#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de visualizaciones avanzadas para reportes de pentest.
Incluye gráficos interactivos, análisis de correlación y timeline de vulnerabilidades.
"""

import json
import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple
from collections import Counter, defaultdict
from dataclasses import dataclass

log = logging.getLogger(__name__)


@dataclass
class ChartConfig:
    """Configuración para gráficos."""
    theme: str = "dark"
    width: int = 800
    height: int = 400
    colors: List[str] = None
    
    def __post_init__(self):
        if self.colors is None:
            if self.theme == "dark":
                self.colors = [
                    "#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", 
                    "#feca57", "#ff9ff3", "#54a0ff", "#5f27cd"
                ]
            else:
                self.colors = [
                    "#e74c3c", "#3498db", "#2ecc71", "#f39c12",
                    "#9b59b6", "#1abc9c", "#34495e", "#e67e22"
                ]


class AdvancedVisualizations:
    """Generador de visualizaciones avanzadas para reportes."""
    
    def __init__(self, config: ChartConfig = None):
        self.config = config or ChartConfig()
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    def generate_all_charts(self, data: Dict[str, Any]) -> Dict[str, str]:
        """Genera todos los gráficos disponibles."""
        charts = {}
        
        try:
            # Gráficos básicos
            charts['severity_distribution'] = self.create_severity_pie_chart(data)
            charts['vulnerability_timeline'] = self.create_vulnerability_timeline(data)
            charts['risk_heatmap'] = self.create_risk_heatmap(data)
            
            # Gráficos de correlación
            charts['technology_correlation'] = self.create_technology_correlation_chart(data)
            charts['port_vulnerability_matrix'] = self.create_port_vulnerability_matrix(data)
            
            # Gráficos avanzados
            charts['attack_surface_radar'] = self.create_attack_surface_radar(data)
            charts['compliance_dashboard'] = self.create_compliance_dashboard(data)
            charts['trend_analysis'] = self.create_trend_analysis(data)
            
            self.log.info(f"Generados {len(charts)} gráficos")
            
        except Exception as e:
            self.log.error(f"Error generando gráficos: {e}")
        
        return charts
    
    def create_severity_pie_chart(self, data: Dict[str, Any]) -> str:
        """Crea gráfico de pastel para distribución de severidad."""
        nuclei_data = data.get('nuclei_data', [])
        
        # Contar por severidad
        severity_counts = Counter()
        for vuln in nuclei_data:
            severity = vuln.get('info', {}).get('severity', 'info').lower()
            severity_counts[severity] += 1
        
        # Preparar datos para Chart.js
        chart_data = {
            'type': 'doughnut',
            'data': {
                'labels': list(severity_counts.keys()),
                'datasets': [{
                    'data': list(severity_counts.values()),
                    'backgroundColor': self.config.colors[:len(severity_counts)],
                    'borderWidth': 2,
                    'borderColor': '#2c3e50' if self.config.theme == 'dark' else '#ffffff'
                }]
            },
            'options': {
                'responsive': True,
                'plugins': {
                    'legend': {
                        'position': 'bottom',
                        'labels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                            'font': {'size': 12}
                        }
                    },
                    'title': {
                        'display': True,
                        'text': 'Distribución de Vulnerabilidades por Severidad',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                },
                'animation': {
                    'animateRotate': True,
                    'duration': 1000
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_vulnerability_timeline(self, data: Dict[str, Any]) -> str:
        """Crea timeline de vulnerabilidades por fecha de descubrimiento."""
        nuclei_data = data.get('nuclei_data', [])
        cves_data = data.get('cves_data', [])
        
        # Simular fechas de descubrimiento (en un sistema real, esto vendría de los datos)
        timeline_data = defaultdict(int)
        base_date = datetime.now() - timedelta(days=30)
        
        # Distribuir vulnerabilidades a lo largo del tiempo
        for i, vuln in enumerate(nuclei_data):
            date = base_date + timedelta(days=i % 30)
            date_str = date.strftime('%Y-%m-%d')
            timeline_data[date_str] += 1
        
        # Ordenar por fecha
        sorted_dates = sorted(timeline_data.keys())
        
        chart_data = {
            'type': 'line',
            'data': {
                'labels': sorted_dates,
                'datasets': [{
                    'label': 'Vulnerabilidades Detectadas',
                    'data': [timeline_data[date] for date in sorted_dates],
                    'borderColor': self.config.colors[0],
                    'backgroundColor': self.config.colors[0] + '20',
                    'fill': True,
                    'tension': 0.4,
                    'pointRadius': 4,
                    'pointHoverRadius': 6
                }]
            },
            'options': {
                'responsive': True,
                'scales': {
                    'x': {
                        'title': {
                            'display': True,
                            'text': 'Fecha',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        },
                        'grid': {
                            'color': '#34495e' if self.config.theme == 'dark' else '#ecf0f1'
                        }
                    },
                    'y': {
                        'title': {
                            'display': True,
                            'text': 'Número de Vulnerabilidades',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        },
                        'grid': {
                            'color': '#34495e' if self.config.theme == 'dark' else '#ecf0f1'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'labels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    },
                    'title': {
                        'display': True,
                        'text': 'Timeline de Detección de Vulnerabilidades',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_risk_heatmap(self, data: Dict[str, Any]) -> str:
        """Crea mapa de calor de riesgo por categoría."""
        categories = {
            'Web Applications': len(data.get('nuclei_data', [])),
            'Network Services': len([p for p in data.get('nmap_data', []) if p.get('state') == 'open']),
            'Exposed Directories': len(data.get('dir_brute_data', [])),
            'Leaked Credentials': len(data.get('leaks_data', [])),
            'CVE Vulnerabilities': len(data.get('cves_data', [])),
            'Security Misconfig': len(data.get('security_config_data', []))
        }
        
        # Normalizar valores para el heatmap (0-100)
        max_value = max(categories.values()) if categories.values() else 1
        normalized_data = []
        
        for i, (category, value) in enumerate(categories.items()):
            normalized_value = (value / max_value) * 100
            color_intensity = normalized_value / 100
            
            # Determinar color basado en intensidad
            if color_intensity > 0.7:
                color = '#e74c3c'  # Rojo
            elif color_intensity > 0.4:
                color = '#f39c12'  # Naranja
            elif color_intensity > 0.2:
                color = '#f1c40f'  # Amarillo
            else:
                color = '#2ecc71'  # Verde
            
            normalized_data.append({
                'x': 0,
                'y': i,
                'v': normalized_value,
                'category': category,
                'count': value,
                'color': color
            })
        
        chart_data = {
            'type': 'scatter',
            'data': {
                'datasets': [{
                    'label': 'Risk Level',
                    'data': normalized_data,
                    'backgroundColor': [item['color'] for item in normalized_data],
                    'pointRadius': 20,
                    'pointHoverRadius': 25
                }]
            },
            'options': {
                'responsive': True,
                'scales': {
                    'x': {
                        'display': False
                    },
                    'y': {
                        'type': 'linear',
                        'position': 'left',
                        'ticks': {
                            'callback': "function(value, index, values) { " +
                                f"const categories = {list(categories.keys())}; " +
                                "return categories[value] || ''; }",
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    },
                    'title': {
                        'display': True,
                        'text': 'Mapa de Calor de Riesgo por Categoría',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    },
                    'tooltip': {
                        'callbacks': {
                            'label': "function(context) { return context.raw.category + ': ' + context.raw.count + ' items'; }"
                        }
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_technology_correlation_chart(self, data: Dict[str, Any]) -> str:
        """Crea gráfico de correlación entre tecnologías y vulnerabilidades."""
        nuclei_data = data.get('nuclei_data', [])
        
        # Extraer tecnologías de los tags
        tech_vulns = defaultdict(list)
        for vuln in nuclei_data:
            tags = vuln.get('info', {}).get('tags', [])
            severity = vuln.get('info', {}).get('severity', 'info')
            
            for tag in tags:
                if any(tech in tag.lower() for tech in ['apache', 'nginx', 'php', 'mysql', 'wordpress', 'joomla', 'drupal']):
                    tech_vulns[tag].append(severity)
        
        # Preparar datos para gráfico de barras agrupadas
        technologies = list(tech_vulns.keys())[:10]  # Top 10
        severity_counts = {'critical': [], 'high': [], 'medium': [], 'low': [], 'info': []}
        
        for tech in technologies:
            severities = tech_vulns[tech]
            severity_counter = Counter(severities)
            
            for sev in severity_counts.keys():
                severity_counts[sev].append(severity_counter.get(sev, 0))
        
        datasets = []
        colors = ['#e74c3c', '#e67e22', '#f1c40f', '#3498db', '#95a5a6']
        
        for i, (severity, counts) in enumerate(severity_counts.items()):
            if any(counts):  # Solo incluir si hay datos
                datasets.append({
                    'label': severity.capitalize(),
                    'data': counts,
                    'backgroundColor': colors[i],
                    'borderColor': colors[i],
                    'borderWidth': 1
                })
        
        chart_data = {
            'type': 'bar',
            'data': {
                'labels': technologies,
                'datasets': datasets
            },
            'options': {
                'responsive': True,
                'scales': {
                    'x': {
                        'title': {
                            'display': True,
                            'text': 'Tecnologías',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    },
                    'y': {
                        'title': {
                            'display': True,
                            'text': 'Número de Vulnerabilidades',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'labels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    },
                    'title': {
                        'display': True,
                        'text': 'Correlación Tecnologías vs Vulnerabilidades',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_port_vulnerability_matrix(self, data: Dict[str, Any]) -> str:
        """Crea matriz de puertos vs vulnerabilidades."""
        nmap_data = data.get('nmap_data', [])
        nuclei_data = data.get('nuclei_data', [])
        
        # Obtener puertos abiertos más comunes
        open_ports = []
        for port_info in nmap_data:
            if port_info.get('state') == 'open':
                port = port_info.get('port')
                service = port_info.get('service', {}).get('name', 'unknown')
                open_ports.append(f"{port}/{service}")
        
        port_counter = Counter(open_ports)
        top_ports = [port for port, _ in port_counter.most_common(10)]
        
        # Simular correlación con vulnerabilidades
        matrix_data = []
        for i, port in enumerate(top_ports):
            # Simular número de vulnerabilidades por puerto
            vuln_count = len([v for v in nuclei_data if str(port.split('/')[0]) in str(v)])
            if vuln_count == 0:
                vuln_count = max(1, len(nuclei_data) // (i + 1))  # Distribución simulada
            
            matrix_data.append({
                'x': 0,
                'y': i,
                'v': vuln_count,
                'port': port,
                'vulnerabilities': vuln_count
            })
        
        chart_data = {
            'type': 'scatter',
            'data': {
                'datasets': [{
                    'label': 'Port Vulnerabilities',
                    'data': matrix_data,
                    'backgroundColor': "function(ctx) { " +
                        "const value = ctx.raw.v; " +
                        f"const max = Math.max(...{[item['v'] for item in matrix_data]}); " +
                        "const intensity = value / max; " +
                        "if (intensity > 0.7) return '#e74c3c'; " +
                        "if (intensity > 0.4) return '#f39c12'; " +
                        "if (intensity > 0.2) return '#f1c40f'; " +
                        "return '#2ecc71'; }",
                    'pointRadius': 15,
                    'pointHoverRadius': 20
                }]
            },
            'options': {
                'responsive': True,
                'scales': {
                    'x': {
                        'display': False
                    },
                    'y': {
                        'type': 'linear',
                        'ticks': {
                            'callback': "function(value, index, values) { " +
                                f"const ports = {top_ports}; " +
                                "return ports[value] || ''; }",
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    },
                    'title': {
                        'display': True,
                        'text': 'Matriz Puerto vs Vulnerabilidades',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    },
                    'tooltip': {
                        'callbacks': {
                            'label': "function(context) { return context.raw.port + ': ' + context.raw.vulnerabilities + ' vulnerabilities'; }"
                        }
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_attack_surface_radar(self, data: Dict[str, Any]) -> str:
        """Crea gráfico radar de superficie de ataque."""
        # Calcular métricas de superficie de ataque
        metrics = {
            'Web Applications': min(100, len(data.get('nuclei_data', [])) * 5),
            'Network Services': min(100, len([p for p in data.get('nmap_data', []) if p.get('state') == 'open']) * 10),
            'Exposed Data': min(100, len(data.get('leaks_data', [])) * 20),
            'Misconfigurations': min(100, len(data.get('security_config_data', [])) * 15),
            'Outdated Software': min(100, len(data.get('cves_data', [])) * 8),
            'Social Engineering': min(100, len(data.get('typosquats_data', [])) * 12)
        }
        
        chart_data = {
            'type': 'radar',
            'data': {
                'labels': list(metrics.keys()),
                'datasets': [{
                    'label': 'Attack Surface',
                    'data': list(metrics.values()),
                    'borderColor': self.config.colors[0],
                    'backgroundColor': self.config.colors[0] + '30',
                    'pointBackgroundColor': self.config.colors[0],
                    'pointBorderColor': '#fff',
                    'pointHoverBackgroundColor': '#fff',
                    'pointHoverBorderColor': self.config.colors[0],
                    'borderWidth': 2,
                    'pointRadius': 4
                }]
            },
            'options': {
                'responsive': True,
                'scales': {
                    'r': {
                        'beginAtZero': True,
                        'max': 100,
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        },
                        'grid': {
                            'color': '#34495e' if self.config.theme == 'dark' else '#ecf0f1'
                        },
                        'pointLabels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                            'font': {'size': 12}
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'labels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    },
                    'title': {
                        'display': True,
                        'text': 'Superficie de Ataque',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_compliance_dashboard(self, data: Dict[str, Any]) -> str:
        """Crea dashboard de cumplimiento de seguridad."""
        # Simular métricas de cumplimiento
        compliance_scores = {
            'OWASP Top 10': max(0, 100 - len(data.get('nuclei_data', [])) * 2),
            'NIST Framework': max(0, 100 - len(data.get('security_config_data', [])) * 5),
            'ISO 27001': max(0, 100 - len(data.get('leaks_data', [])) * 10),
            'PCI DSS': max(0, 100 - len([p for p in data.get('nmap_data', []) if p.get('state') == 'open']) * 3),
            'GDPR': max(0, 100 - len(data.get('dir_brute_data', [])) * 4)
        }
        
        chart_data = {
            'type': 'bar',
            'data': {
                'labels': list(compliance_scores.keys()),
                'datasets': [{
                    'label': 'Compliance Score (%)',
                    'data': list(compliance_scores.values()),
                    'backgroundColor': [
                        '#2ecc71' if score >= 80 else '#f39c12' if score >= 60 else '#e74c3c'
                        for score in compliance_scores.values()
                    ],
                    'borderWidth': 1
                }]
            },
            'options': {
                'responsive': True,
                'indexAxis': 'y',
                'scales': {
                    'x': {
                        'beginAtZero': True,
                        'max': 100,
                        'title': {
                            'display': True,
                            'text': 'Puntuación de Cumplimiento (%)',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    },
                    'y': {
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'display': False
                    },
                    'title': {
                        'display': True,
                        'text': 'Dashboard de Cumplimiento',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def create_trend_analysis(self, data: Dict[str, Any]) -> str:
        """Crea análisis de tendencias de seguridad."""
        # Simular datos históricos de tendencias
        months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun']
        
        # Simular tendencias basadas en datos actuales
        current_vulns = len(data.get('nuclei_data', []))
        current_ports = len([p for p in data.get('nmap_data', []) if p.get('state') == 'open'])
        
        vuln_trend = [max(0, current_vulns + (i - 3) * 2) for i in range(6)]
        port_trend = [max(0, current_ports + (i - 3) * 1) for i in range(6)]
        
        chart_data = {
            'type': 'line',
            'data': {
                'labels': months,
                'datasets': [
                    {
                        'label': 'Vulnerabilidades',
                        'data': vuln_trend,
                        'borderColor': self.config.colors[0],
                        'backgroundColor': self.config.colors[0] + '20',
                        'fill': False,
                        'tension': 0.4
                    },
                    {
                        'label': 'Puertos Abiertos',
                        'data': port_trend,
                        'borderColor': self.config.colors[1],
                        'backgroundColor': self.config.colors[1] + '20',
                        'fill': False,
                        'tension': 0.4
                    }
                ]
            },
            'options': {
                'responsive': True,
                'scales': {
                    'x': {
                        'title': {
                            'display': True,
                            'text': 'Mes',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    },
                    'y': {
                        'title': {
                            'display': True,
                            'text': 'Cantidad',
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        },
                        'ticks': {
                            'color': '#bdc3c7' if self.config.theme == 'dark' else '#7f8c8d'
                        }
                    }
                },
                'plugins': {
                    'legend': {
                        'labels': {
                            'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50'
                        }
                    },
                    'title': {
                        'display': True,
                        'text': 'Análisis de Tendencias de Seguridad',
                        'color': '#ecf0f1' if self.config.theme == 'dark' else '#2c3e50',
                        'font': {'size': 16, 'weight': 'bold'}
                    }
                }
            }
        }
        
        return json.dumps(chart_data)
    
    def generate_chart_html(self, chart_data: str, chart_id: str) -> str:
        """Genera HTML para un gráfico específico."""
        return f"""
        <div class="chart-container" style="position: relative; height: {self.config.height}px; width: {self.config.width}px; margin: 20px auto;">
            <canvas id="{chart_id}"></canvas>
        </div>
        <script>
            const ctx_{chart_id} = document.getElementById('{chart_id}').getContext('2d');
            const chart_{chart_id} = new Chart(ctx_{chart_id}, {chart_data});
        </script>
        """
    
    def generate_all_charts_html(self, data: Dict[str, Any]) -> str:
        """Genera HTML completo para todos los gráficos."""
        charts = self.generate_all_charts(data)
        
        html_parts = [
            '<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>',
            '<div class="charts-section">'
        ]
        
        for chart_name, chart_data in charts.items():
            chart_html = self.generate_chart_html(chart_data, chart_name)
            html_parts.append(f'<div class="chart-wrapper">{chart_html}</div>')
        
        html_parts.append('</div>')
        
        return '\n'.join(html_parts)


# ============================================================================
# FUNCIONES DE UTILIDAD
# ============================================================================

def create_visualization_engine(theme: str = "dark") -> AdvancedVisualizations:
    """Factory function para crear motor de visualizaciones."""
    config = ChartConfig(theme=theme)
    return AdvancedVisualizations(config)


def generate_interactive_dashboard(data: Dict[str, Any], theme: str = "dark") -> str:
    """Genera dashboard interactivo completo."""
    viz_engine = create_visualization_engine(theme)
    return viz_engine.generate_all_charts_html(data)