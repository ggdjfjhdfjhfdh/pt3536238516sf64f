"""Fingerprinting de hosts activos mediante curl.
Optimizado para: legibilidad, testabilidad y tolerancia a fallos.
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import List, Dict, Any

from pentest.runners import run_cmd
from pentest.exceptions import FingerprintError
from pentest.config import DEFAULT_TIMEOUT, WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS

log = logging.getLogger(__name__)

# ------------------------- Constantes & helpers -----------------------------
COMMON_HTTPX_ARGS: List[str] = [
    "-json", "-status-code", "-title", "-server", "-ip",
    "-follow-redirects", "-random-agent", "-silent",
]

TECH_DETECT_ARGS = ["-tech-detect"]
BASIC_ARGS       = []  # usado en fallback


def _run_curl_fingerprint(subdomains: Path) -> List[Dict[str, Any]]:
    """Ejecuta curl para fingerprinting básico con evasión anti-WAF universal."""
    import time
    import random
    
    results: List[Dict[str, Any]] = []
    
    # Usar configuración centralizada anti-WAF
    config = WAF_EVASION_CONFIG
    user_agents = WAF_USER_AGENTS
    headers = WAF_COMMON_HEADERS
    
    try:
        raw_content = subdomains.read_text()
        log.info("🔍 [CURL] Contenido crudo del archivo subdomains: %s", repr(raw_content))
        domains = [d.strip() for d in raw_content.splitlines() if d.strip()]
        log.info("🔍 [CURL] Procesando %d dominios", len(domains))
        for i, domain in enumerate(domains):
            log.info("🔍 [CURL] Dominio %d: '%s' (repr: %s)", i+1, domain, repr(domain))
        
        max_domains = config["max_requests_per_domain"]
        for i, domain in enumerate(domains[:max_domains]):
            # Delay aleatorio entre peticiones usando configuración
            if i > 0:
                delay = random.uniform(config["request_delay_min"], config["request_delay_max"])
                log.debug("🔍 [CURL] Esperando %.2f segundos antes de la siguiente petición", delay)
                time.sleep(delay)
            
            for protocol in ['https', 'http']:
                url = f"{protocol}://{domain}"
                try:
                    # Usar User-Agent aleatorio de la configuración
                    user_agent = random.choice(user_agents)
                    
                    # Construir comando curl con configuración anti-WAF
                    curl_cmd = [
                        'curl', '-s', '-I', 
                        '--max-time', str(config["max_time"]),
                        '--connect-timeout', str(config["connect_timeout"]),
                        '--retry', str(config["retry_attempts"]),
                        '--retry-delay', str(config["retry_delay"]),
                        '--location',  # Seguir redirecciones
                        '--max-redirs', str(config["max_redirects"]),
                        '--user-agent', user_agent
                    ]
                    
                    # Añadir headers de la configuración
                    for header_name, header_value in headers.items():
                        curl_cmd.extend(['--header', f'{header_name}: {header_value}'])
                    
                    curl_cmd.append(url)
                    
                    log.info("🔍 [CURL] Intentando %s con User-Agent: %s", url, user_agent[:50] + '...')
                    timeout = config["max_time"] + 10  # Añadir margen al timeout del comando
                    curl_output = run_cmd(curl_cmd, timeout=timeout)
                    
                    if curl_output and 'HTTP/' in curl_output:
                        # Extraer información básica
                        lines = curl_output.split('\n')
                        status_line = lines[0] if lines else ''
                        server_header = ''
                        location_header = ''
                        
                        for line in lines:
                            line_lower = line.lower()
                            if line_lower.startswith('server:'):
                                server_header = line.split(':', 1)[1].strip()
                            elif line_lower.startswith('location:'):
                                location_header = line.split(':', 1)[1].strip()
                        
                        status_code = status_line.split()[1] if len(status_line.split()) > 1 else 'Unknown'
                        
                        result = {
                            'url': url,
                            'host': domain,
                            'status_code': status_code,
                            'server': server_header,
                            'location': location_header
                        }
                        
                        results.append(result)
                        log.info("🔍 [CURL] ✅ %s: %s %s", url, status_code, f"-> {location_header}" if location_header else "")
                        break  # Si funciona con https, no probar http
                        
                except Exception as e:
                    log.warning("🔍 [CURL] ⚠️ Error con %s: %s", url, e)
                    continue
                    
    except Exception as e:
        log.error("🔍 [CURL] ❌ Error en fingerprinting: %s", e)
    
    return results

# --------------------------- API principal ----------------------------------

def fingerprint(subdomains_file: Path, tmp_dir: Path) -> Path:
    """Detecta hosts activos y tecnologías usando curl.

    Retorna la ruta al archivo httpx.json con los resultados.
    Lanza FingerprintError si todas las estrategias fallan.
    """

    log.info("🔍 [FINGERPRINT] Iniciando fingerprinting de hosts activos")
    log.info("🔍 [FINGERPRINT] Archivo de subdominios: %s", subdomains_file)
    log.info("🔍 [FINGERPRINT] Directorio temporal: %s", tmp_dir)
    
    output_file = tmp_dir / "httpx.json"
    log.info("🔍 [FINGERPRINT] Archivo de salida: %s", output_file)

    if not subdomains_file.exists():
        log.error("🔍 [FINGERPRINT] ❌ Archivo de subdominios no encontrado: %s", subdomains_file)
        raise FingerprintError(f"Archivo de subdominios no encontrado: {subdomains_file}")
    
    # Verificar el tamaño del archivo
    file_size = subdomains_file.stat().st_size
    log.info("🔍 [FINGERPRINT] Tamaño del archivo de subdominios: %d bytes", file_size)
    
    # Mostrar contenido del archivo de subdominios
    try:
        content = subdomains_file.read_text().strip()
        log.info("🔍 [FINGERPRINT] Contenido del archivo de subdominios %s:\n%s", subdomains_file, content)
        log.info("🔍 [FINGERPRINT] Contenido crudo del archivo: %s", repr(content))
        if not content:
            log.warning("🔍 [FINGERPRINT] ⚠️ El archivo de subdominios está vacío")
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al leer el archivo de subdominios: %s", e)
    
    # Verificar disponibilidad de curl (reemplazando httpx)
    try:
        version_cmd = ["curl", "--version"]
        log.info("🔍 [FINGERPRINT] Verificando curl con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, timeout=10)
        log.info("🔍 [FINGERPRINT] ✅ Versión de curl: %s", version_output.strip()[:100])
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al verificar curl: %s", e)
        raise FingerprintError(f"curl no está disponible: {e}")

    # Usar curl para fingerprinting básico
    try:
        log.info("🔍 [FINGERPRINT] Ejecutando fingerprinting con curl")
        results = _run_curl_fingerprint(subdomains_file)
        log.info("🔍 [FINGERPRINT] Resultados obtenidos: %d entradas", len(results))
        if results:
            log.info("🔍 [FINGERPRINT] Primer resultado: %s", results[0])
        _write_json(output_file, results)
        log.info("🔍 [FINGERPRINT] ✅ Fingerprinting completado: %d hosts activos", len(results))
        return output_file
    except Exception as exc:
        log.warning("🔍 [FINGERPRINT] ⚠️ curl fingerprinting falló: %s", exc, exc_info=True)

    # Fallback: devolver cada subdominio como host sin metadata
    try:
        log.warning("🔍 [FINGERPRINT] ⚠️ Creando salida mínima a partir de subdomains_file (fallback)")
        domains = [d.strip() for d in subdomains_file.read_text().splitlines() if d.strip()]
        log.info("🔍 [FINGERPRINT] Dominios para fallback: %s", domains)
        fallback = [{"url": f"http://{d}", "host": d} for d in domains]
        log.info("🔍 [FINGERPRINT] Datos de fallback generados: %s", fallback)
        _write_json(output_file, fallback)
        log.info("🔍 [FINGERPRINT] ✅ Fallback generado con %d entradas", len(fallback))
        return output_file
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error en fallback: %s", e)
        _write_json(output_file, [])
        raise FingerprintError(f"Todos los intentos de fingerprinting fallaron: {e}") from e

# ------------------------- util ---------------------------------------------

def _write_json(path: Path, data: Any) -> None:
    json_content = json.dumps(data, indent=2)
    path.write_text(json_content)
    log.info("🔍 [JSON] Archivo escrito: %s", path)
    log.info("🔍 [JSON] Contenido de %s (primeros 500 chars):\n%s", path, json_content[:500])
    log.debug("🔍 [JSON] Contenido completo de %s:\n%s", path, json_content)
