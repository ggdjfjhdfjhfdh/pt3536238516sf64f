"""Fingerprinting de hosts activos mediante curl.
Optimizado para: legibilidad, testabilidad y tolerancia a fallos.
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import List, Dict, Any

from pentest.runners import run_cmd
from pentest.exceptions import FingerprintError
from pentest.config import DEFAULT_TIMEOUT, WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS

log = logging.getLogger(__name__)

# ------------------------- Constantes & helpers -----------------------------
COMMON_HTTPX_ARGS: List[str] = [
    "-json", "-status-code", "-title", "-server", "-ip",
    "-follow-redirects", "-random-agent", "-silent",
]

TECH_DETECT_ARGS = ["-tech-detect"]
BASIC_ARGS       = []  # usado en fallback


def _run_curl_fingerprint(subdomains: Path) -> List[Dict[str, Any]]:
    """Ejecuta fingerprinting con múltiples estrategias anti-WAF."""
    import time
    import random
    import subprocess
    
    results: List[Dict[str, Any]] = []
    
    # Usar configuración centralizada anti-WAF
    config = WAF_EVASION_CONFIG
    user_agents = WAF_USER_AGENTS
    headers = WAF_COMMON_HEADERS
    
    def _try_simple_curl(url: str, timeout: int = 10) -> Dict[str, Any]:
        """Intenta una petición curl simple y rápida."""
        try:
            cmd = [
                'curl', '-s', '-I', '--max-time', str(timeout),
                '--connect-timeout', '5', '--user-agent', 
                'Mozilla/5.0 (compatible; Scanner/1.0)', url
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout + 5)
            if result.returncode == 0 and 'HTTP/' in result.stdout:
                lines = result.stdout.split('\n')
                status_line = lines[0] if lines else ''
                status_code = status_line.split()[1] if len(status_line.split()) > 1 else 'Unknown'
                return {
                    'url': url,
                    'host': url.replace('https://', '').replace('http://', '').split('/')[0],
                    'status_code': status_code,
                    'method': 'simple_curl'
                }
        except Exception as e:
            log.debug(f"Simple curl falló para {url}: {e}")
        return None
    
    try:
        raw_content = subdomains.read_text()
        log.info("🔍 [CURL] Contenido crudo del archivo subdomains: %s", repr(raw_content))
        domains = [d.strip() for d in raw_content.splitlines() if d.strip()]
        log.info("🔍 [CURL] Procesando %d dominios", len(domains))
        for i, domain in enumerate(domains):
            log.info("🔍 [CURL] Dominio %d: '%s' (repr: %s)", i+1, domain, repr(domain))
        
        max_domains = config["max_requests_per_domain"]
        for i, domain in enumerate(domains[:max_domains]):
            # Delay aleatorio entre peticiones usando configuración
            if i > 0:
                delay = random.uniform(config["request_delay_min"], config["request_delay_max"])
                log.debug("🔍 [CURL] Esperando %.2f segundos antes de la siguiente petición", delay)
                time.sleep(delay)
            
            # Estrategia 1: Curl simple y rápido
            found = False
            for protocol in ['https', 'http']:
                url = f"{protocol}://{domain}"
                result = _try_simple_curl(url, timeout=8)
                if result:
                    results.append(result)
                    log.info("🔍 [CURL] ✅ %s: %s (simple)", url, result['status_code'])
                    found = True
                    break
            
            # Si el método simple falló, intentar método complejo como fallback
            if not found:
                log.debug("🔍 [CURL] 🔄 Fallback a método complejo para %s", domain)
                for protocol in ['https', 'http']:
                    url = f"{protocol}://{domain}"
                    try:
                        # Usar User-Agent aleatorio de la configuración
                        user_agent = random.choice(user_agents)
                        
                        # Construir comando curl con configuración anti-WAF reducida
                        curl_cmd = [
                            'curl', '-s', '-I', 
                            '--max-time', '15',  # Timeout más corto
                            '--connect-timeout', '8',
                            '--retry', '0',  # Sin reintentos para ser más rápido
                            '--user-agent', user_agent
                        ]
                        
                        # Solo cabeceras esenciales
                        curl_cmd.extend(['--header', 'Accept: text/html,application/xhtml+xml'])
                        curl_cmd.append(url)
                        
                        log.info("🔍 [CURL] Intentando %s con User-Agent: %s (complex)", url, user_agent[:50] + '...')
                        curl_output = run_cmd(curl_cmd, timeout=20)
                        
                        if curl_output and 'HTTP/' in curl_output:
                            # Extraer información básica
                            lines = curl_output.split('\n')
                            status_line = lines[0] if lines else ''
                            server_header = ''
                            location_header = ''
                            
                            for line in lines:
                                line_lower = line.lower()
                                if line_lower.startswith('server:'):
                                    server_header = line.split(':', 1)[1].strip()
                                elif line_lower.startswith('location:'):
                                    location_header = line.split(':', 1)[1].strip()
                            
                            status_code = status_line.split()[1] if len(status_line.split()) > 1 else 'Unknown'
                            
                            result = {
                                'url': url,
                                'host': domain,
                                'status_code': status_code,
                                'server': server_header,
                                'location': location_header,
                                'method': 'complex_curl'
                            }
                            
                            results.append(result)
                            log.info("🔍 [CURL] ✅ %s: %s %s (complex)", url, status_code, f"-> {location_header}" if location_header else "")
                            break  # Si funciona con https, no probar http
                            
                    except Exception as e:
                        log.warning("🔍 [CURL] ⚠️ Error con %s: %s", url, e)
                        continue
                    
    except Exception as e:
        log.error("🔍 [CURL] ❌ Error en fingerprinting: %s", e)
    
    return results

# --------------------------- API principal ----------------------------------

def fingerprint(subdomains_file: Path, tmp_dir: Path) -> Path:
    """Detecta hosts activos y tecnologías usando curl.

    Retorna la ruta al archivo httpx.json con los resultados.
    Lanza FingerprintError si todas las estrategias fallan.
    """

    log.info("🔍 [FINGERPRINT] Iniciando fingerprinting de hosts activos")
    log.info("🔍 [FINGERPRINT] Archivo de subdominios: %s", subdomains_file)
    log.info("🔍 [FINGERPRINT] Directorio temporal: %s", tmp_dir)
    
    output_file = tmp_dir / "httpx.json"
    log.info("🔍 [FINGERPRINT] Archivo de salida: %s", output_file)

    if not subdomains_file.exists():
        log.error("🔍 [FINGERPRINT] ❌ Archivo de subdominios no encontrado: %s", subdomains_file)
        raise FingerprintError(f"Archivo de subdominios no encontrado: {subdomains_file}")
    
    # Verificar el tamaño del archivo
    file_size = subdomains_file.stat().st_size
    log.info("🔍 [FINGERPRINT] Tamaño del archivo de subdominios: %d bytes", file_size)
    
    # Mostrar contenido del archivo de subdominios
    try:
        content = subdomains_file.read_text().strip()
        log.info("🔍 [FINGERPRINT] Contenido del archivo de subdominios %s:\n%s", subdomains_file, content)
        log.info("🔍 [FINGERPRINT] Contenido crudo del archivo: %s", repr(content))
        if not content:
            log.warning("🔍 [FINGERPRINT] ⚠️ El archivo de subdominios está vacío")
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al leer el archivo de subdominios: %s", e)
    
    # Verificar disponibilidad de curl (reemplazando httpx)
    try:
        version_cmd = ["curl", "--version"]
        log.info("🔍 [FINGERPRINT] Verificando curl con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, timeout=10)
        log.info("🔍 [FINGERPRINT] ✅ Versión de curl: %s", version_output.strip()[:100])
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al verificar curl: %s", e)
        raise FingerprintError(f"curl no está disponible: {e}")

    # Usar curl para fingerprinting básico
    try:
        log.info("🔍 [FINGERPRINT] Ejecutando fingerprinting con curl")
        results = _run_curl_fingerprint(subdomains_file)
        log.info("🔍 [FINGERPRINT] Resultados obtenidos: %d entradas", len(results))
        if results:
            log.info("🔍 [FINGERPRINT] Primer resultado: %s", results[0])
        _write_json(output_file, results)
        log.info("🔍 [FINGERPRINT] ✅ Fingerprinting completado: %d hosts activos", len(results))
        return output_file
    except Exception as exc:
        log.warning("🔍 [FINGERPRINT] ⚠️ curl fingerprinting falló: %s", exc, exc_info=True)

    # Fallback: devolver cada subdominio como host sin metadata
    try:
        log.warning("🔍 [FINGERPRINT] ⚠️ Creando salida mínima a partir de subdomains_file (fallback)")
        domains = [d.strip() for d in subdomains_file.read_text().splitlines() if d.strip()]
        log.info("🔍 [FINGERPRINT] Dominios para fallback: %s", domains)
        fallback = [{"url": f"http://{d}", "host": d} for d in domains]
        log.info("🔍 [FINGERPRINT] Datos de fallback generados: %s", fallback)
        _write_json(output_file, fallback)
        log.info("🔍 [FINGERPRINT] ✅ Fallback generado con %d entradas", len(fallback))
        return output_file
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error en fallback: %s", e)
        _write_json(output_file, [])
        raise FingerprintError(f"Todos los intentos de fingerprinting fallaron: {e}") from e

# ------------------------- util ---------------------------------------------

def _write_json(path: Path, data: Any) -> None:
    json_content = json.dumps(data, indent=2)
    path.write_text(json_content)
    log.info("🔍 [JSON] Archivo escrito: %s", path)
    log.info("🔍 [JSON] Contenido de %s (primeros 500 chars):\n%s", path, json_content[:500])
    log.debug("🔍 [JSON] Contenido completo de %s:\n%s", path, json_content)
