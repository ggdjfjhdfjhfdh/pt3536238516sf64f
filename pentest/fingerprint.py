"""Fingerprinting de hosts activos mediante httpx.
Optimizado para: legibilidad, testabilidad y tolerancia a fallos.
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import List, Dict, Any

from pentest.runners import run_cmd
from pentest.exceptions import FingerprintError
from pentest.config import DEFAULT_TIMEOUT

log = logging.getLogger(__name__)

# ------------------------- Constantes & helpers -----------------------------
COMMON_HTTPX_ARGS: List[str] = [
    "-json", "-status-code", "-title", "-server", "-ip",
    "-follow-redirects", "-random-agent", "-silent",
]

TECH_DETECT_ARGS = ["-tech-detect"]
BASIC_ARGS       = []  # usado en fallback


def _run_curl_fingerprint(subdomains: Path) -> List[Dict[str, Any]]:
    """Ejecuta curl para fingerprinting básico y devuelve lista de resultados."""
    results: List[Dict[str, Any]] = []
    
    try:
        domains = [d.strip() for d in subdomains.read_text().splitlines() if d.strip()]
        log.info("🔍 [CURL] Procesando %d dominios", len(domains))
        
        for domain in domains[:20]:  # Limitar a 20 para evitar timeouts
            for protocol in ['https', 'http']:
                url = f"{protocol}://{domain}"
                try:
                    curl_cmd = [
                        'curl', '-s', '-I', '--max-time', '10',
                        '--user-agent', 'Mozilla/5.0 (compatible; PentestBot/1.0)',
                        url
                    ]
                    
                    curl_output = run_cmd(curl_cmd, timeout=15)
                    if curl_output and 'HTTP/' in curl_output:
                        # Extraer información básica
                        lines = curl_output.split('\n')
                        status_line = lines[0] if lines else ''
                        server_header = ''
                        
                        for line in lines:
                            if line.lower().startswith('server:'):
                                server_header = line.split(':', 1)[1].strip()
                                break
                        
                        status_code = status_line.split()[1] if len(status_line.split()) > 1 else 'Unknown'
                        
                        result = {
                            'url': url,
                            'host': domain,
                            'status_code': status_code,
                            'server': server_header
                        }
                        
                        results.append(result)
                        log.debug("🔍 [CURL] ✅ %s: %s", url, status_code)
                        break  # Si funciona con https, no probar http
                        
                except Exception as e:
                    log.debug("🔍 [CURL] ⚠️ Error con %s: %s", url, e)
                    continue
                    
    except Exception as e:
        log.error("🔍 [CURL] ❌ Error en fingerprinting: %s", e)
    
    return results

# --------------------------- API principal ----------------------------------

def fingerprint(subdomains_file: Path, tmp_dir: Path) -> Path:
    """Detecta hosts activos y tecnologías usando httpx.

    Retorna la ruta al archivo httpx.json con los resultados.
    Lanza FingerprintError si todas las estrategias fallan.
    """

    log.info("🔍 [FINGERPRINT] Iniciando fingerprinting de hosts activos")
    log.info("🔍 [FINGERPRINT] Archivo de subdominios: %s", subdomains_file)
    log.info("🔍 [FINGERPRINT] Directorio temporal: %s", tmp_dir)
    
    output_file = tmp_dir / "httpx.json"
    log.info("🔍 [FINGERPRINT] Archivo de salida: %s", output_file)

    if not subdomains_file.exists():
        log.error("🔍 [FINGERPRINT] ❌ Archivo de subdominios no encontrado: %s", subdomains_file)
        raise FingerprintError(f"Archivo de subdominios no encontrado: {subdomains_file}")
    
    # Verificar el tamaño del archivo
    file_size = subdomains_file.stat().st_size
    log.info("🔍 [FINGERPRINT] Tamaño del archivo de subdominios: %d bytes", file_size)
    
    # Mostrar contenido del archivo de subdominios
    try:
        content = subdomains_file.read_text().strip()
        log.info("🔍 [FINGERPRINT] Contenido del archivo de subdominios %s:\n%s", subdomains_file, content)
        log.info("🔍 [FINGERPRINT] Contenido crudo del archivo: %s", repr(content))
        if not content:
            log.warning("🔍 [FINGERPRINT] ⚠️ El archivo de subdominios está vacío")
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al leer el archivo de subdominios: %s", e)
    
    # Verificar disponibilidad de curl (reemplazando httpx)
    try:
        version_cmd = ["curl", "--version"]
        log.info("🔍 [FINGERPRINT] Verificando curl con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, timeout=10)
        log.info("🔍 [FINGERPRINT] ✅ Versión de curl: %s", version_output.strip()[:100])
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al verificar curl: %s", e)
        raise FingerprintError(f"curl no está disponible: {e}")

    # Usar curl para fingerprinting básico
    try:
        log.info("🔍 [FINGERPRINT] Ejecutando fingerprinting con curl")
        results = _run_curl_fingerprint(subdomains_file)
        log.info("🔍 [FINGERPRINT] Resultados obtenidos: %d entradas", len(results))
        if results:
            log.info("🔍 [FINGERPRINT] Primer resultado: %s", results[0])
        _write_json(output_file, results)
        log.info("🔍 [FINGERPRINT] ✅ Fingerprinting completado: %d hosts activos", len(results))
        return output_file
    except Exception as exc:
        log.warning("🔍 [FINGERPRINT] ⚠️ curl fingerprinting falló: %s", exc, exc_info=True)

    # Fallback: devolver cada subdominio como host sin metadata
    try:
        log.warning("🔍 [FINGERPRINT] ⚠️ Creando salida mínima a partir de subdomains_file (fallback)")
        domains = [d.strip() for d in subdomains_file.read_text().splitlines() if d.strip()]
        log.info("🔍 [FINGERPRINT] Dominios para fallback: %s", domains)
        fallback = [{"url": f"http://{d}", "host": d} for d in domains]
        log.info("🔍 [FINGERPRINT] Datos de fallback generados: %s", fallback)
        _write_json(output_file, fallback)
        log.info("🔍 [FINGERPRINT] ✅ Fallback generado con %d entradas", len(fallback))
        return output_file
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error en fallback: %s", e)
        _write_json(output_file, [])
        raise FingerprintError(f"Todos los intentos de fingerprinting fallaron: {e}") from e

# ------------------------- util ---------------------------------------------

def _write_json(path: Path, data: Any) -> None:
    json_content = json.dumps(data, indent=2)
    path.write_text(json_content)
    log.info("🔍 [JSON] Archivo escrito: %s", path)
    log.info("🔍 [JSON] Contenido de %s (primeros 500 chars):\n%s", path, json_content[:500])
    log.debug("🔍 [JSON] Contenido completo de %s:\n%s", path, json_content)
