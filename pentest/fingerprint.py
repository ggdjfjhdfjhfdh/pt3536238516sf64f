"""Fingerprinting de hosts activos mediante httpx.
Optimizado para: legibilidad, testabilidad y tolerancia a fallos.
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import List, Dict, Any

from pentest.runners import run_cmd
from pentest.exceptions import FingerprintError
from pentest.config import DEFAULT_TIMEOUT

log = logging.getLogger(__name__)

# ------------------------- Constantes & helpers -----------------------------
COMMON_HTTPX_ARGS: List[str] = [
    "-json", "-status-code", "-title", "-server", "-ip",
    "-follow-redirects", "-random-agent", "-silent",
]

TECH_DETECT_ARGS = ["-tech-detect"]
BASIC_ARGS       = []  # usado en fallback


def _run_httpx(subdomains: Path, extra_args: List[str]) -> str:
    """Ejecuta httpx y devuelve stdout como str (puede lanzar excepción)."""
    cmd = [
        "httpx", "-l", str(subdomains), *extra_args,
    ]
    log.info("🔍 [HTTPX] Comando httpx: %s", " ".join(cmd))
    result = run_cmd(cmd, timeout=DEFAULT_TIMEOUT, ignore=True)
    log.info("🔍 [HTTPX] Resultado httpx (primeros 300 chars): %s", result[:300] if result else "(vacío)")
    return result


def _parse_httpx_output(output: str) -> List[Dict[str, Any]]:
    """Convierte la salida línea‑JSON de httpx a lista de dicts."""
    results: List[Dict[str, Any]] = []
    for line in output.splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            results.append(json.loads(line))
        except json.JSONDecodeError:
            log.debug("Línea JSON inválida de httpx: %s", line[:120])
    return results

# --------------------------- API principal ----------------------------------

def fingerprint(subdomains_file: Path, tmp_dir: Path) -> Path:
    """Detecta hosts activos y tecnologías usando httpx.

    Retorna la ruta al archivo httpx.json con los resultados.
    Lanza FingerprintError si todas las estrategias fallan.
    """

    log.info("🔍 [FINGERPRINT] Iniciando fingerprinting de hosts activos")
    log.info("🔍 [FINGERPRINT] Archivo de subdominios: %s", subdomains_file)
    log.info("🔍 [FINGERPRINT] Directorio temporal: %s", tmp_dir)
    
    output_file = tmp_dir / "httpx.json"
    log.info("🔍 [FINGERPRINT] Archivo de salida: %s", output_file)

    if not subdomains_file.exists():
        log.error("🔍 [FINGERPRINT] ❌ Archivo de subdominios no encontrado: %s", subdomains_file)
        raise FingerprintError(f"Archivo de subdominios no encontrado: {subdomains_file}")
    
    # Verificar el tamaño del archivo
    file_size = subdomains_file.stat().st_size
    log.info("🔍 [FINGERPRINT] Tamaño del archivo de subdominios: %d bytes", file_size)
    
    # Mostrar contenido del archivo de subdominios
    try:
        content = subdomains_file.read_text().strip()
        log.info("🔍 [FINGERPRINT] Contenido del archivo de subdominios %s:\n%s", subdomains_file, content)
        log.info("🔍 [FINGERPRINT] Contenido crudo del archivo: %s", repr(content))
        if not content:
            log.warning("🔍 [FINGERPRINT] ⚠️ El archivo de subdominios está vacío")
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al leer el archivo de subdominios: %s", e)
    
    # Verificar disponibilidad de httpx
    try:
        version_cmd = ["httpx", "-version"]
        log.info("🔍 [FINGERPRINT] Verificando httpx con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, timeout=10)
        log.info("🔍 [FINGERPRINT] ✅ Versión de httpx: %s", version_output.strip())
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error al verificar httpx: %s", e)
        raise FingerprintError(f"httpx no está disponible: {e}")

    # Estrategias en orden de preferencia
    strategies = [TECH_DETECT_ARGS, BASIC_ARGS]

    for args in strategies:
        try:
            mode = "completo" if args else "básico"
            log.info("🔍 [FINGERPRINT] Ejecutando httpx (%s)", mode)
            log.info("🔍 [FINGERPRINT] Argumentos httpx: %s", COMMON_HTTPX_ARGS + args)
            raw = _run_httpx(subdomains_file, COMMON_HTTPX_ARGS + args)
            log.info("🔍 [FINGERPRINT] Salida cruda de httpx: %s", raw[:500] if raw else "(vacía)")
            results = _parse_httpx_output(raw)
            log.info("🔍 [FINGERPRINT] Resultados parseados: %d entradas", len(results))
            if results:
                log.info("🔍 [FINGERPRINT] Primer resultado: %s", results[0])
            _write_json(output_file, results)
            log.info("🔍 [FINGERPRINT] ✅ Fingerprinting %s completado: %d hosts activos", mode, len(results))
            return output_file
        except Exception as exc:
            log.warning("🔍 [FINGERPRINT] ⚠️ httpx (%s) falló: %s", mode, exc, exc_info=True)

    # Fallback: devolver cada subdominio como host sin metadata
    try:
        log.warning("🔍 [FINGERPRINT] ⚠️ Creando salida mínima a partir de subdomains_file (fallback)")
        domains = [d.strip() for d in subdomains_file.read_text().splitlines() if d.strip()]
        log.info("🔍 [FINGERPRINT] Dominios para fallback: %s", domains)
        fallback = [{"url": f"http://{d}", "host": d} for d in domains]
        log.info("🔍 [FINGERPRINT] Datos de fallback generados: %s", fallback)
        _write_json(output_file, fallback)
        log.info("🔍 [FINGERPRINT] ✅ Fallback generado con %d entradas", len(fallback))
        return output_file
    except Exception as e:
        log.error("🔍 [FINGERPRINT] ❌ Error en fallback: %s", e)
        _write_json(output_file, [])
        raise FingerprintError(f"Todos los intentos de fingerprinting fallaron: {e}") from e

# ------------------------- util ---------------------------------------------

def _write_json(path: Path, data: Any) -> None:
    json_content = json.dumps(data, indent=2)
    path.write_text(json_content)
    log.info("🔍 [JSON] Archivo escrito: %s", path)
    log.info("🔍 [JSON] Contenido de %s (primeros 500 chars):\n%s", path, json_content[:500])
    log.debug("🔍 [JSON] Contenido completo de %s:\n%s", path, json_content)
