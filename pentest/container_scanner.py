#!/usr/bin/env python3
"""
Container Scanner - Escáner especializado para contenedores Docker y Kubernetes
Parte del sistema de escaneo premium adaptativo
"""

import json
import subprocess
import requests
import time
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import logging

log = logging.getLogger(__name__)

@dataclass
class ContainerScanResult:
    """Resultado del escaneo de contenedores."""
    docker_detected: bool
    kubernetes_detected: bool
    docker_analysis: Dict[str, Any]
    kubernetes_analysis: Dict[str, Any]
    container_vulnerabilities: List[Dict[str, Any]]
    security_misconfigurations: List[Dict[str, Any]]
    exposed_services: List[Dict[str, Any]]
    scan_duration: float
    recommendations: List[str]

class ContainerScanner:
    """Escáner especializado para contenedores y orquestadores."""
    
    def __init__(self):
        self.docker_ports = [2375, 2376, 2377]  # Docker daemon ports
        self.k8s_ports = [6443, 8080, 10250, 10255]  # Kubernetes API ports
        self.registry_ports = [5000]  # Docker registry ports
        
    def detect_docker(self, target: str) -> bool:
        """Detecta la presencia de Docker en el objetivo."""
        try:
            docker_detected, _ = self._detect_docker(target)
            return docker_detected
        except Exception as e:
            log.error(f"Error detectando Docker: {e}")
            return False
    
    def detect_kubernetes(self, target: str) -> bool:
        """Detecta la presencia de Kubernetes en el objetivo."""
        try:
            k8s_detected, _ = self._detect_kubernetes(target)
            return k8s_detected
        except Exception as e:
            log.error(f"Error detectando Kubernetes: {e}")
            return False
    
    def scan_docker_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Escanea vulnerabilidades específicas de Docker."""
        try:
            docker_detected, docker_analysis = self._detect_docker(target)
            if not docker_detected:
                return {'vulnerabilities': [], 'status': 'no_docker_detected'}
            
            vulnerabilities = self._scan_container_vulnerabilities(target, True, False)
            return {
                'vulnerabilities': vulnerabilities,
                'docker_analysis': docker_analysis,
                'status': 'completed'
            }
        except Exception as e:
            log.error(f"Error en escaneo de vulnerabilidades Docker: {e}")
            return {'vulnerabilities': [], 'status': 'error', 'error': str(e)}
    
    def scan_kubernetes_security(self, target: str) -> Dict[str, Any]:
        """Escanea seguridad específica de Kubernetes."""
        try:
            k8s_detected, k8s_analysis = self._detect_kubernetes(target)
            if not k8s_detected:
                return {'vulnerabilities': [], 'status': 'no_kubernetes_detected'}
            
            vulnerabilities = self._scan_container_vulnerabilities(target, False, True)
            return {
                'vulnerabilities': vulnerabilities,
                'kubernetes_analysis': k8s_analysis,
                'status': 'completed'
            }
        except Exception as e:
            log.error(f"Error en escaneo de seguridad Kubernetes: {e}")
            return {'vulnerabilities': [], 'status': 'error', 'error': str(e)}
    
    def detect_misconfigurations(self, target: str) -> List[Dict[str, Any]]:
        """Detecta configuraciones incorrectas de contenedores."""
        try:
            docker_detected, docker_analysis = self._detect_docker(target)
            k8s_detected, k8s_analysis = self._detect_kubernetes(target)
            
            return self._detect_security_misconfigurations(target, docker_analysis, k8s_analysis)
        except Exception as e:
            log.error(f"Error detectando configuraciones incorrectas: {e}")
            return []
    
    def detect_exposed_services(self, target: str) -> List[Dict[str, Any]]:
        """Detecta servicios de contenedores expuestos."""
        try:
            return self._identify_exposed_services(target)
        except Exception as e:
            log.error(f"Error detectando servicios expuestos: {e}")
            return []
    
    def scan_containers(self, target: str, output_dir: Path) -> ContainerScanResult:
        """Ejecuta escaneo completo de contenedores."""
        start_time = time.time()
        
        log.info(f"Iniciando escaneo de contenedores para {target}")
        
        try:
            # 1. Detectar Docker
            docker_detected, docker_analysis = self._detect_docker(target)
            
            # 2. Detectar Kubernetes
            k8s_detected, k8s_analysis = self._detect_kubernetes(target)
            
            # 3. Escanear vulnerabilidades de contenedores
            container_vulns = self._scan_container_vulnerabilities(target, docker_detected, k8s_detected)
            
            # 4. Detectar configuraciones inseguras
            misconfigs = self._detect_security_misconfigurations(target, docker_analysis, k8s_analysis)
            
            # 5. Identificar servicios expuestos
            exposed_services = self._identify_exposed_services(target)
            
            # 6. Generar recomendaciones
            recommendations = self._generate_container_recommendations(
                docker_detected, k8s_detected, docker_analysis, k8s_analysis, 
                container_vulns, misconfigs
            )
            
            scan_duration = time.time() - start_time
            
            return ContainerScanResult(
                docker_detected=docker_detected,
                kubernetes_detected=k8s_detected,
                docker_analysis=docker_analysis,
                kubernetes_analysis=k8s_analysis,
                container_vulnerabilities=container_vulns,
                security_misconfigurations=misconfigs,
                exposed_services=exposed_services,
                scan_duration=scan_duration,
                recommendations=recommendations
            )
            
        except Exception as e:
            log.error(f"Error en escaneo de contenedores: {e}")
            return ContainerScanResult(
                docker_detected=False,
                kubernetes_detected=False,
                docker_analysis={},
                kubernetes_analysis={},
                container_vulnerabilities=[],
                security_misconfigurations=[],
                exposed_services=[],
                scan_duration=time.time() - start_time,
                recommendations=["Error durante el escaneo de contenedores"]
            )
    
    def _detect_docker(self, target: str) -> tuple[bool, Dict[str, Any]]:
        """Detecta Docker daemon y analiza configuración."""
        docker_analysis = {
            'daemon_exposed': False,
            'version': None,
            'api_accessible': False,
            'tls_enabled': False,
            'containers_found': [],
            'images_found': [],
            'networks_found': [],
            'volumes_found': []
        }
        
        try:
            # Verificar puertos Docker
            for port in self.docker_ports:
                if self._check_port_open(target, port):
                    docker_analysis['daemon_exposed'] = True
                    
                    # Intentar acceder a la API de Docker
                    api_url = f"http://{target}:{port}"
                    try:
                        # Verificar versión
                        response = requests.get(f"{api_url}/version", timeout=5)
                        if response.status_code == 200:
                            docker_analysis['api_accessible'] = True
                            version_info = response.json()
                            docker_analysis['version'] = version_info.get('Version')
                            
                            # Listar contenedores
                            containers_resp = requests.get(f"{api_url}/containers/json?all=true", timeout=5)
                            if containers_resp.status_code == 200:
                                docker_analysis['containers_found'] = containers_resp.json()
                            
                            # Listar imágenes
                            images_resp = requests.get(f"{api_url}/images/json", timeout=5)
                            if images_resp.status_code == 200:
                                docker_analysis['images_found'] = images_resp.json()
                            
                            # Listar redes
                            networks_resp = requests.get(f"{api_url}/networks", timeout=5)
                            if networks_resp.status_code == 200:
                                docker_analysis['networks_found'] = networks_resp.json()
                            
                            # Listar volúmenes
                            volumes_resp = requests.get(f"{api_url}/volumes", timeout=5)
                            if volumes_resp.status_code == 200:
                                docker_analysis['volumes_found'] = volumes_resp.json().get('Volumes', [])
                    
                    except requests.RequestException:
                        # Verificar si es HTTPS (TLS habilitado)
                        try:
                            https_response = requests.get(f"https://{target}:{port}/version", 
                                                        timeout=5, verify=False)
                            if https_response.status_code == 200:
                                docker_analysis['tls_enabled'] = True
                                docker_analysis['api_accessible'] = True
                        except:
                            pass
            
            # Verificar Docker Registry
            for port in self.registry_ports:
                if self._check_port_open(target, port):
                    try:
                        registry_url = f"http://{target}:{port}"
                        catalog_resp = requests.get(f"{registry_url}/v2/_catalog", timeout=5)
                        if catalog_resp.status_code == 200:
                            docker_analysis['registry_exposed'] = True
                            docker_analysis['registry_catalog'] = catalog_resp.json()
                    except:
                        pass
            
            return docker_analysis['daemon_exposed'] or docker_analysis.get('registry_exposed', False), docker_analysis
            
        except Exception as e:
            log.error(f"Error detectando Docker: {e}")
            return False, docker_analysis
    
    def _detect_kubernetes(self, target: str) -> tuple[bool, Dict[str, Any]]:
        """Detecta Kubernetes API y analiza configuración."""
        k8s_analysis = {
            'api_server_exposed': False,
            'version': None,
            'authentication_required': True,
            'kubelet_exposed': False,
            'dashboard_exposed': False,
            'etcd_exposed': False,
            'namespaces': [],
            'pods': [],
            'services': [],
            'secrets_accessible': False
        }
        
        try:
            # Verificar API Server (puerto 6443, 8080)
            for port in [6443, 8080]:
                if self._check_port_open(target, port):
                    k8s_analysis['api_server_exposed'] = True
                    
                    # Intentar acceder a la API
                    protocol = "https" if port == 6443 else "http"
                    api_url = f"{protocol}://{target}:{port}"
                    
                    try:
                        # Verificar versión
                        version_resp = requests.get(f"{api_url}/version", 
                                                   timeout=5, verify=False)
                        if version_resp.status_code == 200:
                            k8s_analysis['version'] = version_resp.json()
                            k8s_analysis['authentication_required'] = False
                            
                            # Listar namespaces
                            ns_resp = requests.get(f"{api_url}/api/v1/namespaces", 
                                                 timeout=5, verify=False)
                            if ns_resp.status_code == 200:
                                k8s_analysis['namespaces'] = ns_resp.json().get('items', [])
                            
                            # Listar pods
                            pods_resp = requests.get(f"{api_url}/api/v1/pods", 
                                                    timeout=5, verify=False)
                            if pods_resp.status_code == 200:
                                k8s_analysis['pods'] = pods_resp.json().get('items', [])
                            
                            # Listar servicios
                            svc_resp = requests.get(f"{api_url}/api/v1/services", 
                                                   timeout=5, verify=False)
                            if svc_resp.status_code == 200:
                                k8s_analysis['services'] = svc_resp.json().get('items', [])
                            
                            # Verificar acceso a secrets
                            secrets_resp = requests.get(f"{api_url}/api/v1/secrets", 
                                                       timeout=5, verify=False)
                            if secrets_resp.status_code == 200:
                                k8s_analysis['secrets_accessible'] = True
                    
                    except requests.RequestException:
                        pass
            
            # Verificar Kubelet (puerto 10250, 10255)
            for port in [10250, 10255]:
                if self._check_port_open(target, port):
                    k8s_analysis['kubelet_exposed'] = True
                    
                    try:
                        protocol = "https" if port == 10250 else "http"
                        kubelet_url = f"{protocol}://{target}:{port}"
                        
                        # Verificar métricas
                        metrics_resp = requests.get(f"{kubelet_url}/metrics", 
                                                   timeout=5, verify=False)
                        if metrics_resp.status_code == 200:
                            k8s_analysis['kubelet_metrics_exposed'] = True
                        
                        # Verificar pods
                        pods_resp = requests.get(f"{kubelet_url}/pods", 
                                                timeout=5, verify=False)
                        if pods_resp.status_code == 200:
                            k8s_analysis['kubelet_pods_accessible'] = True
                    
                    except:
                        pass
            
            # Verificar Dashboard (puerto 8443, 9090)
            for port in [8443, 9090]:
                if self._check_port_open(target, port):
                    try:
                        dashboard_url = f"https://{target}:{port}"
                        resp = requests.get(dashboard_url, timeout=5, verify=False)
                        if "kubernetes" in resp.text.lower() or "dashboard" in resp.text.lower():
                            k8s_analysis['dashboard_exposed'] = True
                    except:
                        pass
            
            return k8s_analysis['api_server_exposed'] or k8s_analysis['kubelet_exposed'], k8s_analysis
            
        except Exception as e:
            log.error(f"Error detectando Kubernetes: {e}")
            return False, k8s_analysis
    
    def _scan_container_vulnerabilities(self, target: str, docker_detected: bool, k8s_detected: bool) -> List[Dict[str, Any]]:
        """Escanea vulnerabilidades específicas de contenedores."""
        vulnerabilities = []
        
        try:
            if docker_detected:
                # Vulnerabilidades comunes de Docker
                docker_vulns = [
                    {
                        'type': 'docker_daemon_exposed',
                        'severity': 'CRITICAL',
                        'description': 'Docker daemon expuesto sin autenticación',
                        'impact': 'Acceso completo al host y contenedores',
                        'cve': 'N/A'
                    },
                    {
                        'type': 'privileged_containers',
                        'severity': 'HIGH',
                        'description': 'Contenedores ejecutándose con privilegios elevados',
                        'impact': 'Escape de contenedor posible',
                        'cve': 'N/A'
                    }
                ]
                vulnerabilities.extend(docker_vulns)
            
            if k8s_detected:
                # Vulnerabilidades comunes de Kubernetes
                k8s_vulns = [
                    {
                        'type': 'k8s_api_unauthenticated',
                        'severity': 'CRITICAL',
                        'description': 'API Server de Kubernetes sin autenticación',
                        'impact': 'Control completo del cluster',
                        'cve': 'N/A'
                    },
                    {
                        'type': 'kubelet_exposed',
                        'severity': 'HIGH',
                        'description': 'Kubelet expuesto sin autenticación',
                        'impact': 'Acceso a pods y secretos del nodo',
                        'cve': 'N/A'
                    }
                ]
                vulnerabilities.extend(k8s_vulns)
            
        except Exception as e:
            log.error(f"Error escaneando vulnerabilidades de contenedores: {e}")
        
        return vulnerabilities
    
    def _detect_security_misconfigurations(self, target: str, docker_analysis: Dict, k8s_analysis: Dict) -> List[Dict[str, Any]]:
        """Detecta configuraciones de seguridad incorrectas."""
        misconfigurations = []
        
        try:
            # Configuraciones inseguras de Docker
            if docker_analysis.get('api_accessible') and not docker_analysis.get('tls_enabled'):
                misconfigurations.append({
                    'type': 'docker_no_tls',
                    'severity': 'HIGH',
                    'description': 'Docker API accesible sin TLS',
                    'recommendation': 'Habilitar TLS para la API de Docker'
                })
            
            if docker_analysis.get('registry_exposed'):
                misconfigurations.append({
                    'type': 'docker_registry_exposed',
                    'severity': 'MEDIUM',
                    'description': 'Docker Registry expuesto públicamente',
                    'recommendation': 'Restringir acceso al registry o implementar autenticación'
                })
            
            # Configuraciones inseguras de Kubernetes
            if not k8s_analysis.get('authentication_required'):
                misconfigurations.append({
                    'type': 'k8s_no_auth',
                    'severity': 'CRITICAL',
                    'description': 'API Server sin autenticación requerida',
                    'recommendation': 'Configurar autenticación y autorización RBAC'
                })
            
            if k8s_analysis.get('secrets_accessible'):
                misconfigurations.append({
                    'type': 'k8s_secrets_exposed',
                    'severity': 'HIGH',
                    'description': 'Secrets de Kubernetes accesibles sin autenticación',
                    'recommendation': 'Implementar RBAC para restringir acceso a secrets'
                })
            
            if k8s_analysis.get('dashboard_exposed'):
                misconfigurations.append({
                    'type': 'k8s_dashboard_exposed',
                    'severity': 'MEDIUM',
                    'description': 'Dashboard de Kubernetes expuesto',
                    'recommendation': 'Restringir acceso al dashboard o deshabilitarlo'
                })
            
        except Exception as e:
            log.error(f"Error detectando configuraciones inseguras: {e}")
        
        return misconfigurations
    
    def _identify_exposed_services(self, target: str) -> List[Dict[str, Any]]:
        """Identifica servicios de contenedores expuestos."""
        exposed_services = []
        
        try:
            # Puertos comunes de servicios en contenedores
            common_ports = {
                80: 'HTTP',
                443: 'HTTPS',
                3000: 'Node.js/React Dev Server',
                8080: 'HTTP Alt/Tomcat',
                8443: 'HTTPS Alt',
                9000: 'SonarQube/Portainer',
                9090: 'Prometheus',
                3306: 'MySQL',
                5432: 'PostgreSQL',
                6379: 'Redis',
                27017: 'MongoDB',
                5000: 'Docker Registry',
                2375: 'Docker Daemon',
                2376: 'Docker Daemon TLS',
                6443: 'Kubernetes API',
                10250: 'Kubelet'
            }
            
            for port, service in common_ports.items():
                if self._check_port_open(target, port):
                    exposed_services.append({
                        'port': port,
                        'service': service,
                        'protocol': 'TCP',
                        'status': 'open'
                    })
            
        except Exception as e:
            log.error(f"Error identificando servicios expuestos: {e}")
        
        return exposed_services
    
    def _generate_container_recommendations(self, docker_detected: bool, k8s_detected: bool, 
                                          docker_analysis: Dict, k8s_analysis: Dict,
                                          vulnerabilities: List, misconfigurations: List) -> List[str]:
        """Genera recomendaciones específicas para contenedores."""
        recommendations = []
        
        try:
            if docker_detected:
                recommendations.extend([
                    "Nunca exponer Docker daemon sin autenticación TLS",
                    "Usar usuarios no-root en contenedores",
                    "Evitar ejecutar contenedores en modo privilegiado",
                    "Implementar escaneo de vulnerabilidades en imágenes",
                    "Usar imágenes base mínimas y actualizadas",
                    "Configurar resource limits para contenedores",
                    "Implementar network policies para aislar contenedores",
                    "Usar secrets management para credenciales",
                    "Habilitar logging y monitoreo de contenedores",
                    "Implementar image signing y verification"
                ])
            
            if k8s_detected:
                recommendations.extend([
                    "Configurar RBAC (Role-Based Access Control)",
                    "Habilitar autenticación y autorización en API Server",
                    "Usar Network Policies para segmentación",
                    "Implementar Pod Security Policies/Standards",
                    "Configurar resource quotas y limits",
                    "Habilitar audit logging",
                    "Usar service mesh para comunicación segura",
                    "Implementar secrets encryption at rest",
                    "Configurar admission controllers",
                    "Usar herramientas de compliance como Falco o OPA"
                ])
            
            # Recomendaciones basadas en vulnerabilidades encontradas
            if any(v['severity'] == 'CRITICAL' for v in vulnerabilities):
                recommendations.insert(0, "URGENTE: Vulnerabilidades críticas detectadas - remediar inmediatamente")
            
            # Recomendaciones basadas en configuraciones inseguras
            if any(m['severity'] == 'CRITICAL' for m in misconfigurations):
                recommendations.insert(0, "URGENTE: Configuraciones críticas inseguras detectadas")
            
            # Recomendaciones generales
            recommendations.extend([
                "Implementar continuous security scanning",
                "Usar herramientas de runtime security",
                "Configurar backup y disaster recovery",
                "Implementar incident response plan",
                "Realizar auditorías de seguridad regulares",
                "Mantener actualizados todos los componentes",
                "Implementar zero-trust networking",
                "Usar herramientas de observabilidad y monitoring"
            ])
            
        except Exception as e:
            log.error(f"Error generando recomendaciones: {e}")
            recommendations.append("Error generando recomendaciones específicas")
        
        return recommendations
    
    def _check_port_open(self, target: str, port: int) -> bool:
        """Verifica si un puerto está abierto."""
        try:
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((target, port))
            sock.close()
            return result == 0
        except:
            return False

if __name__ == "__main__":
    # Ejemplo de uso
    import sys
    
    if len(sys.argv) != 2:
        print("Uso: python container_scanner.py <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    output_dir = Path("./container_scan_output")
    output_dir.mkdir(exist_ok=True)
    
    scanner = ContainerScanner()
    result = scanner.scan_containers(target, output_dir)
    
    print(f"\nEscaneo de contenedores completado en {result.scan_duration:.2f} segundos")
    print(f"Docker detectado: {result.docker_detected}")
    print(f"Kubernetes detectado: {result.kubernetes_detected}")
    print(f"Vulnerabilidades encontradas: {len(result.container_vulnerabilities)}")
    print(f"Configuraciones inseguras: {len(result.security_misconfigurations)}")
    print(f"Servicios expuestos: {len(result.exposed_services)}")
    
    if result.recommendations:
        print("\nRecomendaciones principales:")
        for i, rec in enumerate(result.recommendations[:5], 1):
            print(f"{i}. {rec}")