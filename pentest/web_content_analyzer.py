#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Analizador de Contenido Web para Detección de Tecnologías (Versión Simplificada)
Este módulo analiza HTML, CSS y JavaScript para detectar tecnologías web.
"""

import re
import json
import logging
from typing import Dict, List, Set, Optional, Tuple
from urllib.parse import urljoin, urlparse
from dataclasses import dataclass
import time

# Importar BeautifulSoup solo si está disponible
try:
    from bs4 import BeautifulSoup, Comment
    HAS_BS4 = True
except ImportError:
    HAS_BS4 = False
    BeautifulSoup = None
    Comment = None

log = logging.getLogger(__name__)

@dataclass
class TechnologyDetection:
    """Resultado de detección de tecnología."""
    name: str
    version: Optional[str] = None
    confidence: float = 0.0
    evidence: List[str] = None
    category: str = "unknown"
    source: str = "web_content"  # html, css, js, meta
    
    def __post_init__(self):
        if self.evidence is None:
            self.evidence = []

class HTMLAnalyzer:
    """Analizador de contenido HTML."""
    
    def __init__(self):
        self.meta_patterns = {
            # Generadores de sitios
            'generator': {
                'WordPress': [r'WordPress\s*([\d\.]+)?', r'wp-content'],
                'Drupal': [r'Drupal\s*([\d\.]+)?'],
                'Joomla': [r'Joomla!?\s*([\d\.]+)?'],
                'Shopify': [r'Shopify'],
                'Wix': [r'Wix\.com'],
                'Squarespace': [r'Squarespace'],
                'Ghost': [r'Ghost\s*([\d\.]+)?'],
                'Hugo': [r'Hugo\s*([\d\.]+)?'],
                'Jekyll': [r'Jekyll\s*([\d\.]+)?'],
                'Gatsby': [r'Gatsby\s*([\d\.]+)?']
            },
            # Frameworks y librerías
            'framework': {
                'React': [r'React\s*([\d\.]+)?', r'__REACT_DEVTOOLS_GLOBAL_HOOK__'],
                'Vue.js': [r'Vue\.js\s*([\d\.]+)?', r'Vue\s*([\d\.]+)?'],
                'Angular': [r'Angular\s*([\d\.]+)?', r'ng-version'],
                'jQuery': [r'jQuery\s*v?([\d\.]+)?'],
                'Bootstrap': [r'Bootstrap\s*v?([\d\.]+)?'],
                'Foundation': [r'Foundation\s*([\d\.]+)?'],
                'Materialize': [r'Materialize\s*([\d\.]+)?'],
                'Bulma': [r'Bulma\s*([\d\.]+)?']
            }
        }
        
        # Patrones en el HTML
        self.html_patterns = {
            # Scripts y librerías
            'React': [
                r'react(?:\.min)?\.js',
                r'react-dom(?:\.min)?\.js',
                r'__REACT_DEVTOOLS_GLOBAL_HOOK__',
                r'data-reactroot'
            ],
            'Vue.js': [
                r'vue(?:\.min)?\.js',
                r'v-[a-z-]+',
                r'@click',
                r'{{.*}}'
            ],
            'Angular': [
                r'angular(?:\.min)?\.js',
                r'ng-[a-z-]+',
                r'\[\(.*\)\]',
                r'\*ngFor',
                r'\*ngIf'
            ],
            'jQuery': [
                r'jquery(?:-[\d\.]+)?(?:\.min)?\.js',
                r'\$\(',
                r'jQuery'
            ],
            'Bootstrap': [
                r'bootstrap(?:\.min)?\.css',
                r'bootstrap(?:\.min)?\.js',
                r'class=["\'].*\bbtn\b',
                r'class=["\'].*\bcontainer\b',
                r'class=["\'].*\brow\b',
                r'class=["\'].*\bcol-'
            ],
            'WordPress': [
                r'wp-content',
                r'wp-includes',
                r'wp-admin',
                r'wordpress',
                r'/wp-json/'
            ],
            'Drupal': [
                r'sites/default/files',
                r'drupal',
                r'sites/all/modules',
                r'misc/drupal\.js'
            ],
            'Shopify': [
                r'shopify',
                r'cdn\.shopify\.com',
                r'Shopify\.theme'
            ],
            'Google Analytics': [
                r'google-analytics\.com',
                r'gtag\(',
                r'ga\(',
                r'GoogleAnalyticsObject'
            ],
            'Google Tag Manager': [
                r'googletagmanager\.com',
                r'gtm\.js'
            ],
            'Font Awesome': [
                r'font-awesome',
                r'fa-[a-z-]+',
                r'fas\s',
                r'far\s',
                r'fab\s'
            ],
            'Cloudflare': [
                r'cloudflare',
                r'cf-ray',
                r'__cf_bm'
            ]
        }
    
    def analyze(self, html_content: str, url: str = "") -> List[TechnologyDetection]:
        """Analiza contenido HTML para detectar tecnologías."""
        detections = []
        
        try:
            # Analizar patrones en HTML (sin BeautifulSoup)
            detections.extend(self._analyze_html_patterns(html_content))
            
            # Analizar meta tags con regex
            detections.extend(self._analyze_meta_tags_regex(html_content))
            
            # Si BeautifulSoup está disponible, usar análisis avanzado
            if HAS_BS4:
                soup = BeautifulSoup(html_content, 'html.parser')
                detections.extend(self._analyze_scripts(soup, url))
                detections.extend(self._analyze_css_links(soup, url))
                detections.extend(self._analyze_comments(soup))
            
        except Exception as e:
            log.error(f"Error analizando HTML: {e}")
        
        return self._deduplicate_detections(detections)
    
    def _analyze_meta_tags_regex(self, html_content: str) -> List[TechnologyDetection]:
        """Analiza meta tags usando regex."""
        detections = []
        
        # Buscar meta generator
        generator_match = re.search(r'<meta[^>]*name=["\']generator["\'][^>]*content=["\']([^"\'>]+)["\']', html_content, re.IGNORECASE)
        if generator_match:
            content = generator_match.group(1)
            for category, patterns in self.meta_patterns.items():
                for tech, regexes in patterns.items():
                    for regex in regexes:
                        match = re.search(regex, content, re.IGNORECASE)
                        if match:
                            version = match.group(1) if match.groups() else None
                            detections.append(TechnologyDetection(
                                name=tech,
                                version=version,
                                confidence=0.9,
                                evidence=[f"Meta generator: {content}"],
                                category=category,
                                source="meta"
                            ))
        
        return detections
    
    def _analyze_scripts(self, soup, url: str) -> List[TechnologyDetection]:
        """Analiza tags de script."""
        detections = []
        
        if not soup:
            return detections
        
        scripts = soup.find_all('script')
        for script in scripts:
            src = script.get('src', '')
            content = script.string or ''
            
            # Analizar src de scripts
            if src:
                for tech, patterns in self.html_patterns.items():
                    for pattern in patterns:
                        if re.search(pattern, src, re.IGNORECASE):
                            detections.append(TechnologyDetection(
                                name=tech,
                                confidence=0.8,
                                evidence=[f"Script src: {src}"],
                                category="javascript",
                                source="script"
                            ))
            
            # Analizar contenido de scripts
            if content:
                for tech, patterns in self.html_patterns.items():
                    for pattern in patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            detections.append(TechnologyDetection(
                                name=tech,
                                confidence=0.7,
                                evidence=[f"Script content pattern: {pattern}"],
                                category="javascript",
                                source="script"
                            ))
        
        return detections
    
    def _analyze_css_links(self, soup, url: str) -> List[TechnologyDetection]:
        """Analiza enlaces CSS."""
        detections = []
        
        if not soup:
            return detections
        
        links = soup.find_all('link', rel='stylesheet')
        for link in links:
            href = link.get('href', '')
            
            if href:
                for tech, patterns in self.html_patterns.items():
                    for pattern in patterns:
                        if re.search(pattern, href, re.IGNORECASE):
                            detections.append(TechnologyDetection(
                                name=tech,
                                confidence=0.8,
                                evidence=[f"CSS link: {href}"],
                                category="css",
                                source="css"
                            ))
        
        return detections
    
    def _analyze_comments(self, soup) -> List[TechnologyDetection]:
        """Analiza comentarios HTML."""
        detections = []
        
        if not soup or not Comment:
            return detections
        
        comments = soup.find_all(string=lambda text: isinstance(text, Comment))
        for comment in comments:
            comment_text = str(comment).strip()
            
            for tech, patterns in self.html_patterns.items():
                for pattern in patterns:
                    if re.search(pattern, comment_text, re.IGNORECASE):
                        detections.append(TechnologyDetection(
                            name=tech,
                            confidence=0.6,
                            evidence=[f"HTML comment: {comment_text[:100]}..."],
                            category="comment",
                            source="comment"
                        ))
        
        return detections
    
    def _analyze_html_patterns(self, html_content: str) -> List[TechnologyDetection]:
        """Analiza patrones en el HTML completo."""
        detections = []
        
        for tech, patterns in self.html_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, html_content, re.IGNORECASE)
                if matches:
                    # Extraer versión si es posible
                    version = None
                    for match in matches:
                        if isinstance(match, str) and re.search(r'[\d\.]+', match):
                            version_match = re.search(r'([\d\.]+)', match)
                            if version_match:
                                version = version_match.group(1)
                                break
                    
                    detections.append(TechnologyDetection(
                        name=tech,
                        version=version,
                        confidence=0.7,
                        evidence=[f"HTML pattern: {pattern} ({len(matches)} matches)"],
                        category="html",
                        source="html"
                    ))
        
        return detections
    
    def _deduplicate_detections(self, detections: List[TechnologyDetection]) -> List[TechnologyDetection]:
        """Elimina detecciones duplicadas y consolida evidencia."""
        tech_map = {}
        
        for detection in detections:
            key = detection.name.lower()
            
            if key in tech_map:
                # Combinar evidencia y usar la mayor confianza
                existing = tech_map[key]
                existing.evidence.extend(detection.evidence)
                existing.confidence = max(existing.confidence, detection.confidence)
                
                # Usar la versión más específica
                if detection.version and (not existing.version or len(detection.version) > len(existing.version)):
                    existing.version = detection.version
            else:
                tech_map[key] = detection
        
        return list(tech_map.values())

class CSSAnalyzer:
    """Analizador de contenido CSS."""
    
    def __init__(self):
        self.css_patterns = {
            'Bootstrap': [
                r'\.btn\b',
                r'\.container\b',
                r'\.row\b',
                r'\.col-',
                r'@media\s*\([^)]*\)\s*{[^}]*\.col-'
            ],
            'Foundation': [
                r'\.foundation-',
                r'\.grid-container\b',
                r'\.cell\b'
            ],
            'Materialize': [
                r'\.materialize-',
                r'\.waves-effect\b',
                r'\.btn-floating\b'
            ],
            'Bulma': [
                r'\.bulma\b',
                r'\.is-primary\b',
                r'\.column\b'
            ],
            'Tailwind CSS': [
                r'\.text-',
                r'\.bg-',
                r'\.p-\d',
                r'\.m-\d',
                r'\.flex\b'
            ]
        }
    
    def analyze(self, css_content: str) -> List[TechnologyDetection]:
        """Analiza contenido CSS para detectar frameworks."""
        detections = []
        
        for tech, patterns in self.css_patterns.items():
            for pattern in patterns:
                if re.search(pattern, css_content, re.IGNORECASE):
                    detections.append(TechnologyDetection(
                        name=tech,
                        confidence=0.7,
                        evidence=[f"CSS pattern: {pattern}"],
                        category="css-framework",
                        source="css"
                    ))
                    break  # Solo una detección por tecnología
        
        return detections

class JavaScriptAnalyzer:
    """Analizador de contenido JavaScript."""
    
    def __init__(self):
        self.js_patterns = {
            'jQuery': [
                r'jQuery\s*=',
                r'\$\s*=\s*jQuery',
                r'\$\(',
                r'\.jquery\b'
            ],
            'React': [
                r'React\.',
                r'ReactDOM\.',
                r'createElement\(',
                r'useState\(',
                r'useEffect\('
            ],
            'Vue.js': [
                r'Vue\.',
                r'new Vue\(',
                r'v-model',
                r'v-if',
                r'v-for'
            ],
            'Angular': [
                r'angular\.',
                r'ng\.',
                r'@Component',
                r'@Injectable',
                r'ngOnInit'
            ],
            'Lodash': [
                r'_\.',
                r'lodash',
                r'\.forEach\(',
                r'\.map\('
            ],
            'Moment.js': [
                r'moment\(',
                r'moment\.',
                r'\.format\('
            ],
            'D3.js': [
                r'd3\.',
                r'\.select\(',
                r'\.selectAll\('
            ]
        }
    
    def analyze(self, js_content: str) -> List[TechnologyDetection]:
        """Analiza contenido JavaScript para detectar librerías."""
        detections = []
        
        for tech, patterns in self.js_patterns.items():
            for pattern in patterns:
                if re.search(pattern, js_content, re.IGNORECASE):
                    detections.append(TechnologyDetection(
                        name=tech,
                        confidence=0.8,
                        evidence=[f"JS pattern: {pattern}"],
                        category="javascript-library",
                        source="javascript"
                    ))
                    break  # Solo una detección por tecnología
        
        return detections

class WebContentAnalyzer:
    """Analizador principal de contenido web."""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.html_analyzer = HTMLAnalyzer()
        self.css_analyzer = CSSAnalyzer()
        self.js_analyzer = JavaScriptAnalyzer()
    
    def analyze_content(self, html_content: str = None, css_content: str = None, js_content: str = None, url: str = "") -> Dict[str, List[TechnologyDetection]]:
        """Analiza contenido web directo."""
        results = {
            'html': [],
            'css': [],
            'javascript': [],
            'summary': []
        }
        
        try:
            # Analizar HTML
            if html_content:
                results['html'] = self.html_analyzer.analyze(html_content, url)
            
            # Analizar CSS
            if css_content:
                results['css'] = self.css_analyzer.analyze(css_content)
            
            # Analizar JavaScript
            if js_content:
                results['javascript'] = self.js_analyzer.analyze(js_content)
            
            # Consolidar resultados
            all_detections = results['html'] + results['css'] + results['javascript']
            results['summary'] = self._consolidate_detections(all_detections)
            
        except Exception as e:
            log.error(f"Error analizando contenido web: {e}")
        
        return results
    
    def _consolidate_detections(self, detections: List[TechnologyDetection]) -> List[TechnologyDetection]:
        """Consolida detecciones de múltiples fuentes."""
        tech_map = {}
        
        for detection in detections:
            key = detection.name.lower()
            
            if key in tech_map:
                existing = tech_map[key]
                # Combinar evidencia
                existing.evidence.extend(detection.evidence)
                # Usar la mayor confianza
                existing.confidence = max(existing.confidence, detection.confidence)
                # Usar la versión más específica
                if detection.version and (not existing.version or len(detection.version) > len(existing.version)):
                    existing.version = detection.version
            else:
                tech_map[key] = detection
        
        # Ordenar por confianza
        return sorted(tech_map.values(), key=lambda x: x.confidence, reverse=True)