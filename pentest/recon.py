"""MÃ³dulo para reconocimiento de subdominios."""

import json
import logging
import os
from pathlib import Path
from typing import List, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

from pentest.runners import run_cmd
from pentest.exceptions import ReconError
from pentest.config import DEFAULT_TIMEOUT, AMASS_TIMEOUT

# ConfiguraciÃ³n de logging
log = logging.getLogger(__name__)

def check_tools_availability():
    """Verifica que las herramientas necesarias estÃ©n disponibles."""
    tools = {
        'subfinder': ['-version'],
        'amass': ['-version']
    }
    for tool, version_args in tools.items():
        try:
            run_cmd([tool] + version_args, ignore=True)
            log.info(f'âœ… {tool} estÃ¡ disponible')
        except Exception as e:
            log.error(f'âŒ {tool} no estÃ¡ disponible: {e}')

# Verificar disponibilidad de herramientas al cargar el mÃ³dulo
check_tools_availability()

def recon(domain: str, tmp_dir: Path, *, brute: bool = False) -> Path:
    """Realiza reconocimiento de subdominios utilizando amass y subfinder.
    
    Args:
        domain: Dominio objetivo
        tmp_dir: Directorio temporal para almacenar resultados
        brute: Si se debe realizar fuerza bruta (mÃ¡s lento pero mÃ¡s completo)
        
    Returns:
        Path al archivo JSON con los subdominios encontrados
        
    Raises:
        ReconError: Si fallan todas las herramientas de reconocimiento
    """
    log.info("ğŸ” [RECON] Iniciando reconocimiento de subdominios para %s", domain)
    log.info("ğŸ” [RECON] Directorio temporal: %s", tmp_dir)
    log.info("ğŸ” [RECON] Modo brute force: %s", brute)
    
    output_file = tmp_dir / "subdomains.txt"
    subdomains = set()
    
    # Log del entorno
    import os
    log.info("ğŸ” [RECON] Variables de entorno relevantes:")
    log.info("ğŸ” [RECON] PATH: %s", os.environ.get('PATH', 'No definido'))
    log.info("ğŸ” [RECON] HOME: %s", os.environ.get('HOME', 'No definido'))
    log.info("ğŸ” [RECON] PWD: %s", os.environ.get('PWD', 'No definido'))

    with ThreadPoolExecutor(max_workers=2) as executor:
        subfinder_future = executor.submit(run_subfinder, domain)
        amass_future = executor.submit(run_amass, domain)

        # Collect results from both futures
        subfinder_result = []
        amass_result = []

        try:
            subfinder_result = subfinder_future.result()
            log.info("Subfinder completÃ³. EncontrÃ³ %d subdominios.", len(subfinder_result))
            subdomains.update(subfinder_result)
        except Exception as e:
            log.error("Error al obtener resultados de Subfinder: %s", e)

        try:
            amass_result = amass_future.result()
            log.info("Amass completÃ³. EncontrÃ³ %d subdominios.", len(amass_result))
            subdomains.update(amass_result)
        except Exception as e:
            log.error("Error al obtener resultados de Amass: %s", e)

    log.info("Total de subdominios encontrados antes de guardar: %d", len(subdomains))

    # Si no se encontraron subdominios, aÃ±adir el dominio principal
    if not subdomains:
        log.warning("ğŸ” [RECON] âš ï¸ No se encontraron subdominios, aÃ±adiendo dominio principal: %s", domain)
        subdomains.add(domain)
    
    log.info("ğŸ” [RECON] Total de subdominios Ãºnicos encontrados: %d", len(subdomains))
    log.info("ğŸ” [RECON] Lista de subdominios: %s", sorted(list(subdomains)))
    
    # Escribir subdominios al archivo
    try:
        with open(output_file, "w") as f:
            for subdomain in sorted(subdomains):
                f.write(f"{subdomain}\n")
        
        # Verificar que el archivo se escribiÃ³ correctamente
        if output_file.exists():
            file_size = output_file.stat().st_size
            log.info("ğŸ” [RECON] âœ… Archivo %s creado exitosamente (tamaÃ±o: %d bytes)", output_file, file_size)
            
            # Leer y mostrar el contenido del archivo para verificaciÃ³n
            with open(output_file, "r") as f:
                content = f.read().strip()
                log.info("ğŸ” [RECON] Contenido del archivo subdomains.txt: %s", content)
        else:
            log.error("ğŸ” [RECON] âŒ Error: El archivo %s no se creÃ³", output_file)
            
    except Exception as e:
        log.error("ğŸ” [RECON] âŒ Error al escribir archivo %s: %s", output_file, e)
        raise ReconError(f"Error al escribir archivo de subdominios: {e}")
    
    log.info("ğŸ” [RECON] âœ… Reconocimiento completado. %d subdominios guardados en %s", len(subdomains), output_file)
    return output_file

# Helper functions for running tools
def run_subfinder(domain: str) -> List[str]:
    log.info("ğŸ”§ [SUBFINDER] Ejecutando subfinder para %s", domain)
    try:
        # Primero verificar si subfinder estÃ¡ disponible
        version_cmd = ["subfinder", "-version"]
        log.info("ğŸ”§ [SUBFINDER] Verificando disponibilidad con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, ignore=True, timeout=10)
        log.info("ğŸ”§ [SUBFINDER] VersiÃ³n de subfinder: %s", version_output.strip())
        log.info("ğŸ”§ [SUBFINDER] âœ… Subfinder estÃ¡ disponible")
    except Exception as e:
        log.error("ğŸ”§ [SUBFINDER] âŒ Error al verificar la versiÃ³n de subfinder: %s", e)
        log.error("ğŸ”§ [SUBFINDER] âŒ Subfinder no estÃ¡ disponible o no funciona correctamente")
        return []

    try:
        subfinder_cmd = ["subfinder", "-d", domain, "-silent", "-o", "/dev/stdout"]
        log.info("ğŸ”§ [SUBFINDER] Ejecutando comando: %s", " ".join(subfinder_cmd))
        subfinder_output = run_cmd(subfinder_cmd, timeout=120)
        log.info("ğŸ”§ [SUBFINDER] Salida cruda (primeros 500 chars): %s", subfinder_output[:500])
        
        if subfinder_output:
            found = [line.strip() for line in subfinder_output.split("\n") if line.strip()]
            log.info("ğŸ”§ [SUBFINDER] âœ… Subfinder encontrÃ³ %d subdominios", len(found))
            if found:
                log.info("ğŸ”§ [SUBFINDER] Primeros 5 subdominios: %s", found[:5])
            return found
        else:
            log.warning("ğŸ”§ [SUBFINDER] âš ï¸ Subfinder no devolviÃ³ ninguna salida.")
            return []
    except Exception as e:
        log.error("ğŸ”§ [SUBFINDER] âŒ Error ejecutando subfinder: %s", e)
        log.error("ğŸ”§ [SUBFINDER] âŒ Tipo de error: %s", type(e).__name__)
        return []

def run_amass(domain: str, *, brute: bool = False) -> List[str]:
    log.info("ğŸ”§ [AMASS] Ejecutando amass para %s (brute=%s)", domain, brute)
    try:
        # Primero verificar si amass estÃ¡ disponible
        version_cmd = ["amass", "-version"]
        log.info("ğŸ”§ [AMASS] Verificando disponibilidad con comando: %s", " ".join(version_cmd))
        version_output = run_cmd(version_cmd, ignore=True, timeout=10)
        log.info("ğŸ”§ [AMASS] VersiÃ³n de amass: %s", version_output.strip())
        log.info("ğŸ”§ [AMASS] âœ… Amass estÃ¡ disponible")
    except Exception as e:
        log.error("ğŸ”§ [AMASS] âŒ Error al verificar la versiÃ³n de amass: %s", e)
        log.error("ğŸ”§ [AMASS] âŒ Amass no estÃ¡ disponible o no funciona correctamente")
        return []

    try:
        amass_cmd = ["amass", "enum", "-d", domain, "-silent"]
        if brute:
            amass_cmd.append("-brute")
        log.info("ğŸ”§ [AMASS] Ejecutando comando: %s", " ".join(amass_cmd))
        amass_output = run_cmd(amass_cmd, timeout=300)
        log.info("ğŸ”§ [AMASS] Salida cruda (primeros 500 chars): %s", amass_output[:500])
        
        if amass_output:
            found = [line.strip() for line in amass_output.splitlines() 
                    if line.strip() and domain in line.strip()]
            log.info("ğŸ”§ [AMASS] âœ… Amass encontrÃ³ %d subdominios", len(found))
            if found:
                log.info("ğŸ”§ [AMASS] Primeros 5 subdominios: %s", found[:5])
            return found
        else:
            log.warning("ğŸ”§ [AMASS] âš ï¸ Amass no devolviÃ³ ninguna salida.")
            return []
    except Exception as e:
        log.error("ğŸ”§ [AMASS] âŒ Error al ejecutar amass: %s", e)
        log.error("ğŸ”§ [AMASS] âŒ Tipo de error: %s", type(e).__name__)
        return []