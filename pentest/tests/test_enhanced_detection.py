#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tests para el sistema mejorado de detección de tecnologías.
Incluye tests unitarios, de integración y de rendimiento.
"""

import unittest
import tempfile
import json
import time
import os
import sys
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock
from typing import Dict, Any, List

# Agregar el directorio padre al path para importar módulos
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from enhanced_fingerprint import EnhancedTechDetector
    from tech_mapping import TechMapper
    from metrics import TechDetectionMetrics
    from tool_validator import ExternalToolValidator, ToolStatus, ToolInfo
    from enhanced_integration import EnhancedTechIntegrator
except ImportError as e:
    print(f"Error importando módulos: {e}")
    sys.exit(1)

class TestEnhancedTechDetector(unittest.TestCase):
    """Tests para el detector mejorado de tecnologías."""
    
    def setUp(self):
        """Configuración inicial para cada test."""
        self.config = {
            "cache_enabled": False,  # Deshabilitar cache para tests
            "max_workers": 2,
            "timeout": 10,
            "enable_parallel": False
        }
        self.detector = EnhancedTechDetector(config=self.config)
        self.test_url = "https://httpbin.org/html"
    
    def test_detector_initialization(self):
        """Test de inicialización del detector."""
        self.assertIsNotNone(self.detector)
        self.assertEqual(self.detector.config["max_workers"], 2)
        self.assertEqual(self.detector.config["timeout"], 10)
    
    @patch('subprocess.run')
    def test_wappalyzer_detection(self, mock_subprocess):
        """Test de detección con Wappalyzer."""
        # Mock de respuesta de Wappalyzer
        mock_response = {
            "technologies": [
                {
                    "name": "Nginx",
                    "confidence": 100,
                    "version": "1.18.0",
                    "categories": ["Web servers"]
                }
            ]
        }
        
        mock_subprocess.return_value.returncode = 0
        mock_subprocess.return_value.stdout = json.dumps(mock_response)
        mock_subprocess.return_value.stderr = ""
        
        # Configurar herramientas disponibles
        self.detector.set_available_tools(["wappalyzer"])
        
        result = self.detector._detect_with_wappalyzer(self.test_url)
        
        self.assertIsNotNone(result)
        self.assertIn("technologies", result)
        self.assertEqual(len(result["technologies"]), 1)
        self.assertEqual(result["technologies"][0]["name"], "Nginx")
    
    @patch('subprocess.run')
    def test_whatweb_detection(self, mock_subprocess):
        """Test de detección con WhatWeb."""
        # Mock de respuesta de WhatWeb
        mock_output = "http://example.com [200 OK] Apache[2.4.41], Country[UNITED STATES][US], HTTPServer[Apache/2.4.41], IP[93.184.216.34], Title[Example Domain]"
        
        mock_subprocess.return_value.returncode = 0
        mock_subprocess.return_value.stdout = mock_output
        mock_subprocess.return_value.stderr = ""
        
        self.detector.set_available_tools(["whatweb"])
        
        result = self.detector._detect_with_whatweb(self.test_url)
        
        self.assertIsNotNone(result)
        self.assertIn("technologies", result)
        # Verificar que Apache fue detectado
        apache_found = any(tech["name"] == "Apache" for tech in result["technologies"])
        self.assertTrue(apache_found)
    
    def test_builtin_detection(self):
        """Test de detección incorporada."""
        # Mock de respuesta HTTP
        mock_response = Mock()
        mock_response.headers = {
            "Server": "nginx/1.18.0",
            "X-Powered-By": "PHP/7.4.3"
        }
        mock_response.text = "<html><head><title>Test</title></head><body><script src='jquery-3.6.0.min.js'></script></body></html>"
        mock_response.status_code = 200
        
        with patch('requests.get', return_value=mock_response):
            result = self.detector._detect_builtin(self.test_url)
        
        self.assertIsNotNone(result)
        self.assertIn("technologies", result)
        
        # Verificar detecciones esperadas
        tech_names = [tech["name"] for tech in result["technologies"]]
        self.assertIn("Nginx", tech_names)
        self.assertIn("PHP", tech_names)
        self.assertIn("jQuery", tech_names)
    
    def test_confidence_calculation(self):
        """Test de cálculo de confianza."""
        detections = [
            {"technologies": [{"name": "Nginx", "confidence": 0.9}], "tool": "wappalyzer"},
            {"technologies": [{"name": "Nginx", "confidence": 0.8}], "tool": "whatweb"},
            {"technologies": [{"name": "PHP", "confidence": 0.7}], "tool": "builtin"}
        ]
        
        result = self.detector._merge_detections(detections)
        
        self.assertIn("technologies", result)
        self.assertIn("confidence_score", result)
        
        # Verificar que Nginx tiene mayor confianza (detectado por múltiples herramientas)
        nginx_tech = next((tech for tech in result["technologies"] if tech["name"] == "Nginx"), None)
        php_tech = next((tech for tech in result["technologies"] if tech["name"] == "PHP"), None)
        
        self.assertIsNotNone(nginx_tech)
        self.assertIsNotNone(php_tech)
        self.assertGreater(nginx_tech["confidence"], php_tech["confidence"])


class TestTechMapper(unittest.TestCase):
    """Tests para el mapeador de tecnologías."""
    
    def setUp(self):
        """Configuración inicial para cada test."""
        # Crear archivo de configuración temporal
        self.temp_config = tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False)
        config_content = """
technology_mappings:
  WordPress:
    nuclei_templates:
      - "wordpress-detect.yaml"
      - "wordpress-version.yaml"
    security_checks:
      - "wp_version_disclosure"
      - "wp_admin_access"
    vulnerabilities:
      - "CVE-2021-34527"
    risk_level: "high"
  
  Nginx:
    nuclei_templates:
      - "nginx-version.yaml"
    security_checks:
      - "nginx_status_page"
    risk_level: "medium"
"""
        self.temp_config.write(config_content)
        self.temp_config.close()
        
        self.mapper = TechMapper(config_file=self.temp_config.name)
    
    def tearDown(self):
        """Limpieza después de cada test."""
        os.unlink(self.temp_config.name)
    
    def test_mapper_initialization(self):
        """Test de inicialización del mapeador."""
        self.assertIsNotNone(self.mapper)
        self.assertIn("WordPress", self.mapper.mappings)
        self.assertIn("Nginx", self.mapper.mappings)
    
    def test_get_nuclei_templates(self):
        """Test de obtención de plantillas Nuclei."""
        technologies = [{"name": "WordPress", "version": "5.8"}]
        templates = self.mapper.get_nuclei_templates(technologies)
        
        self.assertIsInstance(templates, list)
        self.assertIn("wordpress-detect.yaml", templates)
        self.assertIn("wordpress-version.yaml", templates)
    
    def test_get_security_analysis(self):
        """Test de análisis de seguridad."""
        technologies = [
            {"name": "WordPress", "version": "5.8"},
            {"name": "Nginx", "version": "1.18.0"}
        ]
        
        analysis = self.mapper.get_security_analysis(technologies)
        
        self.assertIn("vulnerabilities", analysis)
        self.assertIn("risk_score", analysis)
        self.assertIn("recommendations", analysis)
        
        # Verificar que WordPress tiene mayor riesgo
        self.assertGreater(analysis["risk_score"], 5)  # WordPress es high risk
    
    def test_risk_calculation(self):
        """Test de cálculo de riesgo."""
        # Test con tecnología de alto riesgo
        high_risk_tech = [{"name": "WordPress", "version": "5.8"}]
        high_risk_score = self.mapper._calculate_risk_score(high_risk_tech)
        
        # Test con tecnología de riesgo medio
        medium_risk_tech = [{"name": "Nginx", "version": "1.18.0"}]
        medium_risk_score = self.mapper._calculate_risk_score(medium_risk_tech)
        
        self.assertGreater(high_risk_score, medium_risk_score)


class TestTechDetectionMetrics(unittest.TestCase):
    """Tests para el sistema de métricas."""
    
    def setUp(self):
        """Configuración inicial para cada test."""
        self.metrics = TechDetectionMetrics()
    
    def test_metrics_initialization(self):
        """Test de inicialización de métricas."""
        self.assertIsNotNone(self.metrics)
        self.assertEqual(len(self.metrics.detections), 0)
        self.assertEqual(len(self.metrics.tool_metrics), 0)
    
    def test_record_detection(self):
        """Test de registro de detección."""
        self.metrics.record_detection(
            url="https://example.com",
            technologies_found=3,
            confidence_score=0.85,
            detection_time=2.5,
            tools_used=["wappalyzer", "whatweb"]
        )
        
        self.assertEqual(len(self.metrics.detections), 1)
        self.assertEqual(len(self.metrics.tool_metrics), 2)
        
        detection = self.metrics.detections[0]
        self.assertEqual(detection.url, "https://example.com")
        self.assertEqual(detection.technologies_found, 3)
        self.assertEqual(detection.confidence_score, 0.85)
    
    def test_performance_report(self):
        """Test de reporte de rendimiento."""
        # Registrar varias detecciones
        for i in range(5):
            self.metrics.record_detection(
                url=f"https://example{i}.com",
                technologies_found=i + 1,
                confidence_score=0.8 + (i * 0.02),
                detection_time=1.0 + (i * 0.5),
                tools_used=["wappalyzer"]
            )
        
        report = self.metrics.generate_performance_report()
        
        self.assertIn("total_detections", report)
        self.assertIn("average_detection_time", report)
        self.assertIn("average_confidence", report)
        self.assertIn("tool_usage", report)
        
        self.assertEqual(report["total_detections"], 5)
        self.assertGreater(report["average_detection_time"], 0)
        self.assertGreater(report["average_confidence"], 0.8)
    
    def test_export_metrics(self):
        """Test de exportación de métricas."""
        # Registrar una detección
        self.metrics.record_detection(
            url="https://example.com",
            technologies_found=2,
            confidence_score=0.9,
            detection_time=1.5,
            tools_used=["wappalyzer"]
        )
        
        # Exportar a archivo temporal
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as temp_file:
            temp_path = temp_file.name
        
        try:
            self.metrics.export_metrics(temp_path)
            
            # Verificar que el archivo fue creado y contiene datos válidos
            self.assertTrue(os.path.exists(temp_path))
            
            with open(temp_path, 'r') as f:
                exported_data = json.load(f)
            
            self.assertIn("detections", exported_data)
            self.assertIn("tool_metrics", exported_data)
            self.assertIn("summary", exported_data)
            
        finally:
            if os.path.exists(temp_path):
                os.unlink(temp_path)


class TestExternalToolValidator(unittest.TestCase):
    """Tests para el validador de herramientas externas."""
    
    def setUp(self):
        """Configuración inicial para cada test."""
        self.validator = ExternalToolValidator(timeout=10)
    
    def test_validator_initialization(self):
        """Test de inicialización del validador."""
        self.assertIsNotNone(self.validator)
        self.assertEqual(self.validator.timeout, 10)
    
    @patch('shutil.which')
    @patch('subprocess.run')
    def test_tool_validation_available(self, mock_subprocess, mock_which):
        """Test de validación de herramienta disponible."""
        # Mock herramienta disponible
        mock_which.return_value = "/usr/bin/curl"
        mock_subprocess.return_value.returncode = 0
        mock_subprocess.return_value.stdout = "curl 7.68.0"
        mock_subprocess.return_value.stderr = ""
        
        self.validator._validate_curl()
        
        self.assertIn("curl", self.validator.tools_info)
        tool_info = self.validator.tools_info["curl"]
        self.assertEqual(tool_info.status, ToolStatus.AVAILABLE)
        self.assertEqual(tool_info.path, "/usr/bin/curl")
    
    @patch('shutil.which')
    def test_tool_validation_unavailable(self, mock_which):
        """Test de validación de herramienta no disponible."""
        # Mock herramienta no disponible
        mock_which.return_value = None
        
        self.validator._validate_curl()
        
        self.assertIn("curl", self.validator.tools_info)
        tool_info = self.validator.tools_info["curl"]
        self.assertEqual(tool_info.status, ToolStatus.UNAVAILABLE)
    
    def test_get_available_tools(self):
        """Test de obtención de herramientas disponibles."""
        # Simular algunas herramientas
        self.validator.tools_info = {
            "curl": ToolInfo("curl", ToolStatus.AVAILABLE),
            "wappalyzer": ToolInfo("wappalyzer", ToolStatus.UNAVAILABLE),
            "whatweb": ToolInfo("whatweb", ToolStatus.ERROR)
        }
        
        available = self.validator.get_available_tools()
        
        self.assertEqual(len(available), 1)
        self.assertIn("curl", available)
        self.assertNotIn("wappalyzer", available)
        self.assertNotIn("whatweb", available)


class TestEnhancedTechIntegrator(unittest.TestCase):
    """Tests para el integrador principal."""
    
    def setUp(self):
        """Configuración inicial para cada test."""
        self.config = {
            "enable_enhanced_detection": True,
            "enable_legacy_fallback": False,
            "enable_metrics": False,
            "validate_tools_on_startup": False,
            "cache_enabled": False
        }
        self.integrator = EnhancedTechIntegrator(config=self.config)
    
    def test_integrator_initialization(self):
        """Test de inicialización del integrador."""
        self.assertIsNotNone(self.integrator)
        self.assertFalse(self.integrator.initialized)
    
    @patch.object(EnhancedTechIntegrator, '_validate_external_tools')
    @patch.object(EnhancedTechIntegrator, '_initialize_enhanced_detector')
    @patch.object(EnhancedTechIntegrator, '_initialize_tech_mapper')
    def test_initialize_success(self, mock_mapper, mock_detector, mock_validator):
        """Test de inicialización exitosa."""
        # Mock de inicialización exitosa
        mock_validator.return_value = None
        mock_detector.return_value = None
        mock_mapper.return_value = None
        
        result = self.integrator.initialize()
        
        self.assertTrue(result)
        self.assertTrue(self.integrator.initialized)
    
    def test_get_system_status(self):
        """Test de obtención del estado del sistema."""
        status = self.integrator.get_system_status()
        
        self.assertIn("initialized", status)
        self.assertIn("enhanced_detector", status)
        self.assertIn("tech_mapper", status)
        self.assertIn("config", status)
        
        self.assertFalse(status["initialized"])
        self.assertEqual(status["config"], self.integrator.config)


class TestPerformance(unittest.TestCase):
    """Tests de rendimiento para el sistema mejorado."""
    
    def setUp(self):
        """Configuración inicial para tests de rendimiento."""
        self.config = {
            "cache_enabled": True,
            "max_workers": 4,
            "timeout": 5,
            "enable_parallel": True
        }
    
    def test_detection_performance(self):
        """Test de rendimiento de detección."""
        detector = EnhancedTechDetector(config=self.config)
        
        # Mock de herramientas para evitar llamadas reales
        with patch.object(detector, '_detect_with_wappalyzer', return_value={"technologies": []}):
            with patch.object(detector, '_detect_with_whatweb', return_value={"technologies": []}):
                with patch.object(detector, '_detect_builtin', return_value={"technologies": []}):
                    
                    start_time = time.time()
                    
                    # Ejecutar múltiples detecciones
                    urls = [f"https://example{i}.com" for i in range(10)]
                    for url in urls:
                        detector.detect_technologies(url)
                    
                    total_time = time.time() - start_time
                    avg_time = total_time / len(urls)
                    
                    # Verificar que el tiempo promedio sea razonable
                    self.assertLess(avg_time, 2.0)  # Menos de 2 segundos por detección
    
    def test_cache_performance(self):
        """Test de rendimiento del cache."""
        detector = EnhancedTechDetector(config={"cache_enabled": True})
        
        # Mock de detección que simula tiempo de procesamiento
        def mock_detect(*args, **kwargs):
            time.sleep(0.1)  # Simular 100ms de procesamiento
            return {"technologies": [{"name": "Test", "confidence": 0.9}]}
        
        with patch.object(detector, '_detect_builtin', side_effect=mock_detect):
            url = "https://example.com"
            
            # Primera detección (sin cache)
            start_time = time.time()
            result1 = detector.detect_technologies(url)
            first_time = time.time() - start_time
            
            # Segunda detección (con cache)
            start_time = time.time()
            result2 = detector.detect_technologies(url)
            second_time = time.time() - start_time
            
            # La segunda detección debe ser significativamente más rápida
            self.assertLess(second_time, first_time * 0.5)
            self.assertEqual(result1["technologies"], result2["technologies"])


class TestIntegration(unittest.TestCase):
    """Tests de integración para el sistema completo."""
    
    def test_full_pipeline(self):
        """Test del pipeline completo de detección."""
        config = {
            "enable_enhanced_detection": True,
            "enable_security_analysis": True,
            "enable_metrics": True,
            "validate_tools_on_startup": False,
            "cache_enabled": False
        }
        
        integrator = EnhancedTechIntegrator(config=config)
        
        # Mock de todos los componentes
        with patch.object(integrator, '_validate_external_tools'):
            with patch.object(integrator, '_initialize_enhanced_detector'):
                with patch.object(integrator, '_initialize_tech_mapper'):
                    with patch.object(integrator, '_initialize_metrics'):
                        
                        # Inicializar
                        success = integrator.initialize()
                        self.assertTrue(success)
                        
                        # Mock de detección
                        mock_result = {
                            "technologies": [
                                {"name": "Nginx", "confidence": 0.9, "version": "1.18.0"}
                            ],
                            "confidence_score": 0.9,
                            "tool_coverage": {"wappalyzer": True, "whatweb": False}
                        }
                        
                        with patch.object(integrator, '_run_enhanced_detection', return_value=mock_result):
                            with patch.object(integrator, '_run_security_analysis', return_value={"vulnerabilities": []}):
                                
                                # Ejecutar detección completa
                                result = integrator.detect_technologies("https://example.com")
                                
                                # Verificar resultado
                                self.assertIsNotNone(result)
                                self.assertEqual(result.url, "https://example.com")
                                self.assertEqual(len(result.technologies), 1)
                                self.assertEqual(result.technologies[0]["name"], "Nginx")
                                self.assertGreater(result.confidence_score, 0.8)
                                self.assertGreater(result.detection_time, 0)


def run_tests():
    """Ejecuta todos los tests."""
    # Configurar logging para tests
    import logging
    logging.basicConfig(level=logging.WARNING)
    
    # Crear suite de tests
    test_classes = [
        TestEnhancedTechDetector,
        TestTechMapper,
        TestTechDetectionMetrics,
        TestExternalToolValidator,
        TestEnhancedTechIntegrator,
        TestPerformance,
        TestIntegration
    ]
    
    suite = unittest.TestSuite()
    
    for test_class in test_classes:
        tests = unittest.TestLoader().loadTestsFromTestCase(test_class)
        suite.addTests(tests)
    
    # Ejecutar tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Mostrar resumen
    print(f"\n{'='*60}")
    print(f"RESUMEN DE TESTS")
    print(f"{'='*60}")
    print(f"Tests ejecutados: {result.testsRun}")
    print(f"Errores: {len(result.errors)}")
    print(f"Fallos: {len(result.failures)}")
    print(f"Omitidos: {len(result.skipped) if hasattr(result, 'skipped') else 0}")
    
    if result.errors:
        print(f"\n❌ ERRORES:")
        for test, error in result.errors:
            print(f"  - {test}: {error.split(chr(10))[0]}")
    
    if result.failures:
        print(f"\n❌ FALLOS:")
        for test, failure in result.failures:
            print(f"  - {test}: {failure.split(chr(10))[0]}")
    
    success_rate = ((result.testsRun - len(result.errors) - len(result.failures)) / result.testsRun) * 100
    print(f"\n📊 Tasa de éxito: {success_rate:.1f}%")
    
    if success_rate >= 90:
        print("✅ Tests completados exitosamente")
    elif success_rate >= 70:
        print("⚠️ Tests completados con advertencias")
    else:
        print("❌ Tests fallaron")
    
    return result.wasSuccessful()


if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1)