#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de prueba simple para verificar la correcci√≥n del error de premium_adaptive_scan.
Verifica que los argumentos en core.py se pasen correctamente.
"""

import sys
import re
from pathlib import Path

def test_core_py_arguments():
    """Verifica que core.py pase los argumentos correctos a premium_adaptive_scan_wrapper."""
    print("üîç Verificando argumentos en core.py...")
    
    core_file = Path(__file__).parent / "core.py"
    
    if not core_file.exists():
        print(f"‚ùå No se encontr√≥ core.py en {core_file}")
        return False
    
    with open(core_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Buscar la secci√≥n de premium_adaptive
    premium_adaptive_section = None
    lines = content.split('\n')
    
    for i, line in enumerate(lines):
        if 'elif step_key == "premium_adaptive":' in line:
            # Capturar las siguientes l√≠neas hasta el siguiente elif o else
            section_lines = []
            j = i
            while j < len(lines):
                section_lines.append(lines[j])
                j += 1
                if j < len(lines) and ('elif step_key ==' in lines[j] or lines[j].strip().startswith('elif step_key =')):
                    break
                if j < len(lines) and lines[j].strip() == 'return tuple(args), step_kwargs':
                    section_lines.append(lines[j])
                    break
            premium_adaptive_section = '\n'.join(section_lines)
            break
    
    if not premium_adaptive_section:
        print("‚ùå No se encontr√≥ la secci√≥n premium_adaptive en core.py")
        return False
    
    print("üìã Secci√≥n premium_adaptive encontrada:")
    print(premium_adaptive_section)
    print()
    
    # Verificar que se pase domain como primer argumento
    if 'args = [domain, tmp_dir]' in premium_adaptive_section:
        print("‚úÖ CORRECTO: Se pasa domain como primer argumento")
        correct_args = True
    elif 'args = [finger_file, tmp_dir]' in premium_adaptive_section:
        print("‚ùå ERROR: A√∫n se pasa finger_file como primer argumento")
        correct_args = False
    else:
        print("‚ö†Ô∏è No se pudo determinar los argumentos pasados")
        correct_args = False
    
    # Verificar que finger_file se pase como kwarg
    if 'step_kwargs["finger_file"] = finger_file' in premium_adaptive_section:
        print("‚úÖ CORRECTO: finger_file se pasa como kwarg")
        correct_kwargs = True
    else:
        print("‚ùå ERROR: finger_file no se pasa como kwarg")
        correct_kwargs = False
    
    return correct_args and correct_kwargs

def test_premium_adaptive_scan_signature():
    """Verifica la signatura de premium_adaptive_scan_wrapper."""
    print("\nüîç Verificando signatura de premium_adaptive_scan_wrapper...")
    
    premium_scan_file = Path(__file__).parent / "premium_adaptive_scan.py"
    
    if not premium_scan_file.exists():
        print(f"‚ùå No se encontr√≥ premium_adaptive_scan.py en {premium_scan_file}")
        return False
    
    with open(premium_scan_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Buscar la definici√≥n de la funci√≥n
    pattern = r'def premium_adaptive_scan_wrapper\(([^)]+)\)'
    match = re.search(pattern, content)
    
    if not match:
        print("‚ùå No se encontr√≥ la funci√≥n premium_adaptive_scan_wrapper")
        return False
    
    signature = match.group(1)
    print(f"üìã Signatura encontrada: premium_adaptive_scan_wrapper({signature})")
    
    # Verificar que el primer par√°metro sea target: str
    if signature.strip().startswith('target: str'):
        print("‚úÖ CORRECTO: Primer par√°metro es target: str")
        return True
    else:
        print("‚ùå ERROR: Primer par√°metro no es target: str")
        return False

def test_finger_file_handling():
    """Verifica que se maneje finger_file correctamente en premium_adaptive_scan_wrapper."""
    print("\nüîç Verificando manejo de finger_file...")
    
    premium_scan_file = Path(__file__).parent / "premium_adaptive_scan.py"
    
    with open(premium_scan_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Buscar el manejo de finger_file
    if "finger_file = kwargs.get('finger_file')" in content:
        print("‚úÖ CORRECTO: Se obtiene finger_file de kwargs")
        finger_file_handled = True
    else:
        print("‚ùå ERROR: No se maneja finger_file de kwargs")
        finger_file_handled = False
    
    # Verificar que se carguen los datos del finger_file
    if "kwargs['finger_data'] = finger_data" in content:
        print("‚úÖ CORRECTO: Se cargan datos de finger_file")
        finger_data_loaded = True
    else:
        print("‚ö†Ô∏è ADVERTENCIA: No se cargan datos de finger_file (puede ser opcional)")
        finger_data_loaded = True  # No es cr√≠tico
    
    return finger_file_handled and finger_data_loaded

def main():
    """Funci√≥n principal de prueba."""
    print("üöÄ Verificando correcci√≥n del error de premium_adaptive_scan...")
    print("   Error original: 'PosixPath' object has no attribute 'decode'")
    print()
    
    # Prueba 1: Verificar argumentos en core.py
    test1_passed = test_core_py_arguments()
    
    # Prueba 2: Verificar signatura de la funci√≥n
    test2_passed = test_premium_adaptive_scan_signature()
    
    # Prueba 3: Verificar manejo de finger_file
    test3_passed = test_finger_file_handling()
    
    # Resumen
    print("\nüìä RESUMEN DE VERIFICACIONES:")
    print(f"   Argumentos en core.py: {'‚úÖ PASS' if test1_passed else '‚ùå FAIL'}")
    print(f"   Signatura de funci√≥n: {'‚úÖ PASS' if test2_passed else '‚ùå FAIL'}")
    print(f"   Manejo de finger_file: {'‚úÖ PASS' if test3_passed else '‚ùå FAIL'}")
    
    if test1_passed and test2_passed and test3_passed:
        print("\nüéâ ¬°Todas las verificaciones pasaron!")
        print("   La correcci√≥n del error PosixPath.decode() parece exitosa.")
        print("   Ahora premium_adaptive_scan_wrapper recibe:")
        print("   - target (string) como primer argumento")
        print("   - output_dir (Path) como segundo argumento")
        print("   - finger_file (Path) como kwarg")
        return 0
    else:
        print("\n‚ö†Ô∏è Algunas verificaciones fallaron.")
        print("   La correcci√≥n puede no estar completa.")
        return 1

if __name__ == "__main__":
    sys.exit(main())