#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de mapeo dinámico de tecnologías a plantillas de análisis.
Permite configuración externa y análisis dirigido por tecnología.
"""

import yaml
import json
import logging
from pathlib import Path
from typing import Dict, List, Set, Any, Optional
from dataclasses import dataclass

log = logging.getLogger(__name__)

@dataclass
class TechInfo:
    """Información de una tecnología detectada."""
    name: str
    version: str = ""
    confidence: float = 0.0
    source: str = ""
    categories: List[str] = None
    
    def __post_init__(self):
        if self.categories is None:
            self.categories = []

class DynamicTechMapping:
    """Mapeo dinámico de tecnologías a plantillas de análisis."""
    
    def __init__(self, config_file: Optional[str] = None):
        self.config_file = config_file or str(Path(__file__).parent / 'tech_mappings.yaml')
        self.mappings = self._load_mappings()
        self.confidence_weights = {
            'wappalyzer': 1.0,
            'whatweb': 0.9,
            'httpx': 0.7,
            'custom_patterns': 0.6
        }
        self.vulnerability_db = self._load_vulnerability_mappings()
    
    def _load_mappings(self) -> Dict[str, Any]:
        """Carga mapeos desde archivo YAML configurable."""
        mapping_file = Path(self.config_file)
        
        if mapping_file.exists():
            try:
                with open(mapping_file, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f) or {}
            except Exception as e:
                log.warning(f"Error cargando mapeos desde {mapping_file}: {e}")
        
        # Crear archivo de configuración por defecto si no existe
        default_mappings = self._get_default_mappings()
        self._save_default_config(default_mappings)
        return default_mappings
    
    def _save_default_config(self, mappings: Dict[str, Any]) -> None:
        """Guarda configuración por defecto."""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                yaml.dump(mappings, f, default_flow_style=False, allow_unicode=True)
            log.info(f"Configuración por defecto guardada en {self.config_file}")
        except Exception as e:
            log.error(f"Error guardando configuración por defecto: {e}")
    
    def _get_default_mappings(self) -> Dict[str, Any]:
        """Obtiene mapeos por defecto."""
        return {
            'technology_templates': {
                # CMS
                'wordpress': {
                    'nuclei_templates': [
                        'wordpress-detect',
                        'wordpress-version',
                        'wordpress-plugins',
                        'wordpress-themes',
                        'wordpress-config-backup',
                        'wordpress-admin-panel',
                        'wordpress-xmlrpc',
                        'wordpress-user-enum'
                    ],
                    'security_checks': [
                        'wp_version_disclosure',
                        'wp_admin_access',
                        'wp_config_backup',
                        'wp_plugin_vulnerabilities',
                        'wp_theme_vulnerabilities',
                        'wp_xmlrpc_enabled',
                        'wp_user_enumeration'
                    ],
                    'categories': ['cms', 'php']
                },
                'drupal': {
                    'nuclei_templates': [
                        'drupal-detect',
                        'drupal-version',
                        'drupal-modules',
                        'drupal-admin-panel',
                        'drupal-status-page'
                    ],
                    'security_checks': [
                        'drupal_version_disclosure',
                        'drupal_admin_access',
                        'drupal_module_vulnerabilities',
                        'drupal_status_page_exposed'
                    ],
                    'categories': ['cms', 'php']
                },
                'joomla': {
                    'nuclei_templates': [
                        'joomla-detect',
                        'joomla-version',
                        'joomla-admin-panel',
                        'joomla-config-backup'
                    ],
                    'security_checks': [
                        'joomla_version_disclosure',
                        'joomla_admin_access',
                        'joomla_config_backup'
                    ],
                    'categories': ['cms', 'php']
                },
                
                # Servidores Web
                'nginx': {
                    'nuclei_templates': [
                        'nginx-version',
                        'nginx-status',
                        'nginx-alias-traversal',
                        'nginx-server-status'
                    ],
                    'security_checks': [
                        'nginx_status_page',
                        'nginx_version_disclosure',
                        'nginx_alias_traversal',
                        'nginx_server_tokens'
                    ],
                    'categories': ['web-server']
                },
                'apache': {
                    'nuclei_templates': [
                        'apache-version',
                        'apache-status',
                        'apache-server-info',
                        'apache-server-status'
                    ],
                    'security_checks': [
                        'apache_status_page',
                        'apache_version_disclosure',
                        'apache_server_info',
                        'apache_server_tokens'
                    ],
                    'categories': ['web-server']
                },
                
                # Frameworks JavaScript
                'react': {
                    'nuclei_templates': [
                        'react-detect',
                        'react-dev-tools',
                        'react-source-maps'
                    ],
                    'security_checks': [
                        'react_dev_mode',
                        'react_source_maps_exposed',
                        'react_debug_info'
                    ],
                    'categories': ['javascript-framework', 'frontend']
                },
                'vue.js': {
                    'nuclei_templates': [
                        'vue-detect',
                        'vue-dev-tools',
                        'vue-source-maps'
                    ],
                    'security_checks': [
                        'vue_dev_mode',
                        'vue_source_maps_exposed',
                        'vue_debug_info'
                    ],
                    'categories': ['javascript-framework', 'frontend']
                },
                'angular': {
                    'nuclei_templates': [
                        'angular-detect',
                        'angular-version',
                        'angular-source-maps'
                    ],
                    'security_checks': [
                        'angular_dev_mode',
                        'angular_source_maps_exposed',
                        'angular_debug_info'
                    ],
                    'categories': ['javascript-framework', 'frontend']
                },
                
                # Frameworks Backend
                'laravel': {
                    'nuclei_templates': [
                        'laravel-detect',
                        'laravel-debug',
                        'laravel-env',
                        'laravel-telescope'
                    ],
                    'security_checks': [
                        'laravel_debug_mode',
                        'laravel_env_exposed',
                        'laravel_telescope_exposed',
                        'laravel_log_files'
                    ],
                    'categories': ['php-framework', 'backend']
                },
                'django': {
                    'nuclei_templates': [
                        'django-detect',
                        'django-debug',
                        'django-admin'
                    ],
                    'security_checks': [
                        'django_debug_mode',
                        'django_admin_panel',
                        'django_secret_key_exposure'
                    ],
                    'categories': ['python-framework', 'backend']
                },
                
                # Bases de Datos
                'mysql': {
                    'nuclei_templates': [
                        'mysql-detect',
                        'mysql-version',
                        'mysql-default-creds'
                    ],
                    'security_checks': [
                        'mysql_version_disclosure',
                        'mysql_default_credentials',
                        'mysql_anonymous_access'
                    ],
                    'categories': ['database']
                },
                'postgresql': {
                    'nuclei_templates': [
                        'postgresql-detect',
                        'postgresql-version',
                        'postgresql-default-creds'
                    ],
                    'security_checks': [
                        'postgresql_version_disclosure',
                        'postgresql_default_credentials'
                    ],
                    'categories': ['database']
                },
                
                # Tecnologías de Contenido
                'jquery': {
                    'nuclei_templates': [
                        'jquery-version',
                        'jquery-vulnerabilities'
                    ],
                    'security_checks': [
                        'jquery_version_check',
                        'jquery_known_vulnerabilities'
                    ],
                    'categories': ['javascript-library', 'frontend']
                },
                'bootstrap': {
                    'nuclei_templates': [
                        'bootstrap-version'
                    ],
                    'security_checks': [
                        'bootstrap_version_check'
                    ],
                    'categories': ['css-framework', 'frontend']
                }
            },
            
            'security_headers': {
                'required_headers': [
                    'X-Frame-Options',
                    'X-Content-Type-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security',
                    'Content-Security-Policy'
                ],
                'technology_specific': {
                    'php': {
                        'headers_to_check': ['X-Powered-By'],
                        'should_be_hidden': True
                    },
                    'nginx': {
                        'headers_to_check': ['Server'],
                        'should_contain_version': False
                    },
                    'apache': {
                        'headers_to_check': ['Server'],
                        'should_contain_version': False
                    }
                }
            },
            
            'confidence_thresholds': {
                'high': 80,
                'medium': 60,
                'low': 40
            }
        }
    
    def _load_vulnerability_mappings(self) -> Dict[str, Any]:
        """Carga mapeos de vulnerabilidades conocidas por tecnología."""
        return {
            'wordpress': {
                'common_vulnerabilities': [
                    'wp_user_enumeration',
                    'wp_xmlrpc_pingback',
                    'wp_config_backup',
                    'wp_admin_brute_force'
                ],
                'version_specific': {
                    '< 5.0': ['wp_gutenberg_xss'],
                    '< 4.9': ['wp_media_library_xss'],
                    '< 4.7': ['wp_rest_api_exposure']
                }
            },
            'drupal': {
                'common_vulnerabilities': [
                    'drupal_user_enumeration',
                    'drupal_status_page',
                    'drupal_admin_brute_force'
                ],
                'version_specific': {
                    '< 8.6': ['drupal_rce_sa_core_2018_007'],
                    '< 7.58': ['drupal_rce_drupalgeddon2']
                }
            },
            'joomla': {
                'common_vulnerabilities': [
                    'joomla_config_backup',
                    'joomla_admin_brute_force'
                ],
                'version_specific': {
                    '< 3.9': ['joomla_rce_cve_2019_10945']
                }
            }
        }
    
    def get_analysis_templates(self, technologies: List[Dict[str, Any]]) -> Set[str]:
        """Obtiene plantillas de análisis basadas en tecnologías detectadas."""
        templates = set()
        tech_mappings = self.mappings.get('technology_templates', {})
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower().strip()
            confidence = tech.get('confidence', 0)
            source = tech.get('source', '')
            
            # Aplicar peso de confianza por fuente
            weighted_confidence = confidence * self.confidence_weights.get(source, 0.5)
            
            # Solo usar tecnologías con confianza suficiente
            threshold = self.mappings.get('confidence_thresholds', {}).get('medium', 60)
            if weighted_confidence >= threshold:
                tech_config = tech_mappings.get(tech_name, {})
                tech_templates = tech_config.get('nuclei_templates', [])
                templates.update(tech_templates)
                
                log.debug(f"Agregadas {len(tech_templates)} plantillas para {tech_name} (confianza: {weighted_confidence:.1f}%)")
        
        return templates
    
    def get_security_checks(self, technologies: List[Dict[str, Any]]) -> List[str]:
        """Obtiene checks de seguridad específicos por tecnología."""
        checks = []
        tech_mappings = self.mappings.get('technology_templates', {})
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower().strip()
            version = tech.get('version', '')
            confidence = tech.get('confidence', 0)
            
            # Filtrar por confianza
            threshold = self.mappings.get('confidence_thresholds', {}).get('low', 40)
            if confidence < threshold:
                continue
            
            # Checks generales por tecnología
            tech_config = tech_mappings.get(tech_name, {})
            tech_checks = tech_config.get('security_checks', [])
            checks.extend(tech_checks)
            
            # Checks específicos por versión
            if version and tech_name in self.vulnerability_db:
                version_checks = self._get_version_specific_checks(tech_name, version)
                checks.extend(version_checks)
        
        return list(set(checks))  # Deduplicar
    
    def _get_version_specific_checks(self, tech_name: str, version: str) -> List[str]:
        """Obtiene checks específicos basados en la versión de la tecnología."""
        checks = []
        tech_vulns = self.vulnerability_db.get(tech_name, {})
        version_specific = tech_vulns.get('version_specific', {})
        
        for version_range, vulns in version_specific.items():
            if self._version_matches_range(version, version_range):
                checks.extend(vulns)
        
        return checks
    
    def _version_matches_range(self, version: str, version_range: str) -> bool:
        """Verifica si una versión coincide con un rango dado."""
        try:
            # Simplificado: solo maneja rangos como "< X.Y"
            if version_range.startswith('< '):
                target_version = version_range[2:].strip()
                return self._compare_versions(version, target_version) < 0
            elif version_range.startswith('<= '):
                target_version = version_range[3:].strip()
                return self._compare_versions(version, target_version) <= 0
            elif version_range.startswith('> '):
                target_version = version_range[2:].strip()
                return self._compare_versions(version, target_version) > 0
            elif version_range.startswith('>= '):
                target_version = version_range[3:].strip()
                return self._compare_versions(version, target_version) >= 0
            else:
                return version == version_range
        except Exception:
            return False
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        """Compara dos versiones. Retorna -1, 0, o 1."""
        try:
            # Convertir versiones a listas de números
            v1_parts = [int(x) for x in version1.split('.') if x.isdigit()]
            v2_parts = [int(x) for x in version2.split('.') if x.isdigit()]
            
            # Igualar longitudes
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            # Comparar
            for v1, v2 in zip(v1_parts, v2_parts):
                if v1 < v2:
                    return -1
                elif v1 > v2:
                    return 1
            
            return 0
        except Exception:
            # Fallback a comparación de strings
            if version1 < version2:
                return -1
            elif version1 > version2:
                return 1
            return 0
    
    def get_technology_categories(self, technologies: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """Obtiene categorías de tecnologías detectadas."""
        categories = {}
        tech_mappings = self.mappings.get('technology_templates', {})
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower().strip()
            tech_config = tech_mappings.get(tech_name, {})
            tech_categories = tech_config.get('categories', [])
            
            for category in tech_categories:
                if category not in categories:
                    categories[category] = []
                categories[category].append(tech_name)
        
        return categories
    
    def get_security_headers_config(self, technologies: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Obtiene configuración de headers de seguridad basada en tecnologías."""
        headers_config = self.mappings.get('security_headers', {})
        required_headers = headers_config.get('required_headers', [])
        tech_specific = headers_config.get('technology_specific', {})
        
        config = {
            'required_headers': required_headers,
            'technology_specific_checks': []
        }
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower().strip()
            if tech_name in tech_specific:
                config['technology_specific_checks'].append({
                    'technology': tech_name,
                    'config': tech_specific[tech_name]
                })
        
        return config
    
    def generate_analysis_report(self, technologies: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Genera un reporte completo del análisis de tecnologías."""
        templates = self.get_analysis_templates(technologies)
        security_checks = self.get_security_checks(technologies)
        categories = self.get_technology_categories(technologies)
        headers_config = self.get_security_headers_config(technologies)
        
        # Estadísticas
        total_techs = len(technologies)
        high_confidence = len([t for t in technologies if t.get('confidence', 0) >= 80])
        medium_confidence = len([t for t in technologies if 60 <= t.get('confidence', 0) < 80])
        low_confidence = len([t for t in technologies if t.get('confidence', 0) < 60])
        
        return {
            'summary': {
                'total_technologies': total_techs,
                'confidence_distribution': {
                    'high': high_confidence,
                    'medium': medium_confidence,
                    'low': low_confidence
                },
                'categories_found': list(categories.keys()),
                'templates_to_run': len(templates),
                'security_checks': len(security_checks)
            },
            'technologies': technologies,
            'categories': categories,
            'analysis_config': {
                'nuclei_templates': list(templates),
                'security_checks': security_checks,
                'headers_config': headers_config
            },
            'recommendations': self._generate_recommendations(technologies, categories)
        }
    
    def _generate_recommendations(self, technologies: List[Dict[str, Any]], 
                                categories: Dict[str, List[str]]) -> List[str]:
        """Genera recomendaciones basadas en las tecnologías detectadas."""
        recommendations = []
        
        # Recomendaciones por categoría
        if 'cms' in categories:
            recommendations.append("Se detectó un CMS. Verificar actualizaciones y plugins/módulos instalados.")
        
        if 'php' in categories:
            recommendations.append("Se detectó PHP. Verificar que no se exponga información de versión.")
        
        if 'javascript-framework' in categories:
            recommendations.append("Se detectaron frameworks JavaScript. Verificar que no estén en modo desarrollo.")
        
        if 'database' in categories:
            recommendations.append("Se detectaron bases de datos. Verificar configuraciones de acceso y credenciales por defecto.")
        
        # Recomendaciones por tecnologías específicas
        tech_names = [t.get('name', '').lower() for t in technologies]
        
        if any('wordpress' in name for name in tech_names):
            recommendations.append("WordPress detectado: Verificar wp-config.php, plugins desactualizados y enumeración de usuarios.")
        
        if any('nginx' in name for name in tech_names):
            recommendations.append("Nginx detectado: Verificar páginas de estado expuestas y configuración de alias.")
        
        if any('apache' in name for name in tech_names):
            recommendations.append("Apache detectado: Verificar server-info y server-status expuestos.")
        
        return recommendations

# Alias para compatibilidad con importaciones existentes
TechMapper = DynamicTechMapping

if __name__ == "__main__":
    # Ejemplo de uso
    mapping = DynamicTechMapping()
    
    # Tecnologías de ejemplo
    test_technologies = [
        {'name': 'WordPress', 'version': '5.8', 'confidence': 95, 'source': 'wappalyzer'},
        {'name': 'Nginx', 'version': '1.18', 'confidence': 85, 'source': 'httpx'},
        {'name': 'PHP', 'version': '7.4', 'confidence': 80, 'source': 'custom_patterns'},
        {'name': 'jQuery', 'version': '3.5.1', 'confidence': 70, 'source': 'whatweb'}
    ]
    
    report = mapping.generate_analysis_report(test_technologies)
    print(json.dumps(report, indent=2, ensure_ascii=False))