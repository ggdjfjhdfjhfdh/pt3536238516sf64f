#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de migraci√≥n para integrar el sistema mejorado de detecci√≥n de tecnolog√≠as.
Este script automatiza la integraci√≥n segura de las mejoras en el sistema existente.
"""

import os
import sys
import json
import shutil
import logging
import argparse
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("migration.log")
    ]
)
log = logging.getLogger(__name__)

class EnhancedDetectionMigrator:
    """Migrador para el sistema mejorado de detecci√≥n de tecnolog√≠as."""
    
    def __init__(self, project_root: str, backup_enabled: bool = True):
        self.project_root = Path(project_root)
        self.backup_enabled = backup_enabled
        self.backup_dir = self.project_root / "backups" / f"migration_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Archivos cr√≠ticos a respaldar
        self.critical_files = [
            "pentest/core.py",
            "pentest/fingerprint.py",
            "requirements.txt",
            "pentest/config/"
        ]
        
        # Nuevos archivos a verificar
        self.new_files = [
            "pentest/enhanced_fingerprint.py",
            "pentest/tech_mapping.py",
            "pentest/metrics.py",
            "pentest/tool_validator.py",
            "pentest/enhanced_integration.py",
            "pentest/core_integration_patch.py",
            "pentest/tech_mappings.yaml",
            "pentest/config/enhanced_detection_config.yaml"
        ]
        
        # Estado de la migraci√≥n
        self.migration_status = {
            "backup_created": False,
            "dependencies_installed": False,
            "tools_validated": False,
            "core_patched": False,
            "tests_passed": False,
            "migration_completed": False
        }
    
    def run_migration(self, skip_backup: bool = False, skip_tests: bool = False) -> bool:
        """Ejecuta la migraci√≥n completa."""
        try:
            log.info("üöÄ Iniciando migraci√≥n al sistema mejorado de detecci√≥n...")
            log.info(f"üìÅ Directorio del proyecto: {self.project_root}")
            
            # 1. Verificar prerrequisitos
            if not self._check_prerequisites():
                log.error("‚ùå Prerrequisitos no cumplidos")
                return False
            
            # 2. Crear backup
            if not skip_backup and self.backup_enabled:
                if not self._create_backup():
                    log.error("‚ùå Error creando backup")
                    return False
            
            # 3. Instalar dependencias
            if not self._install_dependencies():
                log.error("‚ùå Error instalando dependencias")
                return False
            
            # 4. Validar herramientas externas
            if not self._validate_external_tools():
                log.warning("‚ö†Ô∏è Algunas herramientas externas no est√°n disponibles")
            
            # 5. Aplicar parche al core
            if not self._patch_core_system():
                log.error("‚ùå Error aplicando parche al sistema core")
                return False
            
            # 6. Ejecutar tests
            if not skip_tests:
                if not self._run_tests():
                    log.warning("‚ö†Ô∏è Algunos tests fallaron, pero la migraci√≥n puede continuar")
            
            # 7. Finalizar migraci√≥n
            if not self._finalize_migration():
                log.error("‚ùå Error finalizando migraci√≥n")
                return False
            
            log.info("‚úÖ Migraci√≥n completada exitosamente")
            self._print_migration_summary()
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error cr√≠tico durante la migraci√≥n: {e}")
            self._rollback_migration()
            return False
    
    def _check_prerequisites(self) -> bool:
        """Verifica que se cumplan los prerrequisitos."""
        log.info("üîç Verificando prerrequisitos...")
        
        # Verificar que estamos en el directorio correcto
        if not (self.project_root / "pentest").exists():
            log.error("‚ùå Directorio 'pentest' no encontrado")
            return False
        
        # Verificar que core.py existe
        core_file = self.project_root / "pentest" / "core.py"
        if not core_file.exists():
            log.error("‚ùå Archivo core.py no encontrado")
            return False
        
        # Verificar que los nuevos archivos existen
        missing_files = []
        for file_path in self.new_files:
            if not (self.project_root / file_path).exists():
                missing_files.append(file_path)
        
        if missing_files:
            log.error(f"‚ùå Archivos faltantes: {', '.join(missing_files)}")
            return False
        
        # Verificar Python version
        if sys.version_info < (3, 7):
            log.error("‚ùå Se requiere Python 3.7 o superior")
            return False
        
        log.info("‚úÖ Prerrequisitos verificados")
        return True
    
    def _create_backup(self) -> bool:
        """Crea backup de archivos cr√≠ticos."""
        try:
            log.info(f"üíæ Creando backup en: {self.backup_dir}")
            
            self.backup_dir.mkdir(parents=True, exist_ok=True)
            
            for file_path in self.critical_files:
                source = self.project_root / file_path
                if source.exists():
                    if source.is_file():
                        dest = self.backup_dir / file_path
                        dest.parent.mkdir(parents=True, exist_ok=True)
                        shutil.copy2(source, dest)
                    elif source.is_dir():
                        dest = self.backup_dir / file_path
                        shutil.copytree(source, dest, dirs_exist_ok=True)
                    
                    log.info(f"üìÑ Respaldado: {file_path}")
            
            # Crear archivo de informaci√≥n del backup
            backup_info = {
                "timestamp": datetime.now().isoformat(),
                "project_root": str(self.project_root),
                "files_backed_up": self.critical_files,
                "migration_version": "1.0.0"
            }
            
            with open(self.backup_dir / "backup_info.json", 'w') as f:
                json.dump(backup_info, f, indent=2)
            
            self.migration_status["backup_created"] = True
            log.info("‚úÖ Backup creado exitosamente")
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error creando backup: {e}")
            return False
    
    def _install_dependencies(self) -> bool:
        """Instala dependencias necesarias."""
        try:
            log.info("üì¶ Instalando dependencias...")
            
            # Verificar si pip est√° disponible
            try:
                subprocess.run([sys.executable, "-m", "pip", "--version"], 
                             check=True, capture_output=True)
            except subprocess.CalledProcessError:
                log.error("‚ùå pip no est√° disponible")
                return False
            
            # Instalar dependencias desde requirements.txt
            requirements_file = self.project_root / "requirements.txt"
            if requirements_file.exists():
                cmd = [sys.executable, "-m", "pip", "install", "-r", str(requirements_file)]
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode != 0:
                    log.error(f"‚ùå Error instalando dependencias: {result.stderr}")
                    return False
                
                log.info("‚úÖ Dependencias de Python instaladas")
            
            # Ejecutar script de instalaci√≥n de herramientas externas
            install_script = self.project_root / "pentest" / "install_tech_detection_tools.py"
            if install_script.exists():
                log.info("üîß Ejecutando instalaci√≥n de herramientas externas...")
                cmd = [sys.executable, str(install_script), "--auto-install"]
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                if result.returncode == 0:
                    log.info("‚úÖ Herramientas externas instaladas")
                else:
                    log.warning(f"‚ö†Ô∏è Algunas herramientas externas no se pudieron instalar: {result.stderr}")
            
            self.migration_status["dependencies_installed"] = True
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error instalando dependencias: {e}")
            return False
    
    def _validate_external_tools(self) -> bool:
        """Valida herramientas externas."""
        try:
            log.info("üîç Validando herramientas externas...")
            
            # Importar y ejecutar validador
            sys.path.insert(0, str(self.project_root / "pentest"))
            
            try:
                from tool_validator import ExternalToolValidator
                
                validator = ExternalToolValidator(timeout=15)
                tools_info = validator.validate_all_tools()
                
                available_tools = validator.get_available_tools()
                
                if available_tools:
                    log.info(f"‚úÖ Herramientas disponibles: {', '.join(available_tools)}")
                    self.migration_status["tools_validated"] = True
                    return True
                else:
                    log.warning("‚ö†Ô∏è No hay herramientas externas disponibles")
                    return False
                    
            except ImportError as e:
                log.error(f"‚ùå Error importando validador: {e}")
                return False
            
        except Exception as e:
            log.error(f"‚ùå Error validando herramientas: {e}")
            return False
    
    def _patch_core_system(self) -> bool:
        """Aplica parche al sistema core."""
        try:
            log.info("üîß Aplicando parche al sistema core...")
            
            core_file = self.project_root / "pentest" / "core.py"
            
            # Leer archivo core.py actual
            with open(core_file, 'r', encoding='utf-8') as f:
                core_content = f.read()
            
            # Verificar si ya est√° parcheado
            if "enhanced_integration" in core_content or "EnhancedCorePipeline" in core_content:
                log.info("‚ÑπÔ∏è Sistema core ya est√° parcheado")
                self.migration_status["core_patched"] = True
                return True
            
            # Crear parche
            patch_content = self._generate_core_patch()
            
            # Aplicar parche al final del archivo
            patched_content = core_content + "\n\n" + patch_content
            
            # Escribir archivo parcheado
            with open(core_file, 'w', encoding='utf-8') as f:
                f.write(patched_content)
            
            log.info("‚úÖ Parche aplicado al sistema core")
            self.migration_status["core_patched"] = True
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error aplicando parche: {e}")
            return False
    
    def _generate_core_patch(self) -> str:
        """Genera el c√≥digo de parche para core.py."""
        return '''
# =============================================================================
# ENHANCED TECHNOLOGY DETECTION INTEGRATION
# Integraci√≥n autom√°tica del sistema mejorado de detecci√≥n de tecnolog√≠as
# =============================================================================

try:
    from .core_integration_patch import integrate_enhanced_detection
    
    # Aplicar integraci√≥n mejorada al pipeline
    if 'pipeline_steps' in locals() or 'pipeline_steps' in globals():
        enhanced_pipeline, updated_steps = integrate_enhanced_detection(
            core_instance=locals().get('self') or globals().get('self'),
            pipeline_steps=locals().get('pipeline_steps') or globals().get('pipeline_steps')
        )
        
        if enhanced_pipeline and updated_steps:
            pipeline_steps = updated_steps
            log.info("‚úÖ Sistema mejorado de detecci√≥n integrado")
        else:
            log.warning("‚ö†Ô∏è Integraci√≥n mejorada no disponible, usando sistema b√°sico")
    
except ImportError as e:
    log.warning(f"‚ö†Ô∏è M√≥dulos de detecci√≥n mejorada no disponibles: {e}")
except Exception as e:
    log.error(f"‚ùå Error integrando sistema mejorado: {e}")

# =============================================================================
'''
    
    def _run_tests(self) -> bool:
        """Ejecuta tests del sistema."""
        try:
            log.info("üß™ Ejecutando tests...")
            
            test_file = self.project_root / "pentest" / "tests" / "test_enhanced_detection.py"
            if not test_file.exists():
                log.warning("‚ö†Ô∏è Archivo de tests no encontrado")
                return False
            
            # Ejecutar tests
            cmd = [sys.executable, str(test_file)]
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=str(self.project_root))
            
            if result.returncode == 0:
                log.info("‚úÖ Tests ejecutados exitosamente")
                self.migration_status["tests_passed"] = True
                return True
            else:
                log.warning(f"‚ö†Ô∏è Algunos tests fallaron: {result.stderr}")
                return False
            
        except Exception as e:
            log.error(f"‚ùå Error ejecutando tests: {e}")
            return False
    
    def _finalize_migration(self) -> bool:
        """Finaliza la migraci√≥n."""
        try:
            log.info("üèÅ Finalizando migraci√≥n...")
            
            # Crear archivo de estado de migraci√≥n
            migration_info = {
                "migration_completed": True,
                "timestamp": datetime.now().isoformat(),
                "version": "1.0.0",
                "status": self.migration_status,
                "backup_location": str(self.backup_dir) if self.backup_enabled else None
            }
            
            migration_file = self.project_root / "pentest" / "migration_status.json"
            with open(migration_file, 'w') as f:
                json.dump(migration_info, f, indent=2)
            
            # Crear archivo de configuraci√≥n por defecto si no existe
            config_dir = self.project_root / "pentest" / "config"
            config_dir.mkdir(exist_ok=True)
            
            default_config_file = config_dir / "enhanced_detection.yaml"
            if not default_config_file.exists():
                shutil.copy2(
                    self.project_root / "pentest" / "config" / "enhanced_detection_config.yaml",
                    default_config_file
                )
            
            self.migration_status["migration_completed"] = True
            log.info("‚úÖ Migraci√≥n finalizada")
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error finalizando migraci√≥n: {e}")
            return False
    
    def _rollback_migration(self) -> bool:
        """Revierte la migraci√≥n en caso de error."""
        try:
            log.warning("üîÑ Iniciando rollback de migraci√≥n...")
            
            if not self.backup_enabled or not self.backup_dir.exists():
                log.error("‚ùå No hay backup disponible para rollback")
                return False
            
            # Restaurar archivos desde backup
            for file_path in self.critical_files:
                backup_file = self.backup_dir / file_path
                target_file = self.project_root / file_path
                
                if backup_file.exists():
                    if backup_file.is_file():
                        shutil.copy2(backup_file, target_file)
                    elif backup_file.is_dir():
                        if target_file.exists():
                            shutil.rmtree(target_file)
                        shutil.copytree(backup_file, target_file)
                    
                    log.info(f"üîÑ Restaurado: {file_path}")
            
            log.info("‚úÖ Rollback completado")
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error durante rollback: {e}")
            return False
    
    def _print_migration_summary(self) -> None:
        """Imprime resumen de la migraci√≥n."""
        print("\n" + "="*60)
        print("üìä RESUMEN DE MIGRACI√ìN")
        print("="*60)
        
        for step, completed in self.migration_status.items():
            status_icon = "‚úÖ" if completed else "‚ùå"
            step_name = step.replace("_", " ").title()
            print(f"{status_icon} {step_name}")
        
        print("\nüí° PR√ìXIMOS PASOS:")
        print("1. Reiniciar el servicio de pentest-express-api")
        print("2. Verificar logs para confirmar funcionamiento")
        print("3. Ejecutar un escaneo de prueba")
        print("4. Revisar m√©tricas de rendimiento")
        
        if self.backup_enabled:
            print(f"\nüíæ Backup disponible en: {self.backup_dir}")
        
        print("\nüìö DOCUMENTACI√ìN:")
        print("- README_MEJORAS_TECNOLOGIAS.md")
        print("- pentest/config/enhanced_detection_config.yaml")
        print("- pentest/example_enhanced_usage.py")
        
        print("="*60)


def main():
    """Funci√≥n principal del script de migraci√≥n."""
    parser = argparse.ArgumentParser(
        description="Migrador para sistema mejorado de detecci√≥n de tecnolog√≠as"
    )
    
    parser.add_argument(
        "--project-root",
        default=".",
        help="Directorio ra√≠z del proyecto (default: directorio actual)"
    )
    
    parser.add_argument(
        "--skip-backup",
        action="store_true",
        help="Omitir creaci√≥n de backup"
    )
    
    parser.add_argument(
        "--skip-tests",
        action="store_true",
        help="Omitir ejecuci√≥n de tests"
    )
    
    parser.add_argument(
        "--no-backup",
        action="store_true",
        help="Deshabilitar backup completamente"
    )
    
    parser.add_argument(
        "--rollback",
        action="store_true",
        help="Ejecutar rollback de migraci√≥n anterior"
    )
    
    args = parser.parse_args()
    
    # Configurar migrador
    migrator = EnhancedDetectionMigrator(
        project_root=args.project_root,
        backup_enabled=not args.no_backup
    )
    
    try:
        if args.rollback:
            log.info("üîÑ Ejecutando rollback...")
            success = migrator._rollback_migration()
        else:
            log.info("üöÄ Ejecutando migraci√≥n...")
            success = migrator.run_migration(
                skip_backup=args.skip_backup,
                skip_tests=args.skip_tests
            )
        
        if success:
            print("\nüéâ ¬°Migraci√≥n completada exitosamente!")
            sys.exit(0)
        else:
            print("\n‚ùå Migraci√≥n fall√≥")
            sys.exit(1)
            
    except KeyboardInterrupt:
        log.warning("\n‚ö†Ô∏è Migraci√≥n interrumpida por el usuario")
        sys.exit(1)
    except Exception as e:
        log.error(f"\n‚ùå Error cr√≠tico: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()