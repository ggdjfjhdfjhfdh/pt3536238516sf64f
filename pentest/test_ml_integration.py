#!/usr/bin/env python3
"""
Script de prueba simplificado para verificar la integraci√≥n del sistema de IA/ML predictivo.

Este script:
1. Verifica que todas las dependencias ML est√©n instaladas
2. Prueba la inicializaci√≥n de los componentes ML
3. Simula an√°lisis ML b√°sico
4. Valida los resultados del an√°lisis predictivo
"""

import sys
import json
import tempfile
import os
from pathlib import Path
from typing import Dict, Any

# A√±adir el directorio actual al path
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

def check_ml_dependencies():
    """Verifica que todas las dependencias ML est√©n disponibles."""
    print("üîç Verificando dependencias ML...")
    
    required_packages = [
        'sklearn',
        'numpy', 
        'joblib',
        'scipy'
    ]
    
    missing_packages = []
    
    for package in required_packages:
        try:
            __import__(package)
            print(f"  ‚úÖ {package}")
        except ImportError:
            print(f"  ‚ùå {package} - NO ENCONTRADO")
            missing_packages.append(package)
    
    if missing_packages:
        print(f"\n‚ö†Ô∏è  Paquetes faltantes: {', '.join(missing_packages)}")
        print("Instala con: pip install scikit-learn numpy joblib scipy")
        return False
    
    print("‚úÖ Todas las dependencias ML est√°n disponibles")
    return True

def test_ml_components():
    """Prueba la inicializaci√≥n de los componentes ML."""
    print("\nüß™ Probando componentes ML...")
    
    try:
        # Importar componentes ML directamente
        from ml_predictive_analysis import MLPredictiveAnalyzer
        from ml_integration import MLIntegrationManager
        print("  ‚úÖ Importaci√≥n de m√≥dulos ML exitosa")
        
        # Inicializar analizador ML
        analyzer = MLPredictiveAnalyzer()
        print("  ‚úÖ MLPredictiveAnalyzer inicializado")
        
        # Inicializar gestor de integraci√≥n
        manager = MLIntegrationManager(analyzer)
        print("  ‚úÖ MLIntegrationManager inicializado")
        
        return analyzer, manager
        
    except Exception as e:
        print(f"  ‚ùå Error inicializando componentes ML: {e}")
        import traceback
        traceback.print_exc()
        return None, None

def create_mock_scan_data(tmp_dir: Path) -> Dict[str, Path]:
    """Crea datos de escaneo simulados para pruebas."""
    print("\nüìÅ Creando datos de escaneo simulados...")
    
    files = {}
    
    # Datos de fingerprinting simulados
    finger_data = [
        {
            "url": "https://example.com",
            "status_code": 200,
            "title": "Example Domain",
            "tech": ["Apache", "PHP"],
            "headers": {
                "server": "Apache/2.4.41",
                "x-powered-by": "PHP/7.4.3"
            }
        }
    ]
    
    finger_file = tmp_dir / "finger_results.json"
    with open(finger_file, 'w') as f:
        json.dump(finger_data, f, indent=2)
    files['finger'] = finger_file
    print(f"  ‚úÖ Creado: {finger_file}")
    
    # Datos de Nuclei simulados
    nuclei_data = {
        "findings": [
            {
                "template_id": "apache-version-detect",
                "severity": "info",
                "name": "Apache Version Detection",
                "matched_at": "https://example.com",
                "extracted_results": ["Apache/2.4.41"]
            },
            {
                "template_id": "ssl-tls-version",
                "severity": "medium",
                "name": "SSL/TLS Version Detection",
                "matched_at": "https://example.com:443"
            }
        ]
    }
    
    nuclei_file = tmp_dir / "nuclei_results.json"
    with open(nuclei_file, 'w') as f:
        json.dump(nuclei_data, f, indent=2)
    files['nuclei'] = nuclei_file
    print(f"  ‚úÖ Creado: {nuclei_file}")
    
    # Datos de CVE simulados
    cve_data = {
        "cves": [
            {
                "cve_id": "CVE-2021-44228",
                "severity": "critical",
                "description": "Apache Log4j2 JNDI features vulnerability",
                "cvss_score": 10.0,
                "affected_component": "Apache"
            }
        ]
    }
    
    cve_file = tmp_dir / "cve_results.json"
    with open(cve_file, 'w') as f:
        json.dump(cve_data, f, indent=2)
    files['cve'] = cve_file
    print(f"  ‚úÖ Creado: {cve_file}")
    
    # Datos de Nmap simulados
    nmap_data = [
        {
            "host": "example.com",
            "ports": [
                {"port": 80, "state": "open", "service": "http"},
                {"port": 443, "state": "open", "service": "https"},
                {"port": 22, "state": "open", "service": "ssh"}
            ]
        }
    ]
    
    nmap_file = tmp_dir / "nmap_results.json"
    with open(nmap_file, 'w') as f:
        json.dump(nmap_data, f, indent=2)
    files['nmap'] = nmap_file
    print(f"  ‚úÖ Creado: {nmap_file}")
    
    return files

def test_ml_analysis_direct(analyzer, manager, domain: str, tmp_dir: Path, files: Dict[str, Path]):
    """Prueba el an√°lisis ML usando MLIntegrationManager."""
    print("\nü§ñ Ejecutando an√°lisis ML directo...")
    
    try:
        # Recopilar datos de escaneo
        scan_data = {
            'vulnerabilities': [
                {'severity': 'HIGH', 'name': 'SQL Injection'},
                {'severity': 'MEDIUM', 'name': 'XSS'}
            ],
            'technologies': [{'name': 'Apache'}, {'name': 'PHP'}],
            'open_ports': [80, 443, 22],
            'status_code': 200,
            'network_info': {'avg_response_time': 1.2},
            'content_length': 5000
        }
        
        # Leer datos adicionales de archivos si existen
        if files.get('finger') and files['finger'].exists():
            with open(files['finger'], 'r') as f:
                finger_data = json.load(f)
                if finger_data:
                    scan_data['fingerprinting'] = finger_data
        
        if files.get('nuclei') and files['nuclei'].exists():
            with open(files['nuclei'], 'r') as f:
                nuclei_data = json.load(f)
                if nuclei_data.get('findings'):
                    scan_data['nuclei_findings'] = nuclei_data['findings']
        
        print(f"  üìä Datos recopilados: {list(scan_data.keys())}")
        
        # Ejecutar an√°lisis usando MLIntegrationManager
        print("  üîÆ Ejecutando an√°lisis predictivo...")
        enhanced_result = manager.enhance_scan_result(scan_data, domain)
        
        if enhanced_result:
            print("  ‚úÖ An√°lisis predictivo completado")
            
            # Convertir resultado a diccionario para guardar
            ml_results = {
                'confidence_score': enhanced_result.confidence_score,
                'risk_assessment': enhanced_result.risk_assessment,
                'recommendations': enhanced_result.recommendations,
                'processing_time': enhanced_result.processing_time,
                'threat_score': enhanced_result.risk_assessment.get('threat_score', 0),
                'anomalies': enhanced_result.risk_assessment.get('anomalies', []),
                'vulnerability_predictions': enhanced_result.risk_assessment.get('vulnerability_predictions', []),
                'attack_patterns': enhanced_result.risk_assessment.get('attack_patterns', [])
            }
            
            # Guardar resultados
            ml_file = tmp_dir / "ml_analysis_results.json"
            with open(ml_file, 'w') as f:
                json.dump(ml_results, f, indent=2)
            
            print(f"  ‚úÖ Resultados guardados en: {ml_file}")
            
            # Mostrar resumen de resultados
            print("\nüìä Resumen del an√°lisis ML:")
            print(f"  ‚Ä¢ Confianza: {enhanced_result.confidence_score:.2f}")
            print(f"  ‚Ä¢ Nivel de riesgo: {enhanced_result.risk_assessment.get('risk_level', 'N/A')}")
            print(f"  ‚Ä¢ Puntuaci√≥n de amenaza: {ml_results.get('threat_score', 'N/A')}")
            print(f"  ‚Ä¢ Anomal√≠as detectadas: {len(ml_results.get('anomalies', []))}")
            print(f"  ‚Ä¢ Predicciones de vulnerabilidades: {len(ml_results.get('vulnerability_predictions', []))}")
            print(f"  ‚Ä¢ Patrones de ataque: {len(ml_results.get('attack_patterns', []))}")
            print(f"  ‚Ä¢ Recomendaciones: {len(enhanced_result.recommendations)}")
            print(f"  ‚Ä¢ Tiempo de procesamiento: {enhanced_result.processing_time:.3f}s")
            
            # Mostrar algunas recomendaciones si existen
            if enhanced_result.recommendations:
                print("\nüí° Principales recomendaciones:")
                for i, rec in enumerate(enhanced_result.recommendations[:3], 1):
                    if isinstance(rec, dict):
                        print(f"  {i}. {rec.get('description', 'N/A')} (Prioridad: {rec.get('priority', 'N/A')})")
                    else:
                        print(f"  {i}. {rec}")
            
            return True
        else:
            print("  ‚ùå El an√°lisis predictivo no devolvi√≥ resultados")
            return False
            
    except Exception as e:
        print(f"  ‚ùå Error en an√°lisis ML: {e}")
        import traceback
        traceback.print_exc()
        return False

def test_ml_integration_manager(manager, domain: str, tmp_dir: Path, files: Dict[str, Path]):
    """Prueba el gestor de integraci√≥n ML."""
    print("\nüîó Probando MLIntegrationManager...")
    
    try:
        # Intentar importar SecurityEvent
        SecurityEvent = None
        try:
            from ml_integration import SecurityEvent
            print("  ‚úÖ SecurityEvent disponible")
        except ImportError:
            print("  ‚ö†Ô∏è SecurityEvent no disponible, probando funcionalidad b√°sica...")
        
        # Probar conversi√≥n de escaneo a evento
        scan_result = {
            'vulnerabilities': [{'severity': 'HIGH', 'name': 'Test Vuln'}],
            'technologies': [{'name': 'Apache'}],
            'open_ports': [80, 443],
            'status_code': 200,
            'network_info': {'avg_response_time': 1.0},
            'content_length': 1000
        }
        
        # Probar mejora de resultado
        enhanced = manager.enhance_scan_result(scan_result, domain)
        print(f"  ‚úÖ Mejora de resultado: confianza {enhanced.confidence_score}")
        print(f"  ‚úÖ Nivel de riesgo: {enhanced.risk_assessment.get('risk_level', 'N/A')}")
        print(f"  ‚úÖ Recomendaciones: {len(enhanced.recommendations)}")
        
        # Mostrar algunas m√©tricas adicionales
        if hasattr(enhanced, 'risk_assessment') and enhanced.risk_assessment:
            threat_score = enhanced.risk_assessment.get('threat_score', 'N/A')
            anomalies = enhanced.risk_assessment.get('anomalies', [])
            print(f"  ‚úÖ Puntuaci√≥n de amenaza: {threat_score}")
            print(f"  ‚úÖ Anomal√≠as detectadas: {len(anomalies)}")
        
        # Probar estad√≠sticas si est√°n disponibles
        if hasattr(manager, 'get_processing_stats'):
            try:
                stats = manager.get_processing_stats()
                print(f"  ‚úÖ Estad√≠sticas: {stats.get('total_scans', 0)} escaneos procesados")
            except Exception:
                print("  ‚ö†Ô∏è Estad√≠sticas no disponibles")
        
        return True
        
    except Exception as e:
        print(f"  ‚ùå Error probando MLIntegrationManager: {e}")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Funci√≥n principal de pruebas."""
    print("üöÄ Iniciando pruebas de integraci√≥n ML (versi√≥n simplificada)...\n")
    
    # Verificar dependencias
    if not check_ml_dependencies():
        print("\n‚ùå Pruebas fallidas: dependencias faltantes")
        return False
    
    # Probar componentes ML
    analyzer, manager = test_ml_components()
    if not analyzer or not manager:
        print("\n‚ùå Pruebas fallidas: error en componentes ML")
        return False
    
    # Crear directorio temporal para pruebas
    with tempfile.TemporaryDirectory() as tmp_dir_str:
        tmp_dir = Path(tmp_dir_str)
        domain = "example.com"
        
        # Crear datos simulados
        files = create_mock_scan_data(tmp_dir)
        
        # Probar an√°lisis ML directo
        ml_success = test_ml_analysis_direct(analyzer, manager, domain, tmp_dir, files)
        
        # Probar gestor de integraci√≥n
        integration_success = test_ml_integration_manager(manager, domain, tmp_dir, files)
        
        if ml_success and integration_success:
            print("\n‚úÖ Todas las pruebas pasaron exitosamente!")
            print("\nüéâ El sistema de IA/ML predictivo funciona correctamente")
            print("\nüìã Componentes verificados:")
            print("  ‚Ä¢ MLPredictiveAnalyzer - An√°lisis predictivo")
            print("  ‚Ä¢ MLIntegrationManager - Integraci√≥n con pipeline")
            print("  ‚Ä¢ Detecci√≥n de anomal√≠as")
            print("  ‚Ä¢ Predicci√≥n de vulnerabilidades")
            print("  ‚Ä¢ An√°lisis de patrones de ataque")
            print("  ‚Ä¢ Generaci√≥n de recomendaciones")
            return True
        else:
            print("\n‚ùå Algunas pruebas fallaron")
            return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)