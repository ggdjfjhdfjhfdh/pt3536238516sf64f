#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Módulo refactorizado para generación de informes con arquitectura mejorada.
Implementa separación de responsabilidades, patrón Factory e inyección de dependencias.
"""

import base64
import datetime
import json
import logging
import os
import yaml
from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Protocol

from jinja2 import Environment, FileSystemLoader, PackageLoader, select_autoescape

from pentest.exceptions import ReportError
from .correlation_engine import AdvancedCorrelationEngine, create_correlation_engine
from .intelligent_scoring import (
    IntelligentScoringEngine, create_scoring_engine, 
    create_asset_context, create_vulnerability_context,
    AssetType, BusinessCriticality
)
from .trend_analysis import TrendAnalysisEngine, create_trend_engine
from .visualizations import AdvancedVisualizations, ChartConfig

log = logging.getLogger("pentest")


# ============================================================================
# CONFIGURACIÓN CENTRALIZADA
# ============================================================================

@dataclass
class ReportConfig:
    """Configuración centralizada para el sistema de reportes."""
    
    # Rutas de plantillas
    template_paths: List[str] = None
    template_name: str = "report_enhanced.html"
    
    # Configuración de Jinja2
    autoescape_extensions: List[str] = None
    enable_cache: bool = True
    
    # Configuración de PDF
    pdf_timeout: int = 300
    pdf_quality: str = "high"
    
    # Configuración de datos
    validate_input: bool = True
    enable_correlation: bool = True
    
    # Configuración de scoring
    severity_weights: Dict[str, int] = None
    
    def __post_init__(self):
        if self.template_paths is None:
            self.template_paths = [
                "/app/templates",
                "/app/pentest/templates",
                "templates",
                "./templates",
                "./pentest/templates",
                str(Path(__file__).parent / "templates"),
                str(Path(__file__).parent.absolute() / "templates"),
                str(Path.cwd() / "pentest" / "templates"),
                str(Path.cwd() / "templates")
            ]
        
        if self.autoescape_extensions is None:
            self.autoescape_extensions = ['html', 'xml']
        
        if self.severity_weights is None:
            self.severity_weights = {
                "critical": 5,
                "high": 4,
                "medium": 3,
                "low": 2,
                "info": 1
            }


# ============================================================================
# INTERFACES Y PROTOCOLOS
# ============================================================================

class DataLoader(Protocol):
    """Protocolo para cargadores de datos."""
    
    def load_data(self, file_path: Path) -> Any:
        """Carga datos desde un archivo."""
        ...


class ReportProcessor(Protocol):
    """Protocolo para procesadores de reportes."""
    
    def process_data(self, raw_data: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos crudos y genera métricas."""
        ...


class TemplateEngine(Protocol):
    """Protocolo para motores de plantillas."""
    
    def render(self, template_name: str, context: Dict[str, Any]) -> str:
        """Renderiza una plantilla con el contexto dado."""
        ...


class PDFGenerator(Protocol):
    """Protocolo para generadores de PDF."""
    
    def generate_pdf(self, html_content: str, output_path: Path) -> Path:
        """Genera un PDF desde contenido HTML."""
        ...


# ============================================================================
# IMPLEMENTACIONES CONCRETAS
# ============================================================================

class JSONDataLoader:
    """Cargador de datos JSON con validación y manejo de errores robusto."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    def load_data(self, file_path: Optional[Path]) -> List[Dict[str, Any]]:
        """Carga datos JSON con manejo inteligente de estructuras."""
        if not file_path or not file_path.exists():
            self.log.debug(f"Archivo no encontrado: {file_path}")
            return []
        
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            
            # Normalizar estructura de datos basada en el nombre del archivo
            return self._normalize_data_structure(data, file_path.name)
            
        except json.JSONDecodeError as e:
            self.log.error(f"Error JSON en {file_path}: {e}")
            if self.config.validate_input:
                raise ReportError(f"Datos JSON inválidos en {file_path}: {e}")
            return []
        
        except Exception as e:
            self.log.error(f"Error inesperado cargando {file_path}: {e}")
            if self.config.validate_input:
                raise ReportError(f"Error cargando datos de {file_path}: {e}")
            return []
    
    def _normalize_data_structure(self, data: Any, filename: str) -> List[Dict[str, Any]]:
        """Normaliza diferentes estructuras de datos a una lista consistente."""
        filename_lower = filename.lower()
        
        # Manejar casos especiales por tipo de archivo
        if isinstance(data, dict):
            # Nuclei con nueva estructura
            if 'nuclei' in filename_lower and 'findings' in data:
                return data['findings']
            
            # Directorios
            elif 'dir_brute' in filename_lower or 'directories' in filename_lower:
                return data.get('directories', data.get('results', []))
            
            # Configuración de seguridad
            elif 'security_config' in filename_lower:
                return data.get('results', data.get('findings', []))
            
            # CVEs
            elif 'cve' in filename_lower:
                return data.get('cves', data.get('vulnerabilities', []))
            
            # CISA KEV
            elif 'cisa' in filename_lower or 'kev' in filename_lower:
                return data.get('vulnerabilities', data.get('kev_matches', []))
            
            # Leaks
            elif 'leak' in filename_lower or 'breach' in filename_lower:
                return data.get('breaches', data.get('leaks', []))
            
            # Typosquatting
            elif 'typo' in filename_lower:
                return data.get('typosquats', data.get('domains', []))
            
            # GreyNoise (convertir dict a lista)
            elif 'greynoise' in filename_lower:
                return [data] if data else []
            
            # Estructura genérica
            else:
                return data.get('results', data.get('findings', [data]))
        
        elif isinstance(data, list):
            return data
        
        else:
            return [data] if data else []


class AdvancedReportProcessor:
    """Procesador avanzado de reportes con análisis de correlación y scoring inteligente."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        
        # Inicializar motores de análisis avanzado
        self.correlation_engine = create_correlation_engine()
        self.scoring_engine = create_scoring_engine()
        self.trend_engine = create_trend_engine()
        self.visualizations = AdvancedVisualizations()
    
    def process_data(self, raw_data: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa datos con análisis avanzado y correlación."""
        processed_data = {
            'metrics': self._calculate_metrics(raw_data),
            'correlations': self._analyze_correlations(raw_data),
            'risk_assessment': self._calculate_risk_score(raw_data),
            'recommendations': self._generate_recommendations(raw_data),
            'executive_summary': self._generate_executive_summary(raw_data)
        }
        
        # Agregar datos originales procesados
        processed_data.update(raw_data)
        
        return processed_data
    
    def _calculate_metrics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Calcula métricas clave del escaneo."""
        nuclei_data = data.get('nuclei_data', [])
        
        # Conteos por severidad
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for vuln in nuclei_data:
            severity = vuln.get("info", {}).get("severity", "info").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        # Métricas adicionales
        metrics = {
            'nuclei_severity_counts': severity_counts,
            'total_vulnerabilities': len(nuclei_data),
            'critical_high_count': severity_counts['critical'] + severity_counts['high'],
            'subdomains_count': len(data.get('subdomains_data', [])),
            'open_ports_count': sum(1 for item in data.get('nmap_data', []) if item.get('state') == 'open'),
            'leaked_credentials_count': len(data.get('leaks_data', [])),
            'exposed_directories_count': len(data.get('dir_brute_data', [])),
            'cves_count': len(data.get('cves_data', [])),
            'typosquats_count': len(data.get('typosquats_data', []))
        }
        
        return metrics
    
    def _analyze_correlations(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza correlaciones entre diferentes tipos de vulnerabilidades."""
        if not self.config.enable_correlation:
            return {}
        
        correlations = {
            'technology_vulnerabilities': self._correlate_tech_vulns(data),
            'port_service_vulns': self._correlate_port_vulns(data),
            'credential_exposure': self._correlate_credential_exposure(data)
        }
        
        return correlations
    
    def _generate_advanced_analysis(self, processed_data: Dict[str, Any]) -> Dict[str, Any]:
        """Genera análisis avanzados de los datos procesados."""
        analysis = {}
        
        try:
            # Análisis de correlaciones avanzado
            self.log.info("Ejecutando análisis de correlaciones")
            analysis['correlations'] = self.correlation_engine.analyze_all_correlations(processed_data)
            
            # Análisis de tendencias
            self.log.info("Ejecutando análisis de tendencias")
            analysis['trends'] = self.trend_engine.analyze_all_trends(processed_data)
            
            # Análisis de puntuación inteligente
            self.log.info("Ejecutando análisis de puntuación inteligente")
            analysis['intelligent_scoring'] = self._perform_intelligent_scoring(processed_data, analysis.get('correlations', {}))
            
            # Análisis MITRE ATT&CK
            analysis['mitre_analysis'] = self._generate_mitre_analysis(processed_data)
            
            # Análisis de superficie de ataque
            analysis['attack_surface'] = self._analyze_attack_surface(processed_data)
            
            # Generar visualizaciones avanzadas
            self.log.info("Generando visualizaciones avanzadas")
            analysis['visualizations'] = self._generate_advanced_visualizations(processed_data, analysis)
            
            # Análisis de cumplimiento y compliance
            analysis['compliance_analysis'] = self._analyze_compliance(processed_data)
            
            # Análisis de rutas de ataque
            analysis['attack_paths'] = analysis['correlations'].get('attack_paths', [])
            
            self.log.info("Análisis avanzados completados")
            
        except Exception as e:
            self.log.error(f"Error en análisis avanzados: {e}")
            analysis['error'] = str(e)
        
        return analysis
    
    def _perform_intelligent_scoring(self, data: Dict[str, Any], correlations: Dict[str, Any]) -> Dict[str, Any]:
        """Realiza análisis de puntuación inteligente."""
        try:
            # Crear contextos para el análisis
            asset_context = create_asset_context(
                asset_type=AssetType.WEB_APPLICATION,
                business_criticality=BusinessCriticality.HIGH,
                exposure_level="internet_facing",
                compliance_requirements=["PCI-DSS", "GDPR"]
            )
            
            # Analizar vulnerabilidades con contexto
            scored_vulnerabilities = []
            for vuln in data.get('nuclei_data', []):
                vuln_context = create_vulnerability_context(
                    vulnerability_id=vuln.get('template-id', ''),
                    severity=vuln.get('info', {}).get('severity', 'info'),
                    cvss_score=vuln.get('info', {}).get('classification', {}).get('cvss-score', 0),
                    exploit_available=bool(vuln.get('info', {}).get('tags', [])),
                    affected_component=vuln.get('host', ''),
                    attack_vector="network"
                )
                
                intelligent_score = self.scoring_engine.calculate_intelligent_score(
                    vuln_context, asset_context
                )
                
                scored_vulnerabilities.append({
                    'vulnerability': vuln,
                    'intelligent_score': intelligent_score,
                    'risk_factors': intelligent_score.risk_factors
                })
            
            return {
                'scored_vulnerabilities': scored_vulnerabilities,
                'asset_context': asset_context.__dict__,
                'total_risk_score': sum(sv['intelligent_score'].total_score for sv in scored_vulnerabilities)
            }
            
        except Exception as e:
            self.log.error(f"Error en puntuación inteligente: {e}")
            return {'error': str(e)}
    
    def _generate_advanced_visualizations(self, data: Dict[str, Any], analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Genera visualizaciones avanzadas."""
        try:
            visualizations = {}
            
            # Gráfico de distribución de severidad
            severity_data = data.get('metrics', {}).get('nuclei_severity_counts', {})
            if severity_data:
                severity_chart = self.visualizations.create_severity_distribution_chart(
                    severity_data,
                    ChartConfig(title="Distribución de Severidad", width=800, height=400)
                )
                visualizations['severity_distribution'] = severity_chart
            
            # Timeline de vulnerabilidades
            nuclei_data = data.get('nuclei_data', [])
            if nuclei_data:
                timeline_chart = self.visualizations.create_vulnerability_timeline(
                    nuclei_data,
                    ChartConfig(title="Timeline de Vulnerabilidades", width=1000, height=300)
                )
                visualizations['vulnerability_timeline'] = timeline_chart
            
            # Mapa de correlaciones
            correlations = analysis.get('correlations', {})
            if correlations:
                correlation_chart = self.visualizations.create_correlation_heatmap(
                    correlations,
                    ChartConfig(title="Mapa de Correlaciones", width=800, height=600)
                )
                visualizations['correlation_heatmap'] = correlation_chart
            
            return visualizations
            
        except Exception as e:
            self.log.error(f"Error generando visualizaciones: {e}")
            return {'error': str(e)}
    
    def _generate_mitre_analysis(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Genera análisis MITRE ATT&CK."""
        # Implementación simplificada
        return {
            'techniques': [],
            'tactics': [],
            'coverage': 0
        }
    
    def _analyze_attack_surface(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza la superficie de ataque."""
        return {
            'exposed_services': len(data.get('nmap_data', [])),
            'web_applications': len(data.get('httpx_data', [])),
            'subdomains': len(data.get('subdomains_data', [])),
            'total_attack_vectors': 0
        }
    
    def _analyze_compliance(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza cumplimiento normativo."""
        return {
            'frameworks': ['PCI-DSS', 'GDPR', 'ISO27001'],
            'compliance_score': 75,
            'violations': []
        }
    
    def _correlate_tech_vulns(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Correlaciona tecnologías detectadas con vulnerabilidades."""
        # Implementación simplificada - se puede expandir
        correlations = []
        
        nuclei_data = data.get('nuclei_data', [])
        cves_data = data.get('cves_data', [])
        
        # Agrupar por tecnología/host
        tech_vulns = {}
        for vuln in nuclei_data:
            host = vuln.get('host', 'unknown')
            if host not in tech_vulns:
                tech_vulns[host] = []
            tech_vulns[host].append(vuln)
        
        for host, vulns in tech_vulns.items():
            if len(vulns) > 1:
                correlations.append({
                    'host': host,
                    'vulnerability_count': len(vulns),
                    'max_severity': max(vuln.get('info', {}).get('severity', 'info') for vuln in vulns),
                    'technologies': list(set(vuln.get('info', {}).get('tags', []) for vuln in vulns if vuln.get('info', {}).get('tags')))
                })
        
        return correlations
    
    def _correlate_port_vulns(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Correlaciona puertos abiertos con vulnerabilidades."""
        correlations = []
        
        nmap_data = data.get('nmap_data', [])
        nuclei_data = data.get('nuclei_data', [])
        
        # Mapear puertos a servicios y vulnerabilidades
        port_service_map = {}
        for port_info in nmap_data:
            if port_info.get('state') == 'open':
                port = port_info.get('port')
                service = port_info.get('service', {}).get('name', 'unknown')
                port_service_map[port] = service
        
        # Buscar vulnerabilidades relacionadas con servicios
        for port, service in port_service_map.items():
            related_vulns = []
            for vuln in nuclei_data:
                vuln_tags = vuln.get('info', {}).get('tags', [])
                if service.lower() in [tag.lower() for tag in vuln_tags]:
                    related_vulns.append(vuln)
            
            if related_vulns:
                correlations.append({
                    'port': port,
                    'service': service,
                    'vulnerability_count': len(related_vulns),
                    'vulnerabilities': related_vulns
                })
        
        return correlations
    
    def _correlate_credential_exposure(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza exposición de credenciales y su impacto."""
        leaks_data = data.get('leaks_data', [])
        dir_brute_data = data.get('dir_brute_data', [])
        
        # Buscar archivos sensibles expuestos
        sensitive_files = []
        for directory in dir_brute_data:
            url = directory.get('url', '').lower()
            if any(keyword in url for keyword in ['admin', 'login', 'config', 'backup', '.env']):
                sensitive_files.append(directory)
        
        return {
            'leaked_accounts': len(leaks_data),
            'exposed_sensitive_files': len(sensitive_files),
            'risk_multiplier': len(leaks_data) * len(sensitive_files) if leaks_data and sensitive_files else 0
        }
    
    def _calculate_risk_score(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Calcula puntuación de riesgo inteligente basada en contexto."""
        base_score = 0
        risk_factors = []
        
        # Scoring por vulnerabilidades Nuclei
        nuclei_data = data.get('nuclei_data', [])
        for vuln in nuclei_data:
            severity = vuln.get("info", {}).get("severity", "info").lower()
            weight = self.config.severity_weights.get(severity, 1)
            base_score += weight
        
        # Factores de riesgo adicionales
        if data.get('leaks_data'):
            base_score += 4
            risk_factors.append("Credenciales comprometidas")
        
        if data.get('cisa_kev_data'):
            base_score += 5
            risk_factors.append("Vulnerabilidades CISA KEV")
        
        # Multiplicadores por correlaciones
        correlations = self._analyze_correlations(data)
        if correlations.get('credential_exposure', {}).get('risk_multiplier', 0) > 0:
            base_score *= 1.5
            risk_factors.append("Exposición múltiple de credenciales")
        
        # Determinar nivel de riesgo
        if base_score >= 25:
            risk_level = "Crítico"
        elif base_score >= 20:
            risk_level = "Alto"
        elif base_score >= 15:
            risk_level = "Moderado"
        elif base_score >= 5:
            risk_level = "Bajo"
        else:
            risk_level = "Informacional"
        
        return {
            'score': base_score,
            'level': risk_level,
            'factors': risk_factors,
            'confidence': min(100, base_score * 2)  # Confianza basada en cantidad de datos
        }
    
    def _generate_recommendations(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Genera recomendaciones inteligentes basadas en el análisis."""
        recommendations = []
        
        # Recomendaciones basadas en correlaciones
        correlations = self._analyze_correlations(data)
        
        # Recomendaciones por tecnologías vulnerables
        tech_correlations = correlations.get('technology_vulnerabilities', [])
        for correlation in tech_correlations:
            if correlation['vulnerability_count'] > 2:
                recommendations.append({
                    'priority': 'high',
                    'category': 'technology_hardening',
                    'title': f"Reforzar seguridad en {correlation['host']}",
                    'description': f"Se detectaron {correlation['vulnerability_count']} vulnerabilidades en el mismo host.",
                    'solution': "Implementar un programa de gestión de parches y hardening específico para este sistema."
                })
        
        # Recomendaciones por exposición de credenciales
        cred_exposure = correlations.get('credential_exposure', {})
        if cred_exposure.get('risk_multiplier', 0) > 0:
            recommendations.append({
                'priority': 'critical',
                'category': 'credential_security',
                'title': "Riesgo crítico de exposición de credenciales",
                'description': "Combinación de credenciales filtradas y archivos sensibles expuestos.",
                'solution': "Implementar rotación inmediata de credenciales y revisión de controles de acceso."
            })
        
        return recommendations
    
    def _generate_executive_summary(self, data: Dict[str, Any]) -> str:
        """Genera resumen ejecutivo inteligente."""
        risk_assessment = self._calculate_risk_score(data)
        metrics = self._calculate_metrics(data)
        
        summary_parts = [
            f"Nivel de riesgo global: {risk_assessment['level']} (puntuación: {risk_assessment['score']:.1f})",
        ]
        
        if metrics['critical_high_count'] > 0:
            summary_parts.append(f"Se identificaron {metrics['critical_high_count']} vulnerabilidades críticas/altas")
        
        if risk_assessment['factors']:
            summary_parts.append(f"Factores de riesgo principales: {', '.join(risk_assessment['factors'])}")
        
        return ". ".join(summary_parts) + "."


class Jinja2TemplateEngine:
    """Motor de plantillas Jinja2 con patrón Factory mejorado."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self._env = None
        self._template_cache = {} if config.enable_cache else None
    
    @property
    def env(self) -> Environment:
        """Lazy loading del entorno Jinja2 con patrón Factory."""
        if self._env is None:
            self._env = self._create_environment()
        return self._env
    
    def _create_environment(self) -> Environment:
        """Factory method para crear el entorno Jinja2."""
        strategies = [
            ('PackageLoader', lambda: PackageLoader('pentest', 'templates')),
            ('FileSystemLoader', lambda: FileSystemLoader(self.config.template_paths))
        ]
        
        for strategy_name, loader_factory in strategies:
            try:
                loader = loader_factory()
                env = Environment(
                    loader=loader,
                    autoescape=select_autoescape(self.config.autoescape_extensions)
                )
                
                # Verificar que puede cargar la plantilla
                env.get_template(self.config.template_name)
                
                self.log.info(f"Entorno Jinja2 creado con {strategy_name}")
                return env
                
            except Exception as e:
                self.log.warning(f"{strategy_name} falló: {e}")
                continue
        
        raise ReportError("No se pudo inicializar el entorno Jinja2")
    
    def render(self, template_name: str, context: Dict[str, Any]) -> str:
        """Renderiza una plantilla con cache opcional."""
        cache_key = f"{template_name}_{hash(str(sorted(context.keys())))}"
        
        if self._template_cache and cache_key in self._template_cache:
            template = self._template_cache[cache_key]
        else:
            template = self.env.get_template(template_name)
            if self._template_cache:
                self._template_cache[cache_key] = template
        
        return template.render(**context)


class WeasyPrintPDFGenerator:
    """Generador de PDF usando WeasyPrint con configuración avanzada."""
    
    def __init__(self, config: ReportConfig):
        self.config = config
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    def generate_pdf(self, html_content: str, output_path: Path) -> Path:
        """Genera PDF con configuración optimizada."""
        try:
            from weasyprint import HTML, CSS
            from weasyprint.text.fonts import FontConfiguration
            
            # Configuración de fuentes
            font_config = FontConfiguration()
            
            # CSS adicional para mejorar la calidad del PDF
            additional_css = CSS(string='''
                @page {
                    margin: 2cm;
                    @bottom-center {
                        content: "Página " counter(page) " de " counter(pages);
                        font-size: 10pt;
                        color: #666;
                    }
                }
                
                .page-break {
                    page-break-before: always;
                }
                
                .no-break {
                    page-break-inside: avoid;
                }
            ''')
            
            # Generar PDF
            html_doc = HTML(string=html_content)
            html_doc.write_pdf(
                str(output_path),
                stylesheets=[additional_css],
                font_config=font_config
            )
            
            self.log.info(f"PDF generado exitosamente: {output_path}")
            return output_path
            
        except Exception as e:
            self.log.error(f"Error generando PDF: {e}")
            raise ReportError(f"Error al generar PDF: {e}")


# ============================================================================
# CLASE PRINCIPAL REFACTORIZADA
# ============================================================================

class ReportGenerator:
    """Generador de reportes refactorizado con inyección de dependencias."""
    
    def __init__(
        self,
        config: ReportConfig,
        data_loader: DataLoader,
        processor: ReportProcessor,
        template_engine: TemplateEngine,
        pdf_generator: PDFGenerator
    ):
        self.config = config
        self.data_loader = data_loader
        self.processor = processor
        self.template_engine = template_engine
        self.pdf_generator = pdf_generator
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    def generate_report(
        self,
        domain: str,
        recipient_email: str,
        tmp_dir: Path,
        **file_paths
    ) -> Path:
        """Genera un reporte completo con la nueva arquitectura."""
        self.log.info(f"Generando reporte para {domain}")
        
        try:
            # 1. Cargar datos
            raw_data = self._load_all_data(file_paths)
            raw_data['domain'] = domain
            raw_data['recipient_email'] = recipient_email
            
            # 2. Procesar datos
            processed_data = self.processor.process_data(raw_data)
            
            # 3. Preparar contexto para plantilla
            template_context = self._prepare_template_context(processed_data)
            
            # 4. Renderizar HTML
            html_content = self.template_engine.render(
                self.config.template_name,
                template_context
            )
            
            # 5. Guardar HTML
            html_path = tmp_dir / f"report_{domain}.html"
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(html_content)
            
            # 6. Generar PDF
            pdf_path = tmp_dir / f"report_{domain}.pdf"
            return self.pdf_generator.generate_pdf(html_content, pdf_path)
            
        except Exception as e:
            self.log.error(f"Error generando reporte: {e}")
            raise ReportError(f"Error en generación de reporte: {e}")
    
    def _load_all_data(self, file_paths: Dict[str, Path]) -> Dict[str, Any]:
        """Carga todos los archivos de datos."""
        data = {}
        
        # Mapeo de nombres de archivos a claves de datos
        file_mapping = {
            'httpx_file': 'httpx_data',
            'nuclei_file': 'nuclei_data',
            'leaks_file': 'leaks_data',
            'typosquats_file': 'typosquats_data',
            'cves_file': 'cves_data',
            'nmap_file': 'nmap_data',
            'security_config_file': 'security_config_data',
            'dir_brute_file': 'dir_brute_data',
            'cisa_kev_file': 'cisa_kev_data',
            'greynoise_file': 'greynoise_data',
            'premium_adaptive_file': 'premium_adaptive_data',
            'ml_file': 'ml_data',
            'waf_file': 'waf_data'
        }
        
        for file_key, data_key in file_mapping.items():
            file_path = file_paths.get(file_key)
            data[data_key] = self.data_loader.load_data(file_path)
        
        # Cargar subdominios (archivo de texto)
        subdomains_file = file_paths.get('tmp_dir', Path()) / "subdomains.txt"
        if subdomains_file.exists():
            with open(subdomains_file, "r") as f:
                data['subdomains_data'] = [line.strip() for line in f if line.strip()]
        else:
            data['subdomains_data'] = []
        
        return data
    
    def _prepare_template_context(self, processed_data: Dict[str, Any]) -> Dict[str, Any]:
        """Prepara el contexto para la plantilla."""
        context = {
            'date': datetime.date.today().strftime("%d/%m/%Y"),
            **processed_data
        }
        
        # Agregar métricas calculadas
        metrics = processed_data.get('metrics', {})
        context.update({
            f"{key}": value for key, value in metrics.items()
        })
        
        return context


# ============================================================================
# FACTORY FUNCTIONS
# ============================================================================

def create_default_report_generator(config: Optional[ReportConfig] = None) -> ReportGenerator:
    """Factory function para crear un generador de reportes con configuración por defecto."""
    if config is None:
        config = ReportConfig()
    
    # Crear componentes
    data_loader = JSONDataLoader(config)
    processor = AdvancedReportProcessor(config)
    template_engine = Jinja2TemplateEngine(config)
    pdf_generator = WeasyPrintPDFGenerator(config)
    
    return ReportGenerator(
        config=config,
        data_loader=data_loader,
        processor=processor,
        template_engine=template_engine,
        pdf_generator=pdf_generator
    )


# ============================================================================
# FUNCIONES DE COMPATIBILIDAD
# ============================================================================

def build_pdf(
    domain: str,
    recipient_email: str,
    tmp_dir: Path,
    **kwargs
) -> Path:
    """Función de compatibilidad con la API existente."""
    generator = create_default_report_generator()
    return generator.generate_report(
        domain=domain,
        recipient_email=recipient_email,
        tmp_dir=tmp_dir,
        **kwargs
    )


# Mantener funciones existentes para compatibilidad
def encode_pdf_for_email(pdf_path: Path) -> str:
    """Codifica un PDF en base64 para adjuntarlo a un email."""
    with open(pdf_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")