"""M√≥dulo para generaci√≥n de informes."""

import base64
import datetime
import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

from jinja2 import Environment, FileSystemLoader, select_autoescape

from pentest.exceptions import ReportError
from pentest.config import TEMPLATES_DIR

# Configuraci√≥n de logging
log = logging.getLogger(__name__)

# Inicializar entorno Jinja2 y precompilar plantilla
try:
    env = Environment(
        loader=FileSystemLoader(TEMPLATES_DIR),
        autoescape=select_autoescape(['html', 'xml'])
    )
    template_report = env.get_template("report.html")
except Exception as e:
    log.warning("Error al inicializar Jinja2: %s", str(e))
    template_report = None

def get_recommendations(
    nuclei_data: List[Dict[str, Any]],
    tls_data: Dict[str, Any],
    leaks_data: List[Dict[str, Any]],
    typosquats_data: List[Dict[str, Any]],
    cves_data: List[Dict[str, Any]],
    nmap_data: List[Dict[str, Any]],
    security_config_data: List[Dict[str, Any]]
) -> List[Dict[str, str]]:
    """Genera una lista de recomendaciones basadas en los hallazgos del escaneo."""
    recommendations = []

    # Recomendaciones para vulnerabilidades de Nuclei
    for vuln in nuclei_data:
        severity = vuln.get("info", {}).get("severity", "").lower()
        if severity in ["critical", "high"]:
            recommendations.append({
                "title": f"Vulnerabilidad {severity.capitalize()}: {vuln.get('info', {}).get('name', 'N/A')}",
                "description": f"Se detect√≥ una vulnerabilidad de {severity} en {vuln.get('host', 'N/A')}. Detalles: {vuln.get('info', {}).get('description', 'N/A')}",
                "solution": f"Referencia: {vuln.get('info', {}).get('reference', 'N/A')}. Aplicar parches, actualizar software o reconfigurar seg√∫n la vulnerabilidad espec√≠fica."
            })

    # Recomendaciones para problemas TLS
    for finding in tls_data.get("findings", []):
        recommendations.append({
            "title": f"Problema TLS: {finding.get('id', 'N/A')}",
            "description": f"Se detect√≥ un problema de configuraci√≥n TLS: {finding.get('description', 'N/A')}",
            "solution": f"Configurar el servidor para usar versiones de TLS seguras (TLS 1.2 o 1.3), deshabilitar cifrados d√©biles y asegurar que los certificados sean v√°lidos y est√©n actualizados."
        })

    # Recomendaciones para credenciales filtradas
    if leaks_data:
        recommendations.append({
            "title": "Credenciales filtradas detectadas",
            "description": "Se encontraron direcciones de correo electr√≥nico asociadas con brechas de seguridad conocidas. Esto representa un riesgo de compromiso de cuentas.",
            "solution": "Cambiar inmediatamente las contrase√±as de las cuentas afectadas, usar contrase√±as √∫nicas y fuertes para cada servicio, y habilitar la autenticaci√≥n de dos factores (2FA) siempre que sea posible."
        })

    # Recomendaciones para typosquatting
    if typosquats_data:
        recommendations.append({
            "title": "Riesgo de Typosquatting",
            "description": "Se identificaron dominios similares al dominio objetivo que podr√≠an ser utilizados para ataques de phishing o suplantaci√≥n de identidad.",
            "solution": "Considerar el registro de estos dominios para proteger la marca y evitar su uso malicioso. Educar a los usuarios sobre la verificaci√≥n de URLs antes de hacer clic."
        })

    # Recomendaciones para CVEs
    for cve in cves_data:
        recommendations.append({
            "title": f"CVE detectado: {cve.get('cve_id', 'N/A')}",
            "description": f"Se detect√≥ una vulnerabilidad conocida ({cve.get('cve_id', 'N/A')}) en {cve.get('affected_technology', 'N/A')}.",
            "solution": "Consultar la base de datos de CVEs para obtener informaci√≥n detallada sobre el parche o la mitigaci√≥n. Actualizar el software afectado a la √∫ltima versi√≥n estable."
        })

    # Recomendaciones para Nmap (ejemplo: puertos abiertos inesperados)
    if nmap_data:
        open_ports_count = sum(1 for nmap_item in nmap_data if nmap_item.get('state') == 'open')
        if open_ports_count > 0:
            recommendations.append({
                "title": "Puertos abiertos detectados",
                "description": f"Se detectaron {open_ports_count} puertos abiertos en los hosts escaneados. Algunos de estos puertos podr√≠an no ser necesarios o estar mal configurados.",
                "solution": "Revisar la necesidad de cada puerto abierto. Cerrar los puertos no utilizados o filtrar el acceso a ellos mediante firewalls. Asegurarse de que los servicios expuestos est√©n correctamente configurados y parcheados."
            })

    # Recomendaciones para configuraci√≥n de seguridad
    for config_finding in security_config_data:
        recommendations.append({
            "title": f"Hallazgo de configuraci√≥n de seguridad: {config_finding.get('type', 'N/A')}",
            "description": f"Se identific√≥ una posible mala configuraci√≥n de seguridad: {config_finding.get('description', 'N/A')}",
            "solution": "Revisar la configuraci√≥n del servidor web y de las aplicaciones para aplicar las mejores pr√°cticas de seguridad. Esto puede incluir la eliminaci√≥n de cabeceras informativas, la configuraci√≥n de pol√≠ticas de seguridad de contenido (CSP) y la protecci√≥n contra ataques comunes."
        })

    return recommendations

def build_pdf(
    domain: str,
    tmp_dir: Path,
    httpx_file: Path,
    nuclei_file: Path,
    tls_file: Path,
    leaks_file: Path,
    typosquats_file: Path,
    cves_file: Path,
    nmap_file: Path,
    security_config_file: Path # Add new argument for security config scan
) -> Path:
    """Genera un informe PDF con los resultados del escaneo.
    
    Args:
        domain: Dominio objetivo
        tmp_dir: Directorio temporal para almacenar resultados
        httpx_file: Archivo JSON con hosts activos
        nuclei_file: Archivo JSON con vulnerabilidades
        tls_file: Archivo JSON con resultados TLS
        leaks_file: Archivo JSON con credenciales filtradas
        typosquats_file: Archivo JSON con dominios typosquatting
        
    Returns:
        Path al archivo PDF generado
        
    Raises:
        ReportError: Si falla la generaci√≥n del informe
    """
    log.info("üìä Iniciando generaci√≥n de informe para %s", domain)
    
    output_pdf = tmp_dir / f"report_{domain}.pdf"
    output_html = tmp_dir / f"report_{domain}.html"
    
    # Verificar que existen los archivos de resultados
    for file_path, file_desc in [
        (httpx_file, "hosts activos"),
        (nuclei_file, "vulnerabilidades"),
        (tls_file, "resultados TLS"),
        (leaks_file, "credenciales filtradas"),
        (typosquats_file, "dominios typosquatting"),
        (cves_file, "hallazgos de CVEs"),
        (nmap_file, "hallazgos de Nmap"),
        (security_config_file, "hallazgos de configuraci√≥n de seguridad") # Add new file check
    ]:
        if not file_path.exists():
            raise ReportError(f"Archivo de {file_desc} no encontrado: {file_path}")
    
    # Cargar datos
    try:
        # Hosts activos
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)
        
        # Vulnerabilidades
        with open(nuclei_file, "r") as f:
            nuclei_data = json.load(f)
        
        # Resultados TLS
        with open(tls_file, "r") as f:
            tls_data = json.load(f)
        
        # Credenciales filtradas
        with open(leaks_file, "r") as f:
            leaks_data = json.load(f)
        
        # Dominios typosquatting
        with open(typosquats_file, "r") as f:
            typosquats_data = json.load(f)

        # Hallazgos de CVEs
        with open(cves_file, "r") as f:
            cves_data = json.load(f)

        # Hallazgos de Nmap
        with open(nmap_file, "r") as f:
            nmap_data = json.load(f)

        # Hallazgos de configuraci√≥n de seguridad
        with open(security_config_file, "r") as f:
            security_config_data = json.load(f)
    except Exception as e:
        raise ReportError(f"Error al cargar datos: {str(e)}") from e

    # Generar recomendaciones
    recommendations = get_recommendations(
        nuclei_data,
        tls_data,
        leaks_data,
        typosquats_data,
        cves_data,
        nmap_data,
        security_config_data
    )
    
    # Preparar datos para la plantilla
    try:
        # Contar vulnerabilidades por severidad
        vuln_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for vuln in nuclei_data:
            severity = vuln.get("info", {}).get("severity", "").lower()
            if severity in vuln_counts:
                vuln_counts[severity] += 1
        
        # Contar problemas TLS
        tls_issues_count = len(tls_data.get("findings", []))
        
        # Contar emails filtrados
        leaks_count = len(leaks_data)

        # Contar vulnerabilidades cr√≠ticas/altas de Nuclei
        nuclei_critical_high_count = sum(1 for v in nuclei_data if v.get("info", {}).get("severity", "").lower() in ["critical", "high"])

        # Contar problemas TLS
        tls_findings_count = len(tls_data.get("findings", []))

        # Contar dominios typosquatting
        typosquats_count = len(typosquats_data)

        # Contar CVEs
        cves_count = len(cves_data)

        # Contar puertos abiertos de Nmap
        nmap_open_ports_count = sum(1 for item in nmap_data if item.get('state') == 'open')

        # Contar hallazgos de configuraci√≥n de seguridad
        security_config_count = len(security_config_data)

        # Preparar contexto para la plantilla
        context = {
            "domain": domain,
            "report_date": datetime.datetime.now().strftime("%Y-%m-%d"),
            "subdomains_count": len(httpx_data),
            "httpx_count": len(httpx_data), # Assuming httpx_data contains active hosts
            "nuclei_critical_high_count": nuclei_critical_high_count,
            "tls_findings_count": tls_findings_count,
            "leaks_count": leaks_count,
            "typosquats_count": typosquats_count,
            "cves_count": cves_count,
            "nmap_open_ports_count": nmap_open_ports_count,
            "security_config_count": security_config_count,
            "nuclei_data": nuclei_data,
            "tls_data": tls_data,
            "leaks_data": leaks_data,
            "typosquats_data": typosquats_data,
            "cves_data": cves_data,
            "nmap_data": nmap_data,
            "security_config_data": security_config_data,
            "recommendations": recommendations,
            "current_year": datetime.datetime.now().year
        }

        # Renderizar plantilla HTML
        if template_report is None:
            raise ReportError("La plantilla del informe no se pudo cargar.")
        html_content = template_report.render(context)

        # Guardar HTML temporal
        with open(output_html, "w", encoding="utf-8") as f:
            f.write(html_content)

        log.info("HTML del informe generado en %s", output_html)

        # Convertir HTML a PDF usando wkhtmltopdf
        # Aseg√∫rate de que wkhtmltopdf est√© instalado y accesible en el PATH
        try:
            import pdfkit
            # Configurar la ruta de wkhtmltopdf
            # Aseg√∫rate de que wkhtmltopdf est√© instalado y accesible en el PATH del contenedor
            # O especifica la ruta completa si no est√° en el PATH
            config = pdfkit.configuration(wkhtmltopdf='/usr/local/bin/wkhtmltopdf') # Ruta com√∫n en sistemas Linux/Docker

            options = {
                'enable-local-file-access': None,
                'page-size': 'Letter',
                'margin-top': '0.75in',
                'margin-right': '0.75in',
                'margin-bottom': '0.75in',
                'margin-left': '0.75in',
                'encoding': "UTF-8"
            }
            pdfkit.from_file(str(output_html), str(output_pdf), configuration=config, options=options)
            log.info("PDF del informe generado en %s", output_pdf)
        except ImportError:
            log.error("pdfkit no est√° instalado. No se puede generar el PDF.")
            raise ReportError("pdfkit no est√° instalado. Inst√°lalo con 'pip install pdfkit'.")
        except Exception as e:
            log.error("Error al generar PDF: %s", str(e))
            raise ReportError(f"Error al generar PDF: {str(e)}") from e

        return output_pdf

    except Exception as e:
        raise ReportError(f"Error al preparar datos para la plantilla o renderizar: {str(e)}") from e
        leaked_emails_count = len(leaks_data)
        
        # Filtrar typosquats relevantes (con registros DNS)
        relevant_typosquats = []
        for typo in typosquats_data:
            if any(typo.get(f"dns-{rec}") for rec in ["a", "aaaa", "mx", "ns"]):
                relevant_typosquats.append(typo)
        
        # Preparar contexto para la plantilla
        context = {
            "domain": domain,
            "date": datetime.datetime.now().strftime("%Y-%m-%d"),
            "subdomains": httpx_data,
            "subdomains_count": len(httpx_data),
            "vulnerabilities": sorted(
                [v for v in nuclei_data if v.get("info", {}).get("severity", "").lower() in ["critical", "high"]],
                key=lambda x: {"critical": 0, "high": 1}.get(x.get("info", {}).get("severity", "").lower(), 2)
            ),
            "vuln_counts": vuln_counts,
            "tls_issues": tls_data.get("findings", []),
            "tls_issues_count": tls_issues_count,
            "leaked_emails": leaks_data,
            "leaked_emails_count": leaked_emails_count,
            "typosquats": relevant_typosquats[:15],  # Limitar a 15 para no sobrecargar el informe
            "typosquats_count": len(relevant_typosquats),
            "cves": cves_data, # Add CVE data to context
            "cves_count": len(cves_data),
            "nmap_findings": nmap_data, # Add Nmap data to context
            "nmap_findings_count": len(nmap_data), # Add Nmap count to context
            "security_config_findings": security_config_data, # Add security config data to context
            "security_config_findings_count": len(security_config_data), # Add security config count to context
            "total_findings": sum(vuln_counts.values()) + tls_issues_count + leaked_emails_count + len(cves_data) + len(nmap_data) + len(security_config_data), # Update total findings
            "summary": {
                "subdomains": len(httpx_data),
                "vulns": vuln_counts["critical"] + vuln_counts["high"],
                "tls": tls_issues_count,
                "leaks": leaked_emails_count,
            },
            "recommendations": get_recommendations(
                nuclei_data,
                tls_data,
                leaks_data,
                typosquats_data,
                cves_data,
                nmap_data,
                security_config_data
            )
        }
    except Exception as e:
        raise ReportError(f"Error al preparar datos para la plantilla: {str(e)}") from e
    
    # Renderizar plantilla
    try:
        # Verificar que la plantilla est√° disponible
        if template_report is None:
            # Intentar cargar la plantilla en tiempo de ejecuci√≥n
            for template_dir in [TEMPLATES_DIR, Path("templates"), Path("../templates")]:
                if (template_dir / "report.html").exists():
                    env = Environment(
                        loader=FileSystemLoader(template_dir),
                        autoescape=select_autoescape(['html', 'xml'])
                    )
                    template = env.get_template("report.html")
                    break
            else:
                raise ReportError("No se encontr√≥ la plantilla report.html")
        else:
            template = template_report
        
        # Renderizar HTML
        html_content = template.render(**context)
        
        # Guardar HTML para depuraci√≥n
        with open(output_html, "w", encoding="utf-8") as f:
            f.write(html_content)
            
        log.info("HTML generado correctamente")
    except Exception as e:
        raise ReportError(f"Error al renderizar plantilla: {str(e)}") from e
    
    # Generar PDF
    try:
        # Intentar importar WeasyPrint
        try:
            from weasyprint import HTML
            
            # Generar PDF
            HTML(string=html_content).write_pdf(output_pdf)
            log.info("‚úÖ PDF generado correctamente: %s", output_pdf)
        except ImportError:
            log.warning("WeasyPrint no est√° disponible, se guardar√° solo el HTML")
            output_pdf = output_html
    except Exception as e:
        log.error("Error al generar PDF: %s", str(e))
        log.info("Se utilizar√° el HTML como alternativa")
        output_pdf = output_html
    
    return output_pdf

def encode_pdf_for_email(pdf_path: Path) -> str:
    """Codifica un PDF en base64 para adjuntarlo a un email.
    
    Args:
        pdf_path: Ruta al archivo PDF
        
    Returns:
        String con el PDF codificado en base64
    """
    with open(pdf_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def send_notification(job_id: str, status_message: str, status_type: str, pdf_path: Path, recipient_email: str, subc: int, vulc: int):
    """Env√≠a una notificaci√≥n por email con el informe adjunto.
    
    Args:
        job_id: ID del trabajo de escaneo.
        status_message: Mensaje de estado del escaneo.
        status_type: Tipo de estado (e.g., "success", "failed").
        pdf_path: Ruta al archivo PDF.
        recipient_email: Email del destinatario.
        subc: N√∫mero de subdominios encontrados.
        vulc: N√∫mero de vulnerabilidades encontradas.
        
    Returns:
        True si se envi√≥ correctamente, False en caso contrario.
    """
    log.info("üìß Enviando notificaci√≥n a %s para el trabajo %s", recipient_email, job_id)
    
    # Obtener clave API de MailerSend
    api_key = os.getenv("MAILERSEND_API_KEY")
    if not api_key:
        log.error("No se ha configurado la clave API de MailerSend")
        return False
    
    try:
        # Importar requests si no est√° disponible en el √°mbito global
        import requests
        from pentest.http import get_session
        from pentest.config import MAIL_SENDER_EMAIL, MAIL_SENDER_NAME
        
        # Codificar PDF
        pdf_data = encode_pdf_for_email(pdf_path)

        # Asunto del correo
        subject = f"Informe de Pentest Express - Trabajo {job_id} ({status_type.capitalize()})"

        # Cuerpo del correo
        body = f"Hola,\n\nEl escaneo para el trabajo {job_id} ha finalizado con el siguiente estado: {status_message}.\n\nSe encontraron {subc} subdominios y {vulc} vulnerabilidades.\n\nAdjunto encontrar√°s el informe completo.\n\nSaludos,\nEl equipo de Pentest Express"

        # Datos para la API de MailerSend
        data = {
            "from": {"email": MAIL_SENDER_EMAIL, "name": MAIL_SENDER_NAME},
            "to": [{"email": recipient_email}],
            "subject": subject,
            "html": f"<p>{body.replace(chr(10), '<br>')}</p>",
            "attachments": [
                {
                    "filename": pdf_path.name,
                    "content": pdf_data
                }
            ]
        }

        # Enviar correo
        session = get_session()
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        response = session.post("https://api.mailersend.com/v1/email", headers=headers, json=data)
        response.raise_for_status() # Lanza una excepci√≥n para c√≥digos de estado HTTP err√≥neos

        log.info("‚úÖ Notificaci√≥n enviada correctamente para el trabajo %s", job_id)
        return True

    except requests.exceptions.RequestException as e:
        log.error("Error al enviar notificaci√≥n para el trabajo %s: %s", job_id, e)
        return False
    except Exception as e:
        log.error("Error inesperado al enviar notificaci√≥n para el trabajo %s: %s", job_id, e)
        return False