"""Módulo para generación de informes."""

import base64
import datetime
import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

from jinja2 import Environment, FileSystemLoader, select_autoescape

from pentest.exceptions import ReportError
from pentest.config import TEMPLATES_DIR

# Configuración de logging
log = logging.getLogger(__name__)

# Inicializar entorno Jinja2 y precompilar plantilla
try:
    env = Environment(
        loader=FileSystemLoader(TEMPLATES_DIR),
        autoescape=select_autoescape(['html', 'xml'])
    )
    template_report = env.get_template("report.html")
except Exception as e:
    log.warning("Error al inicializar Jinja2: %s", str(e))
    template_report = None

def get_recommendations(
    nuclei_data: List[Dict[str, Any]],
    tls_data: Dict[str, Any],
    leaks_data: List[Dict[str, Any]],
    typosquats_data: List[Dict[str, Any]],
    cves_data: List[Dict[str, Any]],
    nmap_data: List[Dict[str, Any]],
    security_config_data: List[Dict[str, Any]]
) -> List[Dict[str, str]]:
    """Genera una lista de recomendaciones basadas en los hallazgos del escaneo."""
    recommendations = []

    # Recomendaciones para vulnerabilidades de Nuclei
    for vuln in nuclei_data:
        severity = vuln.get("info", {}).get("severity", "").lower()
        if severity in ["critical", "high"]:
            recommendations.append({
                "title": f"Vulnerabilidad {severity.capitalize()}: {vuln.get('info', {}).get('name', 'N/A')}",
                "description": f"Se detectó una vulnerabilidad de {severity} en {vuln.get('host', 'N/A')}. Detalles: {vuln.get('info', {}).get('description', 'N/A')}",
                "solution": f"Referencia: {vuln.get('info', {}).get('reference', 'N/A')}. Aplicar parches, actualizar software o reconfigurar según la vulnerabilidad específica."
            })

    # Recomendaciones para problemas TLS
    for finding in tls_data.get("findings", []):
        recommendations.append({
            "title": f"Problema TLS: {finding.get('id', 'N/A')}",
            "description": f"Se detectó un problema de configuración TLS: {finding.get('description', 'N/A')}",
            "solution": f"Configurar el servidor para usar versiones de TLS seguras (TLS 1.2 o 1.3), deshabilitar cifrados débiles y asegurar que los certificados sean válidos y estén actualizados."
        })

    # Recomendaciones para credenciales filtradas
    if leaks_data:
        recommendations.append({
            "title": "Credenciales filtradas detectadas",
            "description": "Se encontraron direcciones de correo electrónico asociadas con brechas de seguridad conocidas. Esto representa un riesgo de compromiso de cuentas.",
            "solution": "Cambiar inmediatamente las contraseñas de las cuentas afectadas, usar contraseñas únicas y fuertes para cada servicio, y habilitar la autenticación de dos factores (2FA) siempre que sea posible."
        })

    # Recomendaciones para typosquatting
    if typosquats_data:
        recommendations.append({
            "title": "Riesgo de Typosquatting",
            "description": "Se identificaron dominios similares al dominio objetivo que podrían ser utilizados para ataques de phishing o suplantación de identidad.",
            "solution": "Considerar el registro de estos dominios para proteger la marca y evitar su uso malicioso. Educar a los usuarios sobre la verificación de URLs antes de hacer clic."
        })

    # Recomendaciones para CVEs
    for cve in cves_data:
        recommendations.append({
            "title": f"CVE detectado: {cve.get('cve_id', 'N/A')}",
            "description": f"Se detectó una vulnerabilidad conocida ({cve.get('cve_id', 'N/A')}) en {cve.get('affected_technology', 'N/A')}.",
            "solution": "Consultar la base de datos de CVEs para obtener información detallada sobre el parche o la mitigación. Actualizar el software afectado a la última versión estable."
        })

    # Recomendaciones para Nmap (ejemplo: puertos abiertos inesperados)
    if nmap_data:
        open_ports_count = sum(1 for nmap_item in nmap_data if nmap_item.get('state') == 'open')
        if open_ports_count > 0:
            recommendations.append({
                "title": "Puertos abiertos detectados",
                "description": f"Se detectaron {open_ports_count} puertos abiertos en los hosts escaneados. Algunos de estos puertos podrían no ser necesarios o estar mal configurados.",
                "solution": "Revisar la necesidad de cada puerto abierto. Cerrar los puertos no utilizados o filtrar el acceso a ellos mediante firewalls. Asegurarse de que los servicios expuestos estén correctamente configurados y parcheados."
            })

    # Recomendaciones para configuración de seguridad
    for config_finding in security_config_data:
        recommendations.append({
            "title": f"Hallazgo de configuración de seguridad: {config_finding.get('type', 'N/A')}",
            "description": f"Se identificó una posible mala configuración de seguridad: {config_finding.get('description', 'N/A')}",
            "solution": "Revisar la configuración del servidor web y de las aplicaciones para aplicar las mejores prácticas de seguridad. Esto puede incluir la eliminación de cabeceras informativas, la configuración de políticas de seguridad de contenido (CSP) y la protección contra ataques comunes."
        })

    return recommendations

def build_pdf(
    domain: str,
    tmp_dir: Path,
    httpx_file: Path,
    nuclei_file: Path,
    tls_file: Path,
    leaks_file: Path,
    typosquats_file: Path,
    cves_file: Path,
    nmap_file: Path,
    security_config_file: Path # Add new argument for security config scan
) -> Path:
    """Genera un informe PDF con los resultados del escaneo.
    
    Args:
        domain: Dominio objetivo
        tmp_dir: Directorio temporal para almacenar resultados
        httpx_file: Archivo JSON con hosts activos
        nuclei_file: Archivo JSON con vulnerabilidades
        tls_file: Archivo JSON con resultados TLS
        leaks_file: Archivo JSON con credenciales filtradas
        typosquats_file: Archivo JSON con dominios typosquatting
        
    Returns:
        Path al archivo PDF generado
        
    Raises:
        ReportError: Si falla la generación del informe
    """
    log.info("📊 Iniciando generación de informe para %s", domain)
    
    output_pdf = tmp_dir / f"report_{domain}.pdf"
    output_html = tmp_dir / f"report_{domain}.html"
    
    # Verificar que existen los archivos de resultados
    for file_path, file_desc in [
        (httpx_file, "hosts activos"),
        (nuclei_file, "vulnerabilidades"),
        (tls_file, "resultados TLS"),
        (leaks_file, "credenciales filtradas"),
        (typosquats_file, "dominios typosquatting"),
        (cves_file, "hallazgos de CVEs"),
        (nmap_file, "hallazgos de Nmap"),
        (security_config_file, "hallazgos de configuración de seguridad") # Add new file check
    ]:
        if not file_path.exists():
            raise ReportError(f"Archivo de {file_desc} no encontrado: {file_path}")
    
    # Cargar datos
    try:
        # Hosts activos
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)
        
        # Vulnerabilidades
        with open(nuclei_file, "r") as f:
            nuclei_data = json.load(f)
        
        # Resultados TLS
        with open(tls_file, "r") as f:
            tls_data = json.load(f)
        
        # Credenciales filtradas
        with open(leaks_file, "r") as f:
            leaks_data = json.load(f)
        
        # Dominios typosquatting
        with open(typosquats_file, "r") as f:
            typosquats_data = json.load(f)

        # Hallazgos de CVEs
        with open(cves_file, "r") as f:
            cves_data = json.load(f)

        # Hallazgos de Nmap
        with open(nmap_file, "r") as f:
            nmap_data = json.load(f)

        # Hallazgos de configuración de seguridad
        with open(security_config_file, "r") as f:
            security_config_data = json.load(f)
    except Exception as e:
        raise ReportError(f"Error al cargar datos: {str(e)}") from e

    # Generar recomendaciones
    recommendations = get_recommendations(
        nuclei_data,
        tls_data,
        leaks_data,
        typosquats_data,
        cves_data,
        nmap_data,
        security_config_data
    )
    
    # Preparar datos para la plantilla
    try:
        # Contar vulnerabilidades por severidad
        vuln_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        for vuln in nuclei_data:
            severity = vuln.get("info", {}).get("severity", "").lower()
            if severity in vuln_counts:
                vuln_counts[severity] += 1
        
        # Contar problemas TLS
        tls_issues_count = len(tls_data.get("findings", []))
        
        # Contar emails filtrados
        leaks_count = len(leaks_data)

        # Contar vulnerabilidades críticas/altas de Nuclei
        nuclei_critical_high_count = sum(1 for v in nuclei_data if v.get("info", {}).get("severity", "").lower() in ["critical", "high"])

        # Contar problemas TLS
        tls_findings_count = len(tls_data.get("findings", []))

        # Contar dominios typosquatting
        typosquats_count = len(typosquats_data)

        # Contar CVEs
        cves_count = len(cves_data)

        # Contar puertos abiertos de Nmap
        nmap_open_ports_count = sum(1 for item in nmap_data if item.get('state') == 'open')

        # Contar hallazgos de configuración de seguridad
        security_config_count = len(security_config_data)

        # Preparar contexto para la plantilla
        context = {
            "domain": domain,
            "report_date": datetime.datetime.now().strftime("%Y-%m-%d"),
            "subdomains_count": len(httpx_data),
            "httpx_count": len(httpx_data), # Assuming httpx_data contains active hosts
            "nuclei_critical_high_count": nuclei_critical_high_count,
            "tls_findings_count": tls_findings_count,
            "leaks_count": leaks_count,
            "typosquats_count": typosquats_count,
            "cves_count": cves_count,
            "nmap_open_ports_count": nmap_open_ports_count,
            "security_config_count": security_config_count,
            "nuclei_data": nuclei_data,
            "tls_data": tls_data,
            "leaks_data": leaks_data,
            "typosquats_data": typosquats_data,
            "cves_data": cves_data,
            "nmap_data": nmap_data,
            "security_config_data": security_config_data,
            "recommendations": recommendations,
            "current_year": datetime.datetime.now().year
        }

        # Renderizar plantilla HTML
        if template_report is None:
            raise ReportError("La plantilla del informe no se pudo cargar.")
        html_content = template_report.render(context)

        # Guardar HTML temporal
        with open(output_html, "w", encoding="utf-8") as f:
            f.write(html_content)

        log.info("HTML del informe generado en %s", output_html)

        # Convertir HTML a PDF usando wkhtmltopdf
        # Asegúrate de que wkhtmltopdf esté instalado y accesible en el PATH
        try:
            import pdfkit
            # Configurar la ruta de wkhtmltopdf
            # Asegúrate de que wkhtmltopdf esté instalado y accesible en el PATH del contenedor
            # O especifica la ruta completa si no está en el PATH
            config = pdfkit.configuration(wkhtmltopdf='/usr/local/bin/wkhtmltopdf') # Ruta común en sistemas Linux/Docker

            options = {
                'enable-local-file-access': None,
                'page-size': 'Letter',
                'margin-top': '0.75in',
                'margin-right': '0.75in',
                'margin-bottom': '0.75in',
                'margin-left': '0.75in',
                'encoding': "UTF-8"
            }
            pdfkit.from_file(str(output_html), str(output_pdf), configuration=config, options=options)
            log.info("PDF del informe generado en %s", output_pdf)
        except ImportError:
            log.error("pdfkit no está instalado. No se puede generar el PDF.")
            raise ReportError("pdfkit no está instalado. Instálalo con 'pip install pdfkit'.")
        except Exception as e:
            log.error("Error al generar PDF: %s", str(e))
            raise ReportError(f"Error al generar PDF: {str(e)}") from e

        return output_pdf

    except Exception as e:
        raise ReportError(f"Error al preparar datos para la plantilla o renderizar: {str(e)}") from e
        leaked_emails_count = len(leaks_data)
        
        # Filtrar typosquats relevantes (con registros DNS)
        relevant_typosquats = []
        for typo in typosquats_data:
            if any(typo.get(f"dns-{rec}") for rec in ["a", "aaaa", "mx", "ns"]):
                relevant_typosquats.append(typo)
        
        # Preparar contexto para la plantilla
        context = {
            "domain": domain,
            "date": datetime.datetime.now().strftime("%Y-%m-%d"),
            "subdomains": httpx_data,
            "subdomains_count": len(httpx_data),
            "vulnerabilities": sorted(
                [v for v in nuclei_data if v.get("info", {}).get("severity", "").lower() in ["critical", "high"]],
                key=lambda x: {"critical": 0, "high": 1}.get(x.get("info", {}).get("severity", "").lower(), 2)
            ),
            "vuln_counts": vuln_counts,
            "tls_issues": tls_data.get("findings", []),
            "tls_issues_count": tls_issues_count,
            "leaked_emails": leaks_data,
            "leaked_emails_count": leaked_emails_count,
            "typosquats": relevant_typosquats[:15],  # Limitar a 15 para no sobrecargar el informe
            "typosquats_count": len(relevant_typosquats),
            "cves": cves_data, # Add CVE data to context
            "cves_count": len(cves_data),
            "nmap_findings": nmap_data, # Add Nmap data to context
            "nmap_findings_count": len(nmap_data), # Add Nmap count to context
            "security_config_findings": security_config_data, # Add security config data to context
            "security_config_findings_count": len(security_config_data), # Add security config count to context
            "total_findings": sum(vuln_counts.values()) + tls_issues_count + leaked_emails_count + len(cves_data) + len(nmap_data) + len(security_config_data), # Update total findings
            "summary": {
                "subdomains": len(httpx_data),
                "vulns": vuln_counts["critical"] + vuln_counts["high"],
                "tls": tls_issues_count,
                "leaks": leaked_emails_count,
            },
            "recommendations": get_recommendations(
                nuclei_data,
                tls_data,
                leaks_data,
                typosquats_data,
                cves_data,
                nmap_data,
                security_config_data
            )
        }
    except Exception as e:
        raise ReportError(f"Error al preparar datos para la plantilla: {str(e)}") from e
    
    # Renderizar plantilla
    try:
        # Verificar que la plantilla está disponible
        if template_report is None:
            # Intentar cargar la plantilla en tiempo de ejecución
            for template_dir in [TEMPLATES_DIR, Path("templates"), Path("../templates")]:
                if (template_dir / "report.html").exists():
                    env = Environment(
                        loader=FileSystemLoader(template_dir),
                        autoescape=select_autoescape(['html', 'xml'])
                    )
                    template = env.get_template("report.html")
                    break
            else:
                raise ReportError("No se encontró la plantilla report.html")
        else:
            template = template_report
        
        # Renderizar HTML
        html_content = template.render(**context)
        
        # Guardar HTML para depuración
        with open(output_html, "w", encoding="utf-8") as f:
            f.write(html_content)
            
        log.info("HTML generado correctamente")
    except Exception as e:
        raise ReportError(f"Error al renderizar plantilla: {str(e)}") from e
    
    # Generar PDF
    try:
        # Intentar importar WeasyPrint
        try:
            from weasyprint import HTML
            
            # Generar PDF
            HTML(string=html_content).write_pdf(output_pdf)
            log.info("✅ PDF generado correctamente: %s", output_pdf)
        except ImportError:
            log.warning("WeasyPrint no está disponible, se guardará solo el HTML")
            output_pdf = output_html
    except Exception as e:
        log.error("Error al generar PDF: %s", str(e))
        log.info("Se utilizará el HTML como alternativa")
        output_pdf = output_html
    
    return output_pdf

def encode_pdf_for_email(pdf_path: Path) -> str:
    """Codifica un PDF en base64 para adjuntarlo a un email.
    
    Args:
        pdf_path: Ruta al archivo PDF
        
    Returns:
        String con el PDF codificado en base64
    """
    with open(pdf_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def send_notification(job_id: str, status_message: str, status_type: str, pdf_path: Path, recipient_email: str, subc: int, vulc: int):
    """Envía una notificación por email con el informe adjunto.
    
    Args:
        job_id: ID del trabajo de escaneo.
        status_message: Mensaje de estado del escaneo.
        status_type: Tipo de estado (e.g., "success", "failed").
        pdf_path: Ruta al archivo PDF.
        recipient_email: Email del destinatario.
        subc: Número de subdominios encontrados.
        vulc: Número de vulnerabilidades encontradas.
        
    Returns:
        True si se envió correctamente, False en caso contrario.
    """
    log.info("📧 Enviando notificación a %s para el trabajo %s", recipient_email, job_id)
    
    # Obtener clave API de MailerSend
    api_key = os.getenv("MAILERSEND_API_KEY")
    if not api_key:
        log.error("No se ha configurado la clave API de MailerSend")
        return False
    
    try:
        # Importar requests si no está disponible en el ámbito global
        import requests
        from pentest.http import get_session
        from pentest.config import MAIL_SENDER_EMAIL, MAIL_SENDER_NAME
        
        # Codificar PDF
        pdf_data = encode_pdf_for_email(pdf_path)

        # Asunto del correo
        subject = f"Informe de Pentest Express - Trabajo {job_id} ({status_type.capitalize()})"

        # Cuerpo del correo
        body = f"Hola,\n\nEl escaneo para el trabajo {job_id} ha finalizado con el siguiente estado: {status_message}.\n\nSe encontraron {subc} subdominios y {vulc} vulnerabilidades.\n\nAdjunto encontrarás el informe completo.\n\nSaludos,\nEl equipo de Pentest Express"

        # Datos para la API de MailerSend
        data = {
            "from": {"email": MAIL_SENDER_EMAIL, "name": MAIL_SENDER_NAME},
            "to": [{"email": recipient_email}],
            "subject": subject,
            "html": f"<p>{body.replace(chr(10), '<br>')}</p>",
            "attachments": [
                {
                    "filename": pdf_path.name,
                    "content": pdf_data
                }
            ]
        }

        # Enviar correo
        session = get_session()
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        response = session.post("https://api.mailersend.com/v1/email", headers=headers, json=data)
        response.raise_for_status() # Lanza una excepción para códigos de estado HTTP erróneos

        log.info("✅ Notificación enviada correctamente para el trabajo %s", job_id)
        return True

    except requests.exceptions.RequestException as e:
        log.error("Error al enviar notificación para el trabajo %s: %s", job_id, e)
        return False
    except Exception as e:
        log.error("Error inesperado al enviar notificación para el trabajo %s: %s", job_id, e)
        return False