"""Módulo para generación de informes."""

import base64
from pathlib import Path
import datetime
import logging
import os
import json
from typing import Optional, List, Dict, Any

from jinja2 import Environment, FileSystemLoader, select_autoescape

from pentest.exceptions import ReportError
from pentest.config import TEMPLATES_DIR

log = logging.getLogger("pentest")

# Inicializar entorno Jinja2 y precompilar plantilla
try:
    env = Environment(
        loader=FileSystemLoader(TEMPLATES_DIR),
        autoescape=select_autoescape(['html', 'xml'])
    )
    template_report = env.get_template("report.html")
except Exception as e:
    log.warning("Error al inicializar Jinja2: %s", str(e))
    template_report = None



def get_recommendations(
    nuclei_data: List[Dict[str, Any]],
    tls_data: Dict[str, Any],
    leaks_data: List[Dict[str, Any]],
    typosquats_data: List[Dict[str, Any]],
    cves_data: List[Dict[str, Any]],
    nmap_data: List[Dict[str, Any]],
    security_config_data: List[Dict[str, Any]],
    dir_brute_data: List[Dict[str, Any]],
    domain: str
) -> Dict[str, Any]:
    """Genera un resumen ejecutivo y una lista de recomendaciones basadas en los hallazgos del escaneo."""
    recommendations = []
    executive_summary_text = []

    # Calcular riesgo global basado en severidad de vulnerabilidades
    risk_score = 0
    severity_weights = {
        "critical": 5,
        "high": 4,
        "medium": 3,
        "low": 2,
        "info": 1
    }

    nuclei_severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}

    for vuln in nuclei_data:
        severity = vuln.get("info", {}).get("severity", "info").lower()
        risk_score += severity_weights.get(severity, 1)
        nuclei_severity_counts[severity] += 1

    for finding in tls_data.get("findings", []):
        risk_score += 3  # Consideramos los problemas TLS como de severidad media

    if leaks_data:
        risk_score += 4  # Consideramos las credenciales filtradas como de severidad alta

    if typosquats_data:
        risk_score += 2  # Consideramos el typosquatting como de severidad baja

    for cve in cves_data:
        risk_score += 3  # Consideramos los CVEs como de severidad media

    for config_finding in security_config_data:
        risk_score += 2  # Consideramos los hallazgos de configuración como de severidad baja

    # Determinar nivel de riesgo global
    if risk_score >= 20:
        risk_level = "Crítico"
        executive_summary_text.append(f"El nivel de riesgo global para {domain} es CRÍTICO, indicando la presencia de vulnerabilidades severas que requieren atención inmediata.")
    elif risk_score >= 15:
        risk_level = "Alto"
        executive_summary_text.append(f"El nivel de riesgo global para {domain} es ALTO, con hallazgos significativos que podrían comprometer la seguridad si no se abordan con prontitud.")
    elif risk_score >= 10:
        risk_level = "Moderado"
        executive_summary_text.append(f"El nivel de riesgo global para {domain} es MODERADO, lo que sugiere la existencia de vulnerabilidades que, aunque no críticas, deben ser corregidas para fortalecer la postura de seguridad.")
    elif risk_score >= 5:
        risk_level = "Bajo"
        executive_summary_text.append(f"El nivel de riesgo global para {domain} es BAJO, con hallazgos menores que no representan un riesgo inminente pero que se recomienda revisar.")
    else:
        risk_level = "Informacional"
        executive_summary_text.append(f"El nivel de riesgo global para {domain} es INFORMACIONAL, lo que indica que no se encontraron vulnerabilidades significativas, pero se ofrecen recomendaciones para optimizar la seguridad.")

    # Resumen de hallazgos clave para el resumen ejecutivo
    if nuclei_severity_counts["critical"] > 0:
        executive_summary_text.append(f"Se identificaron {nuclei_severity_counts['critical']} vulnerabilidades CRÍTICAS con Nuclei.")
    if nuclei_severity_counts["high"] > 0:
        executive_summary_text.append(f"Se identificaron {nuclei_severity_counts['high']} vulnerabilidades ALTAS con Nuclei.")
    tls_grade = "N/A"
    for finding_group in tls_data.get("findings", []):
        for finding in finding_group.get("findings", []):
            if finding.get("name") == "Calificación TLS" and finding.get("grade"):
                tls_grade = finding["grade"]
                break
        if tls_grade != "N/A":
            break

    if tls_grade != "N/A":
        executive_summary_text.append(f"El servidor obtuvo una calificación TLS de {tls_grade} según SSLyze.")
    elif tls_data.get("findings"):
        executive_summary_text.append(f"Se detectaron problemas de configuración TLS que podrían afectar la confidencialidad y la integridad de las comunicaciones.")
    if leaks_data:
        executive_summary_text.append(f"Se encontraron credenciales de correo electrónico asociadas con brechas de seguridad conocidas, lo que representa un riesgo de compromiso de cuentas.")
    if typosquats_data:
        executive_summary_text.append(f"Se identificaron dominios de typosquatting que podrían ser utilizados en ataques de phishing.")
    if cves_data:
        executive_summary_text.append(f"Se detectaron CVEs en tecnologías utilizadas, lo que indica la presencia de vulnerabilidades conocidas.")
    if any(nmap_item.get('state') == 'open' for nmap_item in nmap_data):
        executive_summary_text.append(f"Se encontraron puertos abiertos que deben ser revisados para asegurar que solo los servicios necesarios estén expuestos.")
    if security_config_data:
        executive_summary_text.append(f"Se identificaron hallazgos en la configuración de seguridad que requieren ajustes para cumplir con las mejores prácticas.")
    if dir_brute_data:
        executive_summary_text.append(f"Se encontraron {len(dir_brute_data)} directorios o archivos expuestos mediante fuerza bruta ligera.")

    # Recomendaciones para vulnerabilidades de Nuclei
    for vuln in nuclei_data:
        severity = vuln.get("info", {}).get("severity", "").lower()
        if severity in ["critical", "high", "medium"]:
            recommendations.append({
                "title": f"Vulnerabilidad {severity.capitalize()}: {vuln.get('info', {}).get('name', 'N/A')}",
                "description": f"Se detectó una vulnerabilidad de {severity} en {vuln.get('host', 'N/A')}. Detalles: {vuln.get('info', {}).get('description', 'N/A')}",
                "solution": f"Referencia: {vuln.get('info', {}).get('reference', 'N/A')}. Aplicar parches, actualizar software o reconfigurar según la vulnerabilidad específica. Priorizar la mitigación de vulnerabilidades {severity} para reducir el riesgo."
            })

    # Recomendaciones para problemas TLS
    if tls_data.get("findings"):
        recommendations.append({
            "title": "Mejorar la Configuración TLS",
            "description": "Se detectaron problemas de configuración TLS, como el uso de versiones antiguas (TLS 1.0/1.1) o cifrados débiles.",
            "solution": "Configurar el servidor para usar únicamente TLS 1.2 o 1.3. Deshabilitar todos los cifrados débiles y obsoletos (e.g., 3DES, RC4). Asegurar que los certificados SSL/TLS sean válidos, no estén caducados y utilicen algoritmos de firma fuertes (e.g., SHA256 o superior)."
        })

    # Recomendaciones para credenciales filtradas
    if leaks_data:
        recommendations.append({
            "title": "Gestión de Credenciales Comprometidas",
            "description": "Se encontraron direcciones de correo electrónico asociadas con brechas de seguridad conocidas en Have I Been Pwned.",
            "solution": "Cambiar inmediatamente las contraseñas de todas las cuentas afectadas, especialmente si se reutilizan. Implementar una política de contraseñas robusta que exija complejidad y rotación periódica. Habilitar la autenticación de dos factores (2FA) en todos los servicios que lo permitan para añadir una capa extra de seguridad."
        })

    # Recomendaciones para typosquatting
    if typosquats_data:
        recommendations.append({
            "title": "Mitigación de Riesgos de Typosquatting",
            "description": "Se identificaron dominios similares al dominio objetivo que podrían ser utilizados para ataques de phishing o suplantación de identidad.",
            "solution": "Considerar el registro proactivo de las variantes de dominio más críticas para proteger la marca. Educar a los empleados y usuarios sobre los riesgos de phishing y la importancia de verificar cuidadosamente las URLs antes de hacer clic o introducir credenciales."
        })

    # Recomendaciones para CVEs
    for cve in cves_data:
        recommendations.append({
            "title": f"Parchear CVE: {cve.get('cve_id', 'N/A')}",
            "description": f"Se detectó una vulnerabilidad conocida ({cve.get('cve_id', 'N/A')}) en {cve.get('affected_technology', 'N/A')}.",
            "solution": "Consultar las bases de datos de vulnerabilidades (NVD, CVE Mitre) para obtener información detallada sobre el parche o la mitigación específica. Actualizar el software o componente afectado a la última versión estable que contenga la corrección para el CVE."
        })

    # Recomendaciones para Nmap (ejemplo: puertos abiertos inesperados)
    if nmap_data:
        open_ports = [item for item in nmap_data if item.get('state') == 'open']
        if open_ports:
            recommendations.append({
                "title": "Revisión y Cierre de Puertos Abiertos",
                "description": f"Se detectaron {len(open_ports)} puertos abiertos en los hosts escaneados. Algunos de estos puertos podrían no ser necesarios o estar mal configurados, exponiendo servicios innecesarios.",
                "solution": "Realizar una auditoría de todos los puertos abiertos para determinar su necesidad. Cerrar o filtrar mediante firewall cualquier puerto que no sea estrictamente necesario para la operación del servicio. Asegurarse de que los servicios expuestos estén correctamente configurados, parcheados y protegidos con autenticación fuerte."
            })

    # Recomendaciones para configuración de seguridad
    if security_config_data:
        recommendations.append({
            "title": "Optimización de la Configuración de Seguridad",
            "description": "Se identificaron posibles malas configuraciones de seguridad en el servidor web o las aplicaciones.",
            "solution": "Revisar y aplicar las mejores prácticas de seguridad para la configuración del servidor web (e.g., Apache, Nginx) y las aplicaciones. Esto incluye la eliminación de cabeceras informativas (Server, X-Powered-By), la configuración de políticas de seguridad de contenido (CSP), la implementación de HSTS, y la protección contra ataques comunes como XSS y CSRF."
        })

    # Recomendaciones para fuerza bruta de directorios
    if dir_brute_data:
        recommendations.append({
            "title": "Proteger Directorios y Archivos Expuestos",
            "description": f"Se detectaron {len(dir_brute_data)} directorios o archivos accesibles públicamente que podrían contener información sensible o ser puntos de entrada para ataques.",
            "solution": "Revisar los directorios y archivos expuestos para asegurar que no contengan información sensible. Implementar controles de acceso adecuados (autenticación, autorización) para proteger recursos críticos. Eliminar archivos innecesarios o de respaldo que puedan haber quedado expuestos. Considerar el uso de un WAF (Web Application Firewall) para mitigar ataques de fuerza bruta y enumeración de directorios." 
        })

    return {
        "recommendations": recommendations,
        "risk_level": risk_level,
        "risk_score": risk_score,
        "executive_summary": " ".join(executive_summary_text),
        "nuclei_severity_counts": nuclei_severity_counts,
        "tls_grade": tls_grade
    }

def build_pdf(
    domain: str,
    recipient_email: str,
    tmp_dir: Path,
    httpx_file: Path,
    nuclei_file: Path,
    tls_file: Path,
    leaks_file: Path,
    typosquats_file: Path,
    dir_brute_file: Path,
    screenshots_file: Path,
    cves_file: Path,
    nmap_file: Path,
    security_config_file: Path, # Add new argument for security config scan

) -> Path:
    """Genera un informe PDF con los resultados del escaneo.
    
    Args:
        domain: Dominio objetivo
        tmp_dir: Directorio temporal para almacenar resultados
        httpx_file: Archivo JSON con hosts activos
        nuclei_file: Archivo JSON con vulnerabilidades
        tls_file: Archivo JSON con resultados TLS
        leaks_file: Archivo JSON con credenciales filtradas
        typosquats_file: Archivo JSON con dominios typosquatting
        
    Returns:
        Path al archivo PDF generado
        
    Raises:
        ReportError: Si falla la generación del informe
    """
    log.info("📊 Iniciando generación de informe para %s", domain)
    
    output_pdf = tmp_dir / f"report_{domain}.pdf"
    output_html = tmp_dir / f"report_{domain}.html"
    
    # Verificar que existen los archivos de resultados
    for file_path, file_desc in [
        (httpx_file, "hosts activos"),
        (nuclei_file, "vulnerabilidades"),
        (tls_file, "resultados TLS"),
        (leaks_file, "credenciales filtradas"),
        (typosquats_file, "dominios typosquatting"),
        (cves_file, "hallazgos de CVEs"),
        (nmap_file, "hallazgos de Nmap"),
        (security_config_file, "hallazgos de configuración de seguridad"), # Add new file check
        (screenshots_file, "hallazgos de capturas de pantalla")
    ]:
        if not file_path.exists():
            raise ReportError(f"Archivo de {file_desc} no encontrado: {file_path}")
    
    # Cargar datos
    try:
        # Hosts activos
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)
        
        # Vulnerabilidades
        with open(nuclei_file, "r") as f:
            nuclei_data = json.load(f)
        
        # Resultados TLS
        with open(tls_file, "r") as f:
            tls_data = json.load(f)
        
        # Credenciales filtradas
        with open(leaks_file, "r") as f:
            leaks_data = json.load(f)
        
        # Dominios typosquatting
        with open(typosquats_file, "r") as f:
            typosquats_data = json.load(f)

        # Hallazgos de CVEs
        with open(cves_file, "r") as f:
            cves_data = json.load(f)

        # Hallazgos de Nmap
        with open(nmap_file, "r") as f:
            nmap_data = json.load(f)

        # Hallazgos de configuración de seguridad
        with open(security_config_file, "r") as f:
            security_config_data = json.load(f)

        # Hallazgos de fuerza bruta de directorios
        with open(dir_brute_file, "r") as f:
            dir_brute_data = json.load(f)

        # Hallazgos de capturas de pantalla
        with open(screenshots_file, "r") as f:
            screenshots_data = json.load(f)

        # Subdominios (recon)
        # The subdomains file is a simple list of subdomains, one per line.
        # We need to read it and count the lines.
        subdomains_file = tmp_dir / "subdomains.txt"
        subdomains_data = []
        if subdomains_file.exists():
            with open(subdomains_file, "r") as f:
                subdomains_data = [line.strip() for line in f if line.strip()]
    except json.JSONDecodeError as e:
        raise ReportError(f"Error al cargar datos JSON de un archivo: {str(e)}") from e
    except FileNotFoundError as e:
        raise ReportError(f"Archivo no encontrado durante la carga de datos: {str(e)}") from e
    except Exception as e:
        raise ReportError(f"Error inesperado durante la carga de datos: {str(e)}") from e
        raise ReportError(f"Error al cargar datos: {str(e)}") from e

    # Generar recomendaciones y resumen ejecutivo
    report_data = get_recommendations(
        nuclei_data,
        tls_data,
        leaks_data,
        typosquats_data,
        cves_data,
        nmap_data,
        security_config_data,
        dir_brute_data,
        domain
    )
    recommendations = report_data["recommendations"]
    risk_level = report_data["risk_level"]
    risk_score = report_data["risk_score"]
    executive_summary_text = report_data["executive_summary"]
    nuclei_severity_counts = report_data["nuclei_severity_counts"]
    tls_grade = report_data["tls_grade"]

    # Renderizar plantilla HTML
    if template_report is None:
        raise ReportError("La plantilla de informe no se pudo cargar.")

    try:
        html_content = template_report.render(
        domain=domain,
        date=datetime.date.today().strftime("%d/%m/%Y"),
        httpx_data=httpx_data,
        nuclei_data=nuclei_data,
        tls_data=tls_data,
        leaks_data=leaks_data,
        typosquats_data=typosquats_data,
        cves_data=cves_data,
        nmap_data=nmap_data,
        security_config_data=security_config_data,
        dir_brute_data=dir_brute_data,
        screenshots_data=screenshots_data,
            recommendations=recommendations,
            subdomains_count=len(subdomains_data) if subdomains_data else 0,
            httpx_count=len(httpx_data) if httpx_data else 0,
            nuclei_critical_high_count=sum(1 for v in nuclei_data if v.get("info", {}).get("severity", "").lower() in ["critical", "high"]),
            tls_findings_count=len(tls_data.get("findings", [])) if tls_data else 0,
            leaks_count=len(leaks_data) if leaks_data else 0,
            typosquats_count=len(typosquats_data) if typosquats_data else 0,
            cves_count=len(cves_data) if cves_data else 0,
            nmap_open_ports_count=sum(1 for nmap_item in nmap_data if nmap_item.get('state') == 'open') if nmap_data else 0,
            security_config_count=len(security_config_data) if security_config_data else 0,
            dir_brute_count=len(dir_brute_data) if dir_brute_data else 0,
            screenshots_count=len(screenshots_data) if screenshots_data else 0,
            risk_score=risk_score,
            risk_level=risk_level,
            executive_summary_text=executive_summary_text,
            nuclei_severity_counts=nuclei_severity_counts,
            tls_grade=tls_grade
        )
    except Exception as e:
        raise ReportError(f"Error al renderizar la plantilla HTML: {str(e)}") from e

    with open(output_html, "w", encoding="utf-8") as f:
        f.write(html_content)

    # Generar PDF con WeasyPrint
    try:
        from weasyprint import HTML
        HTML(string=html_content).write_pdf(str(output_pdf))
        log.info("PDF generado exitosamente con WeasyPrint en %s", output_pdf)
    except Exception as e:
        raise ReportError(f"Error al generar el PDF con WeasyPrint: {str(e)}") from e

    log.debug("build_pdf returning: %s", output_pdf)
    return output_pdf





def encode_pdf_for_email(pdf_path: Path) -> str:
    """Codifica un PDF en base64 para adjuntarlo a un email.
    
    Args:
        pdf_path: Ruta al archivo PDF
        
    Returns:
        String con el PDF codificado en base64
    """
    with open(pdf_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def send_notification(job_id: str, status_message: str, status_type: str, pdf_path: Optional[Path], recipient_email: str, subc: int, vulc: int, domain: str):
    """Envía una notificación por email con el informe adjunto.
    
    Args:
        job_id: ID del trabajo de escaneo.
        status_message: Mensaje de estado del escaneo.
        status_type: Tipo de estado (e.g., "success", "failed").
        pdf_path: Ruta al archivo PDF.
        recipient_email: Email del destinatario.
        subc: Número de subdominios encontrados.
        vulc: Número de vulnerabilidades encontradas.
        
    Returns:
        True si se envió correctamente, False en caso contrario.
    """
    log.info("📧 Enviando notificación a %s para el dominio %s (trabajo %s)", recipient_email, domain, job_id)
    
    # Obtener clave API de MailerSend
    api_key = os.getenv("MAILERSEND_API_KEY")
    if not api_key:
        log.error("No se ha configurado la clave API de MailerSend")
        return False
    
    try:
        # Importar requests si no está disponible en el ámbito global
        import requests
        from pentest.http import get_session
        from pentest.config import MAIL_SENDER_EMAIL, MAIL_SENDER_NAME
        
        # Asunto del correo
        subject = f"Pentest Express - Escaneo {status_type.capitalize()}: {job_id}"

        # Cuerpo del correo
        body = f"Hola,\n\nEl escaneo para el trabajo {job_id} ha finalizado con estado: {status_message}.\n\nDetalles:\n- Subdominios encontrados: {subc}\n- Vulnerabilidades encontradas: {vulc}\n\nSaludos,\nEl equipo de Pentest Express"

        # Datos para la API de MailerSend
        data = {
            "from": {"email": MAIL_SENDER_EMAIL, "name": MAIL_SENDER_NAME},
            "to": [{"email": recipient_email}],
            "subject": subject,
            "html": f"<p>{body.replace(chr(10), '<br>')}</p>"
        }

        # Adjuntar PDF si está disponible
        if pdf_path and pdf_path.exists():
            pdf_data = base64.b64encode(pdf_path.read_bytes()).decode("utf-8")
            data["attachments"] = [
                {
                    "filename": pdf_path.name,
                    "content": pdf_data
                }
            ]
            body += "\n\nAdjunto encontrarás el informe completo."

        # Enviar correo
        session = get_session()
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        response = session.post("https://api.mailersend.com/v1/email", headers=headers, json=data)
        response.raise_for_status() # Lanza una excepción para códigos de estado HTTP erróneos

        log.info("✅ Notificación enviada correctamente para el dominio %s", domain)
        return True

    except requests.exceptions.RequestException as e:
        log.error("Error al enviar notificación para el dominio %s: %s", domain, e)
        return False
    except Exception as e:
        log.error("Error inesperado al enviar notificación para el dominio %s: %s", domain, e)
        return False