"""Módulo para generación de informes."""

import base64
import datetime
import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

import pdfkit
from jinja2 import Environment, FileSystemLoader, select_autoescape

from pentest.exceptions import ReportError
from pentest.config import TEMPLATES_DIR, MAIL_SENDER_EMAIL, MAIL_SENDER_NAME
from pentest.http import get_session
import requests

# Configuración de logging
log = logging.getLogger(__name__)

# Inicializar entorno Jinja2 y precompilar plantilla
try:
    env = Environment(
        loader=FileSystemLoader(TEMPLATES_DIR),
        autoescape=select_autoescape(['html', 'xml'])
    )
    template_report = env.get_template("report.html")
except Exception as e:
    log.warning("Error al inicializar Jinja2: %s", str(e))
    template_report = None

# Configuración de pdfkit
WKHTMLTOPDF_PATH = os.environ.get('WKHTMLTOPDF_PATH', '/usr/local/bin/wkhtmltopdf')
log.info(f"Usando WKHTMLTOPDF_PATH: {WKHTMLTOPDF_PATH}")

# Verificar si wkhtmltopdf existe en la ruta especificada
if not os.path.exists(WKHTMLTOPDF_PATH):
    log.warning(f"wkhtmltopdf no encontrado en {WKHTMLTOPDF_PATH}. Asegúrate de que esté instalado y la ruta sea correcta.")

config = pdfkit.configuration(wkhtmltopdf=WKHTMLTOPDF_PATH)

def get_recommendations(
    nuclei_data: List[Dict[str, Any]],
    tls_data: Dict[str, Any],
    leaks_data: List[Dict[str, Any]],
    typosquats_data: List[Dict[str, Any]],
    cves_data: List[Dict[str, Any]],
    nmap_data: List[Dict[str, Any]],
    security_config_data: List[Dict[str, Any]]
) -> List[Dict[str, str]]:
    """Genera una lista de recomendaciones basadas en los hallazgos del escaneo."""
    recommendations = []

    # Recomendaciones para vulnerabilidades de Nuclei
    for vuln in nuclei_data:
        severity = vuln.get("info", {}).get("severity", "").lower()
        if severity in ["critical", "high"]:
            recommendations.append({
                "title": f"Vulnerabilidad {severity.capitalize()}: {vuln.get('info', {}).get('name', 'N/A')}",
                "description": f"Se detectó una vulnerabilidad de {severity} en {vuln.get('host', 'N/A')}. Detalles: {vuln.get('info', {}).get('description', 'N/A')}",
                "solution": f"Referencia: {vuln.get('info', {}).get('reference', 'N/A')}. Aplicar parches, actualizar software o reconfigurar según la vulnerabilidad específica."
            })

    # Recomendaciones para problemas TLS
    for finding in tls_data.get("findings", []):
        recommendations.append({
            "title": f"Problema TLS: {finding.get('id', 'N/A')}",
            "description": f"Se detectó un problema de configuración TLS: {finding.get('description', 'N/A')}",
            "solution": f"Configurar el servidor para usar versiones de TLS seguras (TLS 1.2 o 1.3), deshabilitar cifrados débiles y asegurar que los certificados sean válidos y estén actualizados."
        })

    # Recomendaciones para credenciales filtradas
    if leaks_data:
        recommendations.append({
            "title": "Credenciales filtradas detectadas",
            "description": "Se encontraron direcciones de correo electrónico asociadas con brechas de seguridad conocidas. Esto representa un riesgo de compromiso de cuentas.",
            "solution": "Cambiar inmediatamente las contraseñas de las cuentas afectadas, usar contraseñas únicas y fuertes para cada servicio, y habilitar la autenticación de dos factores (2FA) siempre que sea posible."
        })

    # Recomendaciones para typosquatting
    if typosquats_data:
        recommendations.append({
            "title": "Riesgo de Typosquatting",
            "description": "Se identificaron dominios similares al dominio objetivo que podrían ser utilizados para ataques de phishing o suplantación de identidad.",
            "solution": "Considerar el registro de estos dominios para proteger la marca y evitar su uso malicioso. Educar a los usuarios sobre la verificación de URLs antes de hacer clic."
        })

    # Recomendaciones para CVEs
    for cve in cves_data:
        recommendations.append({
            "title": f"CVE detectado: {cve.get('cve_id', 'N/A')}",
            "description": f"Se detectó una vulnerabilidad conocida ({cve.get('cve_id', 'N/A')}) en {cve.get('affected_technology', 'N/A')}.",
            "solution": "Consultar la base de datos de CVEs para obtener información detallada sobre el parche o la mitigación. Actualizar el software afectado a la última versión estable."
        })

    # Recomendaciones para Nmap (ejemplo: puertos abiertos inesperados)
    if nmap_data:
        open_ports_count = sum(1 for nmap_item in nmap_data if nmap_item.get('state') == 'open')
        if open_ports_count > 0:
            recommendations.append({
                "title": "Puertos abiertos detectados",
                "description": f"Se detectaron {open_ports_count} puertos abiertos en los hosts escaneados. Algunos de estos puertos podrían no ser necesarios o estar mal configurados.",
                "solution": "Revisar la necesidad de cada puerto abierto. Cerrar los puertos no utilizados o filtrar el acceso a ellos mediante firewalls. Asegurarse de que los servicios expuestos estén correctamente configurados y parcheados."
            })

    # Recomendaciones para configuración de seguridad
    for config_finding in security_config_data:
        recommendations.append({
            "title": f"Hallazgo de configuración de seguridad: {config_finding.get('type', 'N/A')}",
            "description": f"Se identificó una posible mala configuración de seguridad: {config_finding.get('description', 'N/A')}",
            "solution": "Revisar la configuración del servidor web y de las aplicaciones para aplicar las mejores prácticas de seguridad. Esto puede incluir la eliminación de cabeceras informativas, la configuración de políticas de seguridad de contenido (CSP) y la protección contra ataques comunes."
        })

    return recommendations

def build_pdf(
    domain: str,
    recipient_email: str,
    tmp_dir: Path,
    httpx_file: Path,
    nuclei_file: Path,
    tls_file: Path,
    leaks_file: Path,
    typosquats_file: Path,
    cves_file: Path,
    nmap_file: Path,
    security_config_file: Path, # Add new argument for security config scan
    pdfkit_config: pdfkit.configuration # Add pdfkit configuration as argument
) -> Path:
    """Genera un informe PDF con los resultados del escaneo.
    
    Args:
        domain: Dominio objetivo
        tmp_dir: Directorio temporal para almacenar resultados
        httpx_file: Archivo JSON con hosts activos
        nuclei_file: Archivo JSON con vulnerabilidades
        tls_file: Archivo JSON con resultados TLS
        leaks_file: Archivo JSON con credenciales filtradas
        typosquats_file: Archivo JSON con dominios typosquatting
        
    Returns:
        Path al archivo PDF generado
        
    Raises:
        ReportError: Si falla la generación del informe
    """
    log.info("📊 Iniciando generación de informe para %s", domain)
    
    output_pdf = tmp_dir / f"report_{domain}.pdf"
    output_html = tmp_dir / f"report_{domain}.html"
    
    # Verificar que existen los archivos de resultados
    for file_path, file_desc in [
        (httpx_file, "hosts activos"),
        (nuclei_file, "vulnerabilidades"),
        (tls_file, "resultados TLS"),
        (leaks_file, "credenciales filtradas"),
        (typosquats_file, "dominios typosquatting"),
        (cves_file, "hallazgos de CVEs"),
        (nmap_file, "hallazgos de Nmap"),
        (security_config_file, "hallazgos de configuración de seguridad") # Add new file check
    ]:
        if not file_path.exists():
            raise ReportError(f"Archivo de {file_desc} no encontrado: {file_path}")
    
    # Cargar datos
    try:
        # Hosts activos
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)
        
        # Vulnerabilidades
        with open(nuclei_file, "r") as f:
            nuclei_data = json.load(f)
        
        # Resultados TLS
        with open(tls_file, "r") as f:
            tls_data = json.load(f)
        
        # Credenciales filtradas
        with open(leaks_file, "r") as f:
            leaks_data = json.load(f)
        
        # Dominios typosquatting
        with open(typosquats_file, "r") as f:
            typosquats_data = json.load(f)

        # Hallazgos de CVEs
        with open(cves_file, "r") as f:
            cves_data = json.load(f)

        # Hallazgos de Nmap
        with open(nmap_file, "r") as f:
            nmap_data = json.load(f)

        # Hallazgos de configuración de seguridad
        with open(security_config_file, "r") as f:
            security_config_data = json.load(f)
    except json.JSONDecodeError as e:
        raise ReportError(f"Error al cargar datos JSON de un archivo: {str(e)}") from e
    except FileNotFoundError as e:
        raise ReportError(f"Archivo no encontrado durante la carga de datos: {str(e)}") from e
    except Exception as e:
        raise ReportError(f"Error inesperado durante la carga de datos: {str(e)}") from e
        raise ReportError(f"Error al cargar datos: {str(e)}") from e

    # Generar recomendaciones
    recommendations = get_recommendations(
        nuclei_data,
        tls_data,
        leaks_data,
        typosquats_data,
        cves_data,
        nmap_data,
        security_config_data
    )

    # Renderizar plantilla HTML
    if template_report is None:
        raise ReportError("La plantilla de informe no se pudo cargar.")

    try:
        html_content = template_report.render(
            domain=domain,
            date=datetime.date.today().strftime("%d/%m/%Y"),
            httpx_data=httpx_data,
            nuclei_data=nuclei_data,
            tls_data=tls_data,
            leaks_data=leaks_data,
            typosquats_data=typosquats_data,
            cves_data=cves_data,
            nmap_data=nmap_data,
            security_config_data=security_config_data,
            recommendations=recommendations
        )
    except Exception as e:
        raise ReportError(f"Error al renderizar la plantilla HTML: {str(e)}") from e

    with open(output_html, "w", encoding="utf-8") as f:
        f.write(html_content)

    # Generar PDF
    try:
        pdfkit.from_file(str(output_html), str(output_pdf), configuration=pdfkit_config)
        log.info("PDF generado exitosamente en %s", output_pdf)
    except Exception as e:
        raise ReportError(f"Error al generar el PDF: {str(e)}") from e

    # Enviar notificación por correo electrónico
    try:
        send_notification(recipient_email, domain, output_pdf)
        log.info("Notificación de informe enviada a %s", recipient_email)
    except Exception as e:
        log.error("Error al enviar la notificación por correo electrónico: %s", str(e))
        # No re-raise, ya que el PDF ya se generó y el escaneo puede continuar



def encode_pdf_for_email(pdf_path: Path) -> str:
    """Codifica un PDF en base64 para adjuntarlo a un email.
    
    Args:
        pdf_path: Ruta al archivo PDF
        
    Returns:
        String con el PDF codificado en base64
    """
    with open(pdf_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")

def send_notification(job_id: str, status_message: str, status_type: str, pdf_path: Path, recipient_email: str, subc: int, vulc: int):
    """Envía una notificación por email con el informe adjunto.
    
    Args:
        job_id: ID del trabajo de escaneo.
        status_message: Mensaje de estado del escaneo.
        status_type: Tipo de estado (e.g., "success", "failed").
        pdf_path: Ruta al archivo PDF.
        recipient_email: Email del destinatario.
        subc: Número de subdominios encontrados.
        vulc: Número de vulnerabilidades encontradas.
        
    Returns:
        True si se envió correctamente, False en caso contrario.
    """
    log.info("📧 Enviando notificación a %s para el trabajo %s", recipient_email, domain)
    
    # Obtener clave API de MailerSend
    api_key = os.getenv("MAILERSEND_API_KEY")
    if not api_key:
        log.error("No se ha configurado la clave API de MailerSend")
        return False
    
    try:
        # Importar requests si no está disponible en el ámbito global
        import requests
        from pentest.http import get_session
        from pentest.config import MAIL_SENDER_EMAIL, MAIL_SENDER_NAME
        
        # Codificar PDF
        pdf_data = base64.b64encode(pdf_path.read_bytes()).decode("utf-8")

        # Asunto del correo
        subject = f"Pentest Express - Escaneo {status_type.capitalize()}: {job_id}"

        # Cuerpo del correo
        body = f"Hola,\n\nEl escaneo para el trabajo {job_id} ha finalizado con estado: {status_message}.\n\nDetalles:\n- Subdominios encontrados: {subc}\n- Vulnerabilidades encontradas: {vulc}\n\nAdjunto encontrarás el informe completo.\n\nSaludos,\nEl equipo de Pentest Express"

        # Datos para la API de MailerSend
        data = {
            "from": {"email": MAIL_SENDER_EMAIL, "name": MAIL_SENDER_NAME},
            "to": [{"email": recipient_email}],
            "subject": subject,
            "html": f"<p>{body.replace(chr(10), '<br>')}</p>",
            "attachments": [
                {
                    "filename": pdf_path.name,
                    "content": pdf_data
                }
            ]
        }

        # Enviar correo
        session = get_session()
        headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
        response = session.post("https://api.mailersend.com/v1/email", headers=headers, json=data)
        response.raise_for_status() # Lanza una excepción para códigos de estado HTTP erróneos

        log.info("✅ Notificación enviada correctamente para el dominio %s", domain)
        return True

    except requests.exceptions.RequestException as e:
        log.error("Error al enviar notificación para el dominio %s: %s", domain, e)
        return False
    except Exception as e:
        log.error("Error inesperado al enviar notificación para el dominio %s: %s", domain, e)
        return False