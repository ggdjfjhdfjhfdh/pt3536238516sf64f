#!/usr/bin/env python3
"""
Módulo de Integración ML con el Pipeline Principal
Conecta el sistema de IA/ML predictivo con el escáner de seguridad
"""

import json
import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
import redis
import pickle

try:
    from .ml_predictive_analysis import (
        MLPredictiveAnalyzer, SecurityEvent, PredictionResult, ThreatPattern
    )
    from .advanced_ml_engine import AdvancedMLEngine, AdvancedSecurityEvent, AdvancedPredictionResult
    from .config.ml_config import ML_CONFIG
    from .metrics import MetricsCollector
except ImportError as e:
    logging.warning(f"Importación ML no disponible: {e}")
    MLPredictiveAnalyzer = None
    SecurityEvent = None
    PredictionResult = None
    ThreatPattern = None
    AdvancedMLEngine = None
    AdvancedSecurityEvent = None
    AdvancedPredictionResult = None
    ML_CONFIG = None
    MetricsCollector = None

# Configuración de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class MLEnhancedScanResult:
    """Resultado de escaneo enriquecido con análisis ML"""
    original_result: Dict[str, Any]
    ml_prediction: Optional[PredictionResult]
    threat_patterns: List[ThreatPattern]
    risk_assessment: Dict[str, Any]
    recommendations: List[str]
    confidence_score: float
    processing_time: float
    timestamp: datetime

class MLIntegrationManager:
    """Gestor de integración entre ML y el pipeline de escaneo"""
    
    def __init__(self, redis_client=None, enable_cache=True):
        self.ml_analyzer = None
        self.advanced_engine = None
        self.redis_client = redis_client
        self.enable_cache = enable_cache
        self.metrics_collector = None
        self.use_advanced_engine = True
        self.processing_stats = {
            'total_scans': 0,
            'ml_enhanced_scans': 0,
            'advanced_enhanced_scans': 0,
            'cache_hits': 0,
            'cache_misses': 0,
            'errors': 0
        }
        
        self._initialize_components()
    
    def _initialize_components(self):
        """Inicializa los componentes ML"""
        try:
            if MLPredictiveAnalyzer:
                self.ml_analyzer = MLPredictiveAnalyzer()
                self.ml_analyzer.load_models()
                logger.info("Analizador ML inicializado")
            
            if AdvancedMLEngine:
                self.advanced_engine = AdvancedMLEngine()
                logger.info("Motor ML Avanzado inicializado")
                self.use_advanced_engine = True
            else:
                self.use_advanced_engine = False
            
            if MetricsCollector:
                self.metrics_collector = MetricsCollector()
                logger.info("Collector de métricas inicializado")
            
            # Configurar Redis si está disponible
            if not self.redis_client and self.enable_cache:
                try:
                    import redis
                    from .config import REDIS_URL
                    self.redis_client = redis.Redis.from_url(
                        REDIS_URL, decode_responses=True
                    )
                    self.redis_client.ping()
                    logger.info(f"Conexión Redis establecida: {REDIS_URL}")
                except Exception as e:
                    logger.warning(f"Redis no disponible: {e}")
                    logger.info(f"URL Redis configurada: {REDIS_URL if 'REDIS_URL' in locals() else 'No disponible'}")
                    self.enable_cache = False
        
        except Exception as e:
            logger.error(f"Error inicializando componentes ML: {e}")
    
    def is_ml_available(self) -> bool:
        """Verifica si el sistema ML está disponible"""
        basic_available = self.ml_analyzer is not None and self.ml_analyzer.models_loaded
        advanced_available = self.advanced_engine is not None
        return basic_available or advanced_available
    
    def convert_scan_to_security_event(self, scan_result: Dict[str, Any], 
                                     target_domain: str) -> SecurityEvent:
        """Convierte resultado de escaneo a SecurityEvent para ML"""
        try:
            # Extraer información del resultado de escaneo
            vulnerabilities = scan_result.get('vulnerabilities', [])
            technologies = scan_result.get('technologies', [])
            ports = scan_result.get('open_ports', [])
            
            # Calcular threat score basado en vulnerabilidades
            threat_score = self._calculate_threat_score(vulnerabilities)
            
            # Extraer información de red
            network_info = scan_result.get('network_info', {})
            response_time = network_info.get('avg_response_time', 1.0)
            
            # Crear evento de seguridad
            event = SecurityEvent(
                timestamp=datetime.now(),
                event_type="security_scan",
                severity=self._determine_severity(threat_score, len(vulnerabilities)),
                source_ip="scanner",
                target_domain=target_domain,
                vulnerability_count=len(vulnerabilities),
                threat_score=threat_score,
                technologies=[tech.get('name', '') for tech in technologies if isinstance(tech, dict)],
                ports_open=ports if isinstance(ports, list) else [],
                response_time=response_time,
                status_code=scan_result.get('status_code', 200),
                payload_size=scan_result.get('content_length', 0),
                user_agent="PentestExpress",
                country=scan_result.get('geo_location', {}).get('country', 'Unknown'),
                is_malicious=threat_score > 7.0
            )
            
            return event
        
        except Exception as e:
            logger.error(f"Error convirtiendo scan a SecurityEvent: {e}")
            # Retornar evento básico en caso de error
            return SecurityEvent(
                timestamp=datetime.now(),
                event_type="security_scan",
                severity="UNKNOWN",
                source_ip="scanner",
                target_domain=target_domain,
                vulnerability_count=0,
                threat_score=0.0,
                technologies=[],
                ports_open=[],
                response_time=1.0,
                status_code=200,
                payload_size=0,
                user_agent="PentestExpress",
                country="Unknown",
                is_malicious=False
            )
    
    def _calculate_threat_score(self, vulnerabilities: List[Dict]) -> float:
        """Calcula puntuación de amenaza basada en vulnerabilidades"""
        if not vulnerabilities:
            return 0.0
        
        score = 0.0
        severity_weights = {
            'CRITICAL': 10.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'INFO': 1.0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW').upper()
            weight = severity_weights.get(severity, 1.0)
            score += weight
        
        # Normalizar a escala 0-10
        max_possible = len(vulnerabilities) * 10.0
        normalized_score = min((score / max_possible) * 10.0, 10.0) if max_possible > 0 else 0.0
        
        return normalized_score
    
    def _determine_severity(self, threat_score: float, vuln_count: int) -> str:
        """Determina la severidad basada en threat score y cantidad de vulnerabilidades"""
        if threat_score >= 8.0 or vuln_count >= 20:
            return "CRITICAL"
        elif threat_score >= 6.0 or vuln_count >= 10:
            return "HIGH"
        elif threat_score >= 4.0 or vuln_count >= 5:
            return "MEDIUM"
        elif threat_score >= 2.0 or vuln_count >= 1:
            return "LOW"
        else:
            return "INFO"
    
    def get_cached_prediction(self, cache_key: str) -> Optional[PredictionResult]:
        """Obtiene predicción desde cache"""
        if not self.enable_cache or not self.redis_client:
            return None
        
        try:
            cached_data = self.redis_client.get(f"ml_pred:{cache_key}")
            if cached_data:
                self.processing_stats['cache_hits'] += 1
                return pickle.loads(cached_data.encode('latin1'))
        except Exception as e:
            logger.warning(f"Error obteniendo cache: {e}")
        
        self.processing_stats['cache_misses'] += 1
        return None
    
    def cache_prediction(self, cache_key: str, prediction: PredictionResult):
        """Guarda predicción en cache"""
        if not self.enable_cache or not self.redis_client:
            return
        
        try:
            ttl = ML_CONFIG.CACHE['cache_ttl_seconds'] if ML_CONFIG else 300
            cached_data = pickle.dumps(prediction).decode('latin1')
            self.redis_client.setex(
                f"ml_pred:{cache_key}", 
                ttl, 
                cached_data
            )
        except Exception as e:
            logger.warning(f"Error guardando en cache: {e}")
    
    def enhance_scan_result(self, scan_result: Dict[str, Any], 
                          target_domain: str) -> MLEnhancedScanResult:
        """Enriquece resultado de escaneo con análisis ML"""
        start_time = datetime.now()
        self.processing_stats['total_scans'] += 1
        
        try:
            # Verificar si ML está disponible
            if not self.is_ml_available():
                logger.warning("Sistema ML no disponible, retornando resultado básico")
                return self._create_basic_result(scan_result, start_time)
            
            # Usar motor avanzado si está disponible
            if self.use_advanced_engine and self.advanced_engine:
                return self._enhance_with_advanced_engine(scan_result, target_domain, start_time)
            else:
                return self._enhance_with_basic_engine(scan_result, target_domain, start_time)
        
        except Exception as e:
            logger.error(f"Error en análisis ML: {e}")
            self.processing_stats['errors'] += 1
            return self._create_basic_result(scan_result, start_time)
    
    def _generate_cache_key(self, scan_result: Dict[str, Any], target_domain: str) -> str:
        """Genera clave de cache basada en características del escaneo"""
        key_components = [
            target_domain,
            str(len(scan_result.get('vulnerabilities', []))),
            str(len(scan_result.get('technologies', []))),
            str(len(scan_result.get('open_ports', []))),
            scan_result.get('scan_type', 'unknown')
        ]
        return ":".join(key_components)
    
    def _get_threat_patterns(self, target_domain: str) -> List[ThreatPattern]:
        """Obtiene patrones de amenazas para el dominio"""
        try:
            # En una implementación real, esto obtendría eventos históricos
            # Por ahora retornamos lista vacía
            return []
        except Exception as e:
            logger.warning(f"Error obteniendo patrones: {e}")
            return []
    
    def _update_metrics(self, prediction: PredictionResult, event: SecurityEvent):
        """Actualiza métricas del sistema ML"""
        try:
            metrics = {
                'ml_prediction_confidence': prediction.confidence,
                'ml_risk_score': prediction.risk_score,
                'ml_anomaly_score': prediction.anomaly_score,
                'ml_prediction_type': prediction.prediction,
                'event_vulnerability_count': event.vulnerability_count,
                'event_threat_score': event.threat_score
            }
            
            self.metrics_collector.record_ml_metrics(metrics)
        except Exception as e:
            logger.warning(f"Error actualizando métricas: {e}")
    
    def _create_enhanced_result(self, scan_result: Dict[str, Any], 
                              prediction: PredictionResult,
                              patterns: List[ThreatPattern],
                              start_time: datetime) -> MLEnhancedScanResult:
        """Crea resultado enriquecido con ML"""
        processing_time = (datetime.now() - start_time).total_seconds()
        
        # Generar evaluación de riesgo
        risk_assessment = {
            'overall_risk': prediction.risk_score,
            'threat_probability': prediction.confidence if prediction.prediction == "malicious" else 1 - prediction.confidence,
            'anomaly_detected': prediction.anomaly_score > 0.5,
            'risk_level': self._get_risk_level(prediction.risk_score),
            'factors': self._analyze_risk_factors(scan_result, prediction)
        }
        
        # Combinar recomendaciones
        all_recommendations = prediction.recommendations.copy()
        all_recommendations.extend(self._generate_integration_recommendations(scan_result, prediction))
        
        return MLEnhancedScanResult(
            original_result=scan_result,
            ml_prediction=prediction,
            threat_patterns=patterns,
            risk_assessment=risk_assessment,
            recommendations=all_recommendations,
            confidence_score=prediction.confidence,
            processing_time=processing_time,
            timestamp=datetime.now()
        )
    
    def _create_basic_result(self, scan_result: Dict[str, Any], 
                           start_time: datetime) -> MLEnhancedScanResult:
        """Crea resultado básico sin análisis ML"""
        processing_time = (datetime.now() - start_time).total_seconds()
        
        # Análisis básico sin ML
        vuln_count = len(scan_result.get('vulnerabilities', []))
        basic_risk = min(vuln_count * 5, 100)  # Riesgo básico
        
        risk_assessment = {
            'overall_risk': basic_risk,
            'threat_probability': 0.0,
            'anomaly_detected': False,
            'risk_level': self._get_risk_level(basic_risk),
            'factors': ['Análisis ML no disponible']
        }
        
        recommendations = self._generate_basic_recommendations(scan_result)
        
        return MLEnhancedScanResult(
            original_result=scan_result,
            ml_prediction=None,
            threat_patterns=[],
            risk_assessment=risk_assessment,
            recommendations=recommendations,
            confidence_score=0.5,  # Confianza neutral
            processing_time=processing_time,
            timestamp=datetime.now()
        )
    
    def _get_risk_level(self, risk_score: float) -> str:
        """Determina nivel de riesgo basado en puntuación"""
        if risk_score >= 80:
            return "CRÍTICO"
        elif risk_score >= 60:
            return "ALTO"
        elif risk_score >= 40:
            return "MEDIO"
        elif risk_score >= 20:
            return "BAJO"
        else:
            return "MÍNIMO"
    
    def _analyze_risk_factors(self, scan_result: Dict[str, Any], 
                            prediction: PredictionResult) -> List[str]:
        """Analiza factores de riesgo"""
        factors = []
        
        vuln_count = len(scan_result.get('vulnerabilities', []))
        if vuln_count > 10:
            factors.append(f"Múltiples vulnerabilidades detectadas ({vuln_count})")
        
        if prediction and prediction.prediction == "malicious":
            factors.append("Actividad maliciosa predicha por ML")
        
        if prediction and prediction.anomaly_score > 0.5:
            factors.append("Comportamiento anómalo detectado")
        
        open_ports = scan_result.get('open_ports', [])
        if len(open_ports) > 20:
            factors.append(f"Muchos puertos abiertos ({len(open_ports)})")
        
        # Verificar puertos peligrosos
        if ML_CONFIG:
            dangerous_ports = [p for p in open_ports if ML_CONFIG.is_dangerous_port(p)]
            if dangerous_ports:
                factors.append(f"Puertos peligrosos expuestos: {dangerous_ports}")
        
        return factors
    
    def _generate_integration_recommendations(self, scan_result: Dict[str, Any], 
                                            prediction: PredictionResult) -> List[str]:
        """Genera recomendaciones específicas de integración"""
        recommendations = []
        
        # Recomendaciones basadas en tecnologías detectadas
        technologies = scan_result.get('technologies', [])
        for tech in technologies:
            if isinstance(tech, dict):
                tech_name = tech.get('name', '').lower()
                if 'wordpress' in tech_name:
                    recommendations.append("🔧 WordPress detectado - Verificar plugins y actualizaciones")
                elif 'apache' in tech_name:
                    recommendations.append("🔧 Apache detectado - Revisar configuración de seguridad")
                elif 'nginx' in tech_name:
                    recommendations.append("🔧 Nginx detectado - Verificar configuración SSL/TLS")
        
        # Recomendaciones basadas en vulnerabilidades
        vulnerabilities = scan_result.get('vulnerabilities', [])
        critical_vulns = [v for v in vulnerabilities if v.get('severity') == 'CRITICAL']
        if critical_vulns:
            recommendations.append(f"🚨 {len(critical_vulns)} vulnerabilidades críticas - Parchear inmediatamente")
        
        return recommendations
    
    def _generate_basic_recommendations(self, scan_result: Dict[str, Any]) -> List[str]:
        """Genera recomendaciones básicas sin ML"""
        recommendations = []
        
        vuln_count = len(scan_result.get('vulnerabilities', []))
        if vuln_count > 0:
            recommendations.append(f"🔍 {vuln_count} vulnerabilidades encontradas - Revisar y remediar")
        
        open_ports = scan_result.get('open_ports', [])
        if len(open_ports) > 10:
            recommendations.append("🔐 Muchos puertos abiertos - Cerrar servicios innecesarios")
        
        recommendations.append("🤖 Habilitar análisis ML para evaluación avanzada de riesgos")
        
        return recommendations
    
    def get_processing_stats(self) -> Dict[str, Any]:
        """Obtiene estadísticas de procesamiento"""
        stats = self.processing_stats.copy()
        stats['ml_available'] = self.is_ml_available()
        stats['cache_enabled'] = self.enable_cache
        stats['ml_enhancement_rate'] = (
            stats['ml_enhanced_scans'] / stats['total_scans'] 
            if stats['total_scans'] > 0 else 0
        )
        return stats
    
    def _enhance_with_advanced_engine(self, scan_result: Dict[str, Any], 
                                    target_domain: str, start_time: datetime) -> MLEnhancedScanResult:
        """Enriquece usando el motor ML avanzado"""
        try:
            # Convertir a evento avanzado
            advanced_event = self._convert_to_advanced_event(scan_result, target_domain)
            
            # Generar reporte comprehensivo
            comprehensive_report = self.advanced_engine.generate_comprehensive_report([advanced_event])
            
            # Convertir a resultado enriquecido
            enhanced_result = self._create_enhanced_result_from_comprehensive(
                scan_result, comprehensive_report, start_time
            )
            
            self.processing_stats['advanced_enhanced_scans'] += 1
            logger.info("Análisis ML avanzado completado")
            
            return enhanced_result
            
        except Exception as e:
            logger.error(f"Error en motor avanzado: {e}")
            return self._enhance_with_basic_engine(scan_result, target_domain, start_time)
    
    def _enhance_with_basic_engine(self, scan_result: Dict[str, Any], 
                                 target_domain: str, start_time: datetime) -> MLEnhancedScanResult:
        """Enriquece usando el motor ML básico"""
        try:
            # Crear cache key
            cache_key = self._generate_cache_key(scan_result, target_domain)
            
            # Intentar obtener desde cache
            cached_prediction = self.get_cached_prediction(cache_key)
            if cached_prediction:
                logger.debug("Usando predicción desde cache")
                return self._create_enhanced_result(
                    scan_result, cached_prediction, [], start_time
                )
            
            # Convertir a evento de seguridad
            security_event = self.convert_scan_to_security_event(scan_result, target_domain)
            
            # Realizar predicción ML
            prediction = self.ml_analyzer.predict_threat(security_event)
            
            # Detectar patrones
            patterns = self._get_threat_patterns(target_domain)
            
            # Guardar en cache
            self.cache_prediction(cache_key, prediction)
            
            # Actualizar métricas
            if self.metrics_collector:
                self._update_metrics(prediction, security_event)
            
            self.processing_stats['ml_enhanced_scans'] += 1
            
            return self._create_enhanced_result(scan_result, prediction, patterns, start_time)
            
        except Exception as e:
            logger.error(f"Error en motor básico: {e}")
            raise
    
    def _convert_to_advanced_event(self, scan_result: Dict[str, Any], 
                                 target_domain: str) -> AdvancedSecurityEvent:
        """Convierte resultado de escaneo a evento avanzado"""
        try:
            vulnerabilities = scan_result.get('vulnerabilities', [])
            timestamp = datetime.now()
            
            return AdvancedSecurityEvent(
                timestamp=timestamp,
                event_id=f"scan_{int(timestamp.timestamp())}",
                event_type="comprehensive_scan",
                severity=self._determine_severity_from_vulns(vulnerabilities),
                source_ip="scanner",
                target_domain=target_domain,
                
                # Vulnerabilidades
                vulnerability_count=len(vulnerabilities),
                critical_vulns=len([v for v in vulnerabilities if v.get('severity') == 'CRITICAL']),
                high_vulns=len([v for v in vulnerabilities if v.get('severity') == 'HIGH']),
                medium_vulns=len([v for v in vulnerabilities if v.get('severity') == 'MEDIUM']),
                low_vulns=len([v for v in vulnerabilities if v.get('severity') == 'LOW']),
                
                # Tecnologías
                technologies=scan_result.get('technologies', []),
                web_frameworks=scan_result.get('web_frameworks', []),
                databases=scan_result.get('databases', []),
                cms_detected=scan_result.get('cms_detected', []),
                
                # Red
                ports_open=scan_result.get('open_ports', []),
                services_detected=scan_result.get('services', []),
                ssl_info=scan_result.get('ssl_info', {}),
                dns_records=scan_result.get('dns_records', []),
                
                # Rendimiento
                response_time=scan_result.get('response_time', 1.0),
                status_codes=scan_result.get('status_codes', [200]),
                payload_sizes=scan_result.get('payload_sizes', []),
                
                # Headers y contenido
                headers_analysis=scan_result.get('headers', {}),
                content_analysis=scan_result.get('content_analysis', {}),
                javascript_analysis=scan_result.get('javascript_analysis', {}),
                
                # Geolocalización
                country=scan_result.get('geo_location', {}).get('country', 'Unknown'),
                asn=scan_result.get('asn', 'Unknown'),
                organization=scan_result.get('organization', 'Unknown'),
                is_tor=scan_result.get('is_tor', False),
                is_vpn=scan_result.get('is_vpn', False),
                
                # Threat Intelligence
                threat_feeds=scan_result.get('threat_feeds', []),
                ioc_matches=scan_result.get('ioc_matches', []),
                reputation_score=scan_result.get('reputation_score', 0.5),
                
                # Comportamiento
                user_agents=scan_result.get('user_agents', ["PentestExpress"]),
                request_patterns=scan_result.get('request_patterns', []),
                timing_patterns=scan_result.get('timing_patterns', []),
                
                # Clasificación
                is_malicious=len([v for v in vulnerabilities if v.get('severity') in ['CRITICAL', 'HIGH']]) > 0,
                attack_types=scan_result.get('attack_types', []),
                confidence_level=0.8
            )
            
        except Exception as e:
            logger.error(f"Error convirtiendo a evento avanzado: {e}")
            raise
    
    def _determine_severity_from_vulns(self, vulnerabilities: List[Dict]) -> str:
        """Determina severidad basada en vulnerabilidades"""
        if any(v.get('severity') == 'CRITICAL' for v in vulnerabilities):
            return 'CRITICAL'
        elif any(v.get('severity') == 'HIGH' for v in vulnerabilities):
            return 'HIGH'
        elif any(v.get('severity') == 'MEDIUM' for v in vulnerabilities):
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _create_enhanced_result_from_comprehensive(self, scan_result: Dict[str, Any],
                                                 comprehensive_report: Dict,
                                                 start_time: datetime) -> MLEnhancedScanResult:
        """Crea resultado enriquecido desde reporte comprehensivo"""
        processing_time = (datetime.now() - start_time).total_seconds()
        
        summary = comprehensive_report.get('executive_summary', {})
        threat_analysis = comprehensive_report.get('threat_analysis', {})
        recommendations = comprehensive_report.get('recommendations', {})
        
        # Crear evaluación de riesgo
        risk_assessment = {
            'overall_risk': summary.get('average_risk_score', 0.0),
            'threat_probability': summary.get('malicious_rate', 0.0),
            'anomaly_detected': threat_analysis.get('anomaly_detection_rate', 0.0) > 0.5,
            'risk_level': self._get_risk_level(summary.get('average_risk_score', 0.0)),
            'factors': threat_analysis.get('primary_attack_vectors', {})
        }
        
        # Combinar recomendaciones
        all_recommendations = []
        all_recommendations.extend(recommendations.get('immediate_actions', []))
        all_recommendations.extend(recommendations.get('strategic_recommendations', []))
        
        return MLEnhancedScanResult(
            original_result=scan_result,
            ml_prediction=None,  # El motor avanzado no usa PredictionResult
            threat_patterns=[],
            risk_assessment=risk_assessment,
            recommendations=all_recommendations,
            confidence_score=summary.get('average_confidence', 0.5),
            processing_time=processing_time,
            timestamp=datetime.now()
        )
    
    def train_with_scan_data(self, scan_results: List[Dict[str, Any]], 
                           target_domains: List[str]):
        """Entrena modelos ML con datos de escaneos"""
        if not self.is_ml_available():
            logger.warning("Sistema ML no disponible para entrenamiento")
            return
        
        try:
            # Entrenar motor básico si está disponible
            if self.ml_analyzer:
                events = []
                for scan_result, domain in zip(scan_results, target_domains):
                    event = self.convert_scan_to_security_event(scan_result, domain)
                    events.append(event)
                
                logger.info(f"Entrenando modelos ML básicos con {len(events)} eventos")
                self.ml_analyzer.train_anomaly_detector(events)
                self.ml_analyzer.train_threat_classifier(events)
            
            # Entrenar motor avanzado si está disponible
            if self.advanced_engine:
                advanced_events = []
                for scan_result, domain in zip(scan_results, target_domains):
                    advanced_event = self._convert_to_advanced_event(scan_result, domain)
                    advanced_events.append(advanced_event)
                
                logger.info(f"Entrenando motor ML avanzado con {len(advanced_events)} eventos")
                # El motor avanzado maneja su propio entrenamiento internamente
            
            logger.info("Entrenamiento ML completado")
        
        except Exception as e:
            logger.error(f"Error en entrenamiento ML: {e}")

# Función de utilidad para integración fácil
def enhance_scan_with_ml(scan_result: Dict[str, Any], target_domain: str, 
                        ml_manager: Optional[MLIntegrationManager] = None) -> MLEnhancedScanResult:
    """Función de conveniencia para enriquecer escaneo con ML"""
    if ml_manager is None:
        ml_manager = MLIntegrationManager()
    
    return ml_manager.enhance_scan_result(scan_result, target_domain)

# Alias para compatibilidad
MLIntegration = MLIntegrationManager

# Instancia global para uso en el pipeline
ml_integration_manager = MLIntegrationManager()