import logging
import json
from pathlib import Path
import requests
import ipaddress
import socket
from typing import Dict, Optional, Tuple
from functools import lru_cache
import time

log = logging.getLogger("pentest")

GREYNOISE_API_URL = "https://api.greynoise.io/v3/community/{ip}"
GREYNOISE_TIMEOUT = 10  # seconds
MAX_RETRIES = 3
RETRY_DELAY = 1  # seconds

class GreyNoiseClient:
    """Cliente mejorado para la API de GreyNoise con cache y reintentos."""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({"key": api_key})
    
    def check_ip(self, ip: str) -> Dict:
        """Consulta la API de GreyNoise para una IP dada con reintentos."""
        if not self.api_key:
            log.warning("GREYNOISE_API_KEY no configurada. Saltando la comprobaci√≥n de GreyNoise.")
            return {}

        for attempt in range(MAX_RETRIES):
            try:
                response = self.session.get(
                    GREYNOISE_API_URL.format(ip=ip), 
                    timeout=GREYNOISE_TIMEOUT
                )
                
                if response.status_code == 404:
                    return {
                        "ip": ip, 
                        "noise": False, 
                        "riot": False, 
                        "message": "IP not found in GreyNoise database"
                    }
                elif response.status_code == 429:  # Rate limit
                    log.warning(f"Rate limit alcanzado en GreyNoise. Reintentando en {RETRY_DELAY}s...")
                    time.sleep(RETRY_DELAY * (attempt + 1))
                    continue
                
                response.raise_for_status()
                data = response.json()
                
                # Agregar timestamp para auditor√≠a
                data["queried_at"] = time.time()
                data["queried_ip"] = ip
                
                return data
                
            except requests.exceptions.Timeout:
                log.warning(f"Timeout en consulta GreyNoise para {ip} (intento {attempt + 1}/{MAX_RETRIES})")
            except requests.exceptions.ConnectionError:
                log.warning(f"Error de conexi√≥n a GreyNoise para {ip} (intento {attempt + 1}/{MAX_RETRIES})")
            except requests.exceptions.RequestException as e:
                log.error(f"Error HTTP en GreyNoise para {ip}: {e}")
                break
            except json.JSONDecodeError:
                log.error(f"Respuesta JSON inv√°lida de GreyNoise para {ip}")
                break
            
            if attempt < MAX_RETRIES - 1:
                time.sleep(RETRY_DELAY * (attempt + 1))
        
        log.error(f"Fall√≥ la consulta a GreyNoise para {ip} despu√©s de {MAX_RETRIES} intentos")
        return {}

@lru_cache(maxsize=256)
def resolve_domain_to_ip(domain: str) -> Optional[str]:
    """
    Resuelve un dominio a IP con cache para evitar resoluciones duplicadas.
    
    Args:
        domain: Dominio o IP a resolver
        
    Returns:
        IP como string, o None si no se puede resolver
    """
    try:
        # Verifica si ya es una IP v√°lida
        ipaddress.ip_address(domain)
        return domain
    except ValueError:
        pass
    
    try:
        # Intenta resolver el dominio
        ip = socket.gethostbyname(domain)
        log.info(f"Dominio {domain} resuelto a IP: {ip}")
        return ip
    except socket.gaierror as e:
        log.error(f"No se pudo resolver el dominio {domain} a una IP: {e}")
        return None

def is_private_ip(ip: str) -> bool:
    """Verifica si una IP es privada/interna."""
    try:
        ip_obj = ipaddress.ip_address(ip)
        return ip_obj.is_private or ip_obj.is_loopback or ip_obj.is_link_local
    except ValueError:
        return False

def save_greynoise_results(data: Dict, domain: str, tmp_dir: Path) -> Path:
    """
    Guarda los resultados de GreyNoise en archivo JSON.
    
    Returns:
        Path al archivo JSON creado
    """
    greynoise_file = tmp_dir / "greynoise.json"
    
    try:
        # Asegurar que el directorio existe
        tmp_dir.mkdir(parents=True, exist_ok=True)
        
        with open(greynoise_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        
        log.info(f"Resultados de GreyNoise guardados en {greynoise_file}")
        
    except IOError as e:
        log.error(f"Error al guardar los resultados de GreyNoise en {greynoise_file}: {e}")
        # Crear archivo vac√≠o en caso de error
        with open(greynoise_file, 'w', encoding='utf-8') as f:
            json.dump({}, f)
    
    return greynoise_file

def analyze_greynoise_data(gn_data: Dict, ip: str) -> Tuple[bool, str]:
    """
    Analiza los datos de GreyNoise para determinar si la IP es maliciosa.
    
    Returns:
        Tuple de (es_maliciosa, raz√≥n)
    """
    if not gn_data:
        return False, "Sin datos de GreyNoise"
    
    classification = gn_data.get("classification", "").lower()
    noise = gn_data.get("noise", False)
    riot = gn_data.get("riot", False)
    
    # An√°lisis detallado
    if classification == "malicious":
        return True, f"Clasificada como MALICIOSA por GreyNoise"
    elif classification == "suspicious":
        return True, f"Clasificada como SOSPECHOSA por GreyNoise"
    elif noise and not riot:
        return True, f"IP detectada en actividad de ruido (scanning/attacks)"
    elif riot:
        return False, f"IP en RIOT (tr√°fico benigno com√∫n)"
    
    return False, f"IP limpia seg√∫n GreyNoise"

def check_greynoise(ip: str, api_key: str) -> Dict:
    """Funci√≥n de compatibilidad - mantiene la interfaz original."""
    client = GreyNoiseClient(api_key)
    return client.check_ip(ip)

def is_ip_malicious_greynoise(domain: str, tmp_dir: Path, api_key: str) -> Path:
    """
    Verifica si una IP es clasificada como maliciosa por GreyNoise.
    Versi√≥n mejorada con mejor manejo de errores y an√°lisis.
    
    Returns:
        Path al archivo JSON con los resultados de GreyNoise.
    """
    # Resolver dominio a IP
    ip = resolve_domain_to_ip(domain)
    if not ip:
        log.error(f"No se pudo obtener una IP v√°lida para {domain}")
        # Crear archivo vac√≠o cuando no se puede resolver IP
        return save_greynoise_results({"error": "No se pudo resolver IP"}, domain, tmp_dir)
    
    # Saltar IPs privadas (GreyNoise solo tiene IPs p√∫blicas)
    if is_private_ip(ip):
        log.info(f"Saltando consulta GreyNoise para IP privada: {ip}")
        # Crear archivo con informaci√≥n de IP privada
        return save_greynoise_results({"ip": ip, "private": True, "message": "IP privada - no consultada"}, domain, tmp_dir)
    
    # Consultar GreyNoise
    client = GreyNoiseClient(api_key)
    gn_data = client.check_ip(ip)
    
    # Analizar resultados
    is_malicious, reason = analyze_greynoise_data(gn_data, ip)
    
    # Agregar informaci√≥n de an√°lisis a los datos
    if gn_data:
        gn_data["is_malicious"] = is_malicious
        gn_data["analysis_reason"] = reason
    
    if is_malicious:
        log.warning(f"üö® ¬°Alerta! La IP {ip} ({domain}): {reason}")
        
        # Log adicional con detalles si est√°n disponibles
        if gn_data.get("last_seen"):
            log.info(f"   √öltima actividad vista: {gn_data['last_seen']}")
        if gn_data.get("tags"):
            log.info(f"   Tags: {', '.join(gn_data['tags'])}")
    else:
        log.info(f"‚úÖ IP {ip} ({domain}): {reason}")
    
    # Guardar resultados y retornar el path
    return save_greynoise_results(gn_data, domain, tmp_dir)

# Funci√≥n para limpiar cache si es necesario
def clear_dns_cache():
    """Limpia el cache de resoluci√≥n DNS."""
    resolve_domain_to_ip.cache_clear()
    log.info("Cache de resoluci√≥n DNS limpiado")