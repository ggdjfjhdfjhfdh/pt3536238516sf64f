"""Pipeline principal del escáner de seguridad con notificaciones de progreso."""

from __future__ import annotations
import json, logging, os, shutil, sys, tempfile, datetime as dt
from pathlib import Path
from typing import Dict, Optional, Callable, List

import redis

# --- módulos de tu proyecto -----------------------------------------------
from pentest.config import REDIS_URL, SAFE_DOMAIN
from pentest.exceptions import ScanError
from pentest.recon         import recon
from pentest.fingerprint   import fingerprint
from pentest.nuclei_scan   import nuclei_scan
from pentest.tls_scan      import tls_scan
from pentest.leaks         import check_leaks
from pentest.typosquat     import check_typosquats
from pentest.cve_scan      import cve_scan
from pentest.nmap_scan     import nmap_scan
from pentest.security_config import security_config_scan # Import the new security config scan module
from pentest.report        import build_pdf, send_notification
# ---------------------------------------------------------------------------

log = logging.getLogger("pentest")
logging.basicConfig(
    stream=sys.stdout,
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)

rds: redis.Redis = redis.from_url(REDIS_URL)

# Paso, porcentaje acumulado aproximado y función que lo ejecuta ------------
Step = Dict[str, object]
STEPS: List[Step] = [
    {"key": "recon",   "pct": 10, "runner": recon},
    {"key": "finger",  "pct": 30, "runner": fingerprint},
    {"key": "nuclei",  "pct": 55, "runner": nuclei_scan},
    {"key": "tls",     "pct": 70, "runner": tls_scan},
    {"key": "leaks",   "pct": 85, "runner": check_leaks},
    {"key": "typos",   "pct": 95, "runner": check_typosquats},
    {"key": "cve",     "pct": 97, "runner": cve_scan},
    {"key": "nmap",    "pct": 98, "runner": nmap_scan},
    {"key": "security_config", "pct": 99, "runner": security_config_scan}, # Add security config scan step
]

def _publish(job_id: str, payload: Dict):
    """Envía el progreso por Pub/Sub y lo guarda en Redis hash."""
    try:
        rds.publish(job_id, json.dumps(payload))
        # Guardar progreso en Redis hash
        rds.hset(f"rq:job:{job_id}", "meta", json.dumps({"progress": payload}))
    except Exception:  # conexión Redis caída → no interrumpir el scan
        pass

def _mark(job_id: str, step_key: str, pct: int, extra: Dict | None = None):
    data = {"state": "working", "step": step_key, "pct": pct}
    if extra:
        data.update(extra)
    _publish(job_id, data)

# ---------------------------------------------------------------------------
def generate_pdf(domain: str,
                 recipient_email: str,
                 job_id: str | None = None,
                 *,
                 hibp_api_key: str | None = None,
                 debug: bool = False) -> Dict:
    """
    Ejecuta el pipeline completo y devuelve dict con estado final.
    """
    if not SAFE_DOMAIN.match(domain):
        raise ScanError(f"Dominio inválido: {domain}")

    if not job_id:
        job_id = f"standalone:{dt.datetime.utcnow().isoformat()}"

    tmp_dir = Path(tempfile.mkdtemp(prefix=f"scan_{domain}_"))
    log.info("➜ [%s] TMP %s", domain, tmp_dir)

    files: Dict[str, Path] = {}

    try:
        # -------- pipeline dinámico -------------------------------------------------
        for step in STEPS:
            key, pct, fn = step["key"], step["pct"], step["runner"]

            _mark(job_id, key, pct)
            log.info("→ [%s] Fase %s (%s %%)", domain, key, pct)

            match key:
                case "recon":
                    log.info("Iniciando fase de reconocimiento (recon)")
                    try:
                        files["subdomains"] = fn(domain, tmp_dir)
                        log.info("Fase de reconocimiento (recon) completada.")
                    except Exception as e:
                        log.error("Error en la fase de reconocimiento (recon): %s", e)
                        raise ScanError(f"Error en recon: {e}") from e

                case "finger":
                    log.info("Iniciando fase de fingerprinting (finger)")
                    try:
                        files["httpx"] = fn(files["subdomains"], tmp_dir)
                        log.info("Fase de fingerprinting (finger) completada.")
                    except Exception as e:
                        log.error("Error en la fase de fingerprinting (finger): %s", e)
                        raise ScanError(f"Error en finger: {e}") from e

                case "nuclei":
                    log.info("Iniciando fase de escaneo de vulnerabilidades (nuclei)")
                    try:
                        files["nuclei"] = fn(files["httpx"], tmp_dir)
                        log.info("Fase de escaneo de vulnerabilidades (nuclei) completada.")
                    except Exception as e:
                        log.error("Error en la fase de escaneo de vulnerabilidades (nuclei): %s", e)
                        raise ScanError(f"Error en nuclei: {e}") from e

                case "tls":
                    log.info("Iniciando fase de escaneo TLS (tls)")
                    try:
                        files["tls"] = fn(files["httpx"], tmp_dir)
                        log.info("Fase de escaneo TLS (tls) completada.")
                    except Exception as e:
                        log.error("Error en la fase de escaneo TLS (tls): %s", e)
                        raise ScanError(f"Error en tls: {e}") from e

                case "leaks":
                    log.info("Iniciando fase de búsqueda de filtraciones (leaks)")
                    try:
                        files["leaks"] = fn(domain, tmp_dir, hibp_api_key)
                        log.info("Fase de búsqueda de filtraciones (leaks) completada.")
                    except Exception as e:
                        log.warning("Advertencia en la fase de búsqueda de filtraciones (leaks): %s", e)
                        # No se lanza ScanError si la API key no está configurada, solo se registra la advertencia
                        if "No se ha proporcionado clave API para Have I Been Pwned" not in str(e):
                            raise ScanError(f"Error en leaks: {e}") from e

                case "typos":
                    log.info("Iniciando fase de typosquatting (typos)")
                    try:
                        files["typosquats"] = fn(domain, tmp_dir)
                        log.info("Fase de typosquatting (typos) completada.")
                    except Exception as e:
                        log.error("Error en la fase de typosquatting (typos): %s", e)
                        raise ScanError(f"Error en typos: {e}") from e

                case "cve":
                    log.info("Iniciando fase de escaneo CVE (cve)")
                    try:
                        files["cves"] = fn(files["httpx"], tmp_dir)
                        log.info("Fase de escaneo CVE (cve) completada.")
                    except Exception as e:
                        log.error("Error en la fase de escaneo CVE (cve): %s", e)
                        raise ScanError(f"Error en cve: {e}") from e

                case "nmap":
                    log.info("Iniciando fase de escaneo Nmap (nmap)")
                    try:
                        files["nmap"] = fn(files["httpx"], tmp_dir)
                        log.info("Fase de escaneo Nmap (nmap) completada.")
                    except Exception as e:
                        log.error("Error en la fase de escaneo Nmap (nmap): %s", e)
                        raise ScanError(f"Error en nmap: {e}") from e

                case "security_config":
                    log.info("Iniciando fase de configuración de seguridad (security_config)")
                    try:
                        files["security_config"] = fn(files["httpx"], tmp_dir)
                        log.info("Fase de configuración de seguridad (security_config) completada.")
                    except Exception as e:
                        log.error("Error en la fase de configuración de seguridad (security_config): %s", e)
                        raise ScanError(f"Error en security_config: {e}") from e

        # -------- PDF ---------------------------------------------------------------
        pdf_path = build_pdf(domain, tmp_dir,
                             httpx_file=files["httpx"],
                             nuclei_file=files["nuclei"],
                             tls_file=files["tls"],
                             leaks_file=files["leaks"],
                             typosquats_file=files["typosquats"],
                             cves_file=files["cves"],
                             nmap_file=files["nmap"],
                             security_config_file=files["security_config"] # Pass security config file
                         )
        # Notificación email (Best-Effort)
        subc = _safe_count_json(files.get("httpx"))
        vulc = _safe_count_json(files.get("nuclei"))
        send_notification(job_id, "PDF generado", "success", pdf_path, recipient_email, subc, vulc)

        final = Path(f"report_{domain}_{dt.datetime.utcnow():%Y%m%d%H%M}.pdf")
        shutil.copy(pdf_path, final)

        result = {"state": "finished", "report_path": str(final)}
        _publish(job_id, result)
        log.info("✅ [%s] Escaneo finalizado", domain)
        return result

    except Exception as e:
        log.exception("❌ [%s] Error en el escaneo", domain)
        err = {"state": "failed", "error": str(e)}
        _publish(job_id, err)
        raise

    finally:
        if not debug:
            shutil.rmtree(tmp_dir, ignore_errors=True)

# ---------------------------------------------------------------------------
def _safe_count_json(path: Path | None) -> int:
    if not path or not path.exists(): return 0
    try:
        with open(path, "r") as f:
            return len(json.load(f))
    except Exception:
        return 0
# ---------------------------------------------------------------------------
#  MODO WORKER "BÁSICO" (sigue utilizando tu cola BLPOP)
# ---------------------------------------------------------------------------
def start_worker():
    log.info("⌛ Worker BLPOP escuchando en redis queue 'scan_queue'")
    while True:
        log.info("Esperando mensajes en la cola 'scan_queue'...")
        _, raw = rds.blpop("scan_queue")
        log.info(f"Mensaje recibido: {raw}")
        try:
            req = json.loads(raw)
            log.info(f"Mensaje parseado: {req}")
            job_id = f"job:{dt.datetime.utcnow().isoformat()}"
            _publish(job_id, {"state": "queued"})
            log.info(f"Iniciando generate_pdf para dominio: {req['domain']} con job_id: {job_id}")
            generate_pdf(req["domain"], req["email"], job_id)
            log.info(f"generate_pdf completado para job_id: {job_id}")
        except Exception as e:
            log.error("Error procesando job %s – %s", raw, e)

if __name__ == "__main__":
    start_worker()