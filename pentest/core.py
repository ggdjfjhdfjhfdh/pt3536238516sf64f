"""Punto de entrada principal para el escáner de seguridad."""

import json
import logging
import os
import re
import shutil
import sys
import tempfile
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from typing import Dict, List, Any, Optional, Union

import redis

from pentest.config import REDIS_URL, SAFE_DOMAIN
from pentest.exceptions import ScanError
from pentest.runners import thread_pool
from pentest.recon import recon
from pentest.fingerprint import fingerprint
from pentest.nuclei_scan import nuclei_scan
from pentest.tls_scan import tls_scan
from pentest.leaks import check_leaks
from pentest.typosquat import check_typosquats
from pentest.report import build_pdf, send_notification

# Configuración de logging
logging.basicConfig(
    stream=sys.stdout,
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
log = logging.getLogger(__name__)

def generate_pdf(
    domain: str, 
    recipient_email: str, 
    *, 
    debug: bool = False,
    hibp_api_key: Optional[str] = None
) -> str:
    """Ejecuta el pipeline completo de escaneo y genera un informe PDF.
    
    Args:
        domain: Dominio objetivo
        recipient_email: Email para enviar el informe
        debug: Si es True, no elimina el directorio temporal
        hibp_api_key: Clave API para Have I Been Pwned (opcional)
        
    Returns:
        Ruta al archivo PDF generado
        
    Raises:
        ScanError: Si falla alguna fase del escaneo
    """
    # Validar dominio
    if not SAFE_DOMAIN.match(domain):
        raise ScanError(f"Dominio inválido: {domain}")
    
    # Crear directorio temporal
    tmp_dir = Path(tempfile.mkdtemp(prefix=f"scan_{domain}_"))
    log.info("Directorio temporal: %s", tmp_dir)
    
    try:
        # Fase 1: Reconocimiento de subdominios
        subdomains_file = recon(domain, tmp_dir)
        
        # Fase 2: Fingerprinting de hosts activos
        httpx_file = fingerprint(subdomains_file, tmp_dir)
        
        # Fase 3: Escaneo de vulnerabilidades
        nuclei_file = nuclei_scan(httpx_file, tmp_dir)
        
        # Fase 4: Análisis TLS
        tls_file = tls_scan(httpx_file, tmp_dir)
        
        # Fase 5: Búsqueda de credenciales filtradas
        leaks_file = check_leaks(domain, tmp_dir, hibp_api_key)
        
        # Fase 6: Detección de typosquatting
        typosquats_file = check_typosquats(domain, tmp_dir)
        
        # Fase 7: Generación del informe
        pdf_file = build_pdf(
            domain,
            tmp_dir,
            httpx_file,
            nuclei_file,
            tls_file,
            leaks_file,
            typosquats_file
        )
        
        # Fase 8: Envío de notificación
        # Contar subdominios
        with open(httpx_file, "r") as f:
            subdomains_count = len(json.load(f))
        
        # Contar vulnerabilidades
        with open(nuclei_file, "r") as f:
            vulnerabilities_count = len(json.load(f))
        
        # Enviar notificación
        send_notification(
            domain,
            pdf_file,
            recipient_email,
            subdomains_count,
            vulnerabilities_count
        )
        
        # Copiar el PDF a una ubicación permanente
        final_pdf = f"report_{domain}.pdf"
        shutil.copy(pdf_file, final_pdf)
        
        log.info("✅ Escaneo completado para %s", domain)
        return final_pdf
    
    except Exception as e:
        if isinstance(e, ScanError):
            log.error("Error durante el escaneo: %s", str(e))
        else:
            log.exception("Error inesperado durante el escaneo")
        raise
    
    finally:
        # Limpiar directorio temporal solo si no estamos en modo debug
        if not debug:
            shutil.rmtree(tmp_dir, ignore_errors=True)

def start_worker():
    """Inicia un worker para procesar solicitudes de escaneo desde Redis."""
    log.info("Iniciando worker para procesar solicitudes de escaneo")
    
    # Conectar a Redis
    try:
        r = redis.from_url(REDIS_URL)
        log.info("Conectado a Redis: %s", REDIS_URL)
    except Exception as e:
        log.error("Error al conectar a Redis: %s", str(e))
        return
    
    # Bucle principal
    while True:
        try:
            # Esperar por una solicitud
            _, data = r.blpop("scan_queue")
            request = json.loads(data)
            
            domain = request.get("domain")
            email = request.get("email")
            
            if not domain or not email:
                log.error("Solicitud inválida: %s", data)
                continue
            
            log.info("Procesando solicitud para %s", domain)
            
            # Ejecutar escaneo
            try:
                pdf_path = generate_pdf(domain, email)
                log.info("Escaneo completado para %s: %s", domain, pdf_path)
                
                # Actualizar estado en Redis
                r.hset("scan_status", domain, json.dumps({
                    "status": "completed",
                    "pdf": pdf_path
                }))
            except Exception as e:
                log.error("Error al procesar %s: %s", domain, str(e))
                
                # Actualizar estado en Redis
                r.hset("scan_status", domain, json.dumps({
                    "status": "error",
                    "message": str(e)
                }))
        
        except Exception as e:
            log.exception("Error en el bucle principal: %s", str(e))

if __name__ == "__main__":
    start_worker()