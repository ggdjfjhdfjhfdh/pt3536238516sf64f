import os
import logging
import requests
import time
import hashlib
from typing import List, Dict, Any, Optional, Tuple
from functools import lru_cache
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse
import ipaddress
import json
from pathlib import Path

log = logging.getLogger(__name__)

# Configuración de APIs
OTX_API_KEY = os.getenv("OTX_API_KEY")
ABUSEIPDB_API_KEY = os.getenv("ABUSEIPDB_API_KEY")
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY")

# Configuración de rendimiento
MAX_WORKERS = 5
REQUEST_TIMEOUT = 10
RETRY_ATTEMPTS = 3
RETRY_DELAY = 1
CACHE_SIZE = 256
RATE_LIMIT_DELAY = 0.2  # Delay entre requests para evitar rate limiting

# ---------------------------------------------------------------------------
# Funciones auxiliares
# ---------------------------------------------------------------------------

def _make_request_with_retry(url: str, headers: Dict[str, str] = None, params: Dict[str, Any] = None) -> Optional[Dict[str, Any]]:
    """Realiza una petición HTTP con reintentos y rate limiting."""
    for attempt in range(RETRY_ATTEMPTS):
        try:
            time.sleep(RATE_LIMIT_DELAY)  # Rate limiting
            response = requests.get(url, headers=headers, params=params, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            if attempt == RETRY_ATTEMPTS - 1:
                log.error(f"Error en petición después de {RETRY_ATTEMPTS} intentos: {e}")
                return None
            time.sleep(RETRY_DELAY * (attempt + 1))  # Backoff exponencial
    return None

def _is_valid_ip(ip: str) -> bool:
    """Valida si una cadena es una dirección IP válida."""
    try:
        ipaddress.ip_address(ip)
        return True
    except ValueError:
        return False

def _is_valid_domain(domain: str) -> bool:
    """Valida si una cadena es un dominio válido."""
    if not domain or len(domain) > 253:
        return False
    # Validación básica de dominio
    import re
    pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
    return bool(re.match(pattern, domain))

@lru_cache(maxsize=CACHE_SIZE)
def _cached_threat_check(indicator: str, source: str) -> str:
    """Cache para evitar consultas duplicadas."""
    return f"{indicator}:{source}:{int(time.time() // 3600)}"  # Cache por hora

# ---------------------------------------------------------------------------
# Funciones de threat intelligence mejoradas
# ---------------------------------------------------------------------------

def get_otx_pulses_by_indicator(indicator_type: str, indicator_value: str) -> List[Dict[str, Any]]:
    """Obtiene pulsos de AlienVault OTX para un indicador dado.

    Args:
        indicator_type: Tipo de indicador (ej. "IPv4", "domain").
        indicator_value: Valor del indicador.

    Returns:
        Lista de pulsos de OTX con metadatos adicionales.
    """
    if not OTX_API_KEY:
        log.warning("OTX_API_KEY no configurada. Se omitirá la comprobación de OTX.")
        return []
    
    # Validar entrada
    if indicator_type == "IPv4" and not _is_valid_ip(indicator_value):
        log.warning(f"IP inválida para OTX: {indicator_value}")
        return []
    elif indicator_type == "domain" and not _is_valid_domain(indicator_value):
        log.warning(f"Dominio inválido para OTX: {indicator_value}")
        return []
    
    # Verificar cache
    cache_key = _cached_threat_check(indicator_value, "otx")
    
    url = f"https://otx.alienvault.com/api/v1/indicators/{indicator_type}/{indicator_value}/pulses"
    headers = {"X-OTX-API-KEY": OTX_API_KEY}
    
    response_data = _make_request_with_retry(url, headers)
    if response_data:
        pulses = response_data.get("results", [])
        # Enriquecer con metadatos
        for pulse in pulses:
            pulse["source"] = "AlienVault OTX"
            pulse["indicator_type"] = indicator_type
            pulse["indicator_value"] = indicator_value
            pulse["timestamp"] = time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        return pulses
    
    return []

def get_abuseipdb_score(ip: str) -> Dict[str, Any]:
    """Obtiene información detallada de AbuseIPDB para una IP.

    Args:
        ip: Dirección IP a consultar.

    Returns:
        Diccionario con información de AbuseIPDB o datos vacíos si hay error.
    """
    if not ABUSEIPDB_API_KEY:
        log.warning("ABUSEIPDB_API_KEY no configurada. Se omitirá la comprobación de AbuseIPDB.")
        return {"score": 0, "is_public": False, "usage_type": "unknown"}
    
    # Validar IP
    if not _is_valid_ip(ip):
        log.warning(f"IP inválida para AbuseIPDB: {ip}")
        return {"score": 0, "is_public": False, "usage_type": "invalid"}
    
    # Verificar cache
    cache_key = _cached_threat_check(ip, "abuseipdb")
    
    url = "https://api.abuseipdb.com/api/v2/check"
    headers = {
        "Key": ABUSEIPDB_API_KEY,
        "Accept": "application/json"
    }
    params = {
        "ipAddress": ip,
        "maxAgeInDays": 90,
        "verbose": True
    }
    
    response_data = _make_request_with_retry(url, headers, params)
    if response_data:
        data = response_data.get("data", {})
        return {
            "score": data.get("abuseConfidenceScore", 0),
            "is_public": data.get("isPublic", False),
            "usage_type": data.get("usageType", "unknown"),
            "country_code": data.get("countryCode", "unknown"),
            "isp": data.get("isp", "unknown"),
            "domain": data.get("domain", "unknown"),
            "total_reports": data.get("totalReports", 0),
            "num_distinct_users": data.get("numDistinctUsers", 0),
            "last_reported_at": data.get("lastReportedAt"),
            "source": "AbuseIPDB",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        }
    
    return {"score": 0, "is_public": False, "usage_type": "error"}

def get_virustotal_ip_report(ip: str) -> Dict[str, Any]:
    """Obtiene el reporte de VirusTotal para una IP.
    
    Args:
        ip: Dirección IP a consultar.
        
    Returns:
        Diccionario con información de VirusTotal.
    """
    if not VIRUSTOTAL_API_KEY:
        log.warning("VIRUSTOTAL_API_KEY no configurada. Se omitirá la comprobación de VirusTotal.")
        return {"malicious": 0, "suspicious": 0, "harmless": 0, "undetected": 0}
    
    if not _is_valid_ip(ip):
        log.warning(f"IP inválida para VirusTotal: {ip}")
        return {"malicious": 0, "suspicious": 0, "harmless": 0, "undetected": 0}
    
    url = f"https://www.virustotal.com/vtapi/v2/ip-address/report"
    params = {
        "apikey": VIRUSTOTAL_API_KEY,
        "ip": ip
    }
    
    response_data = _make_request_with_retry(url, params=params)
    if response_data:
        detected_urls = response_data.get("detected_urls", [])
        detected_samples = response_data.get("detected_samples", [])
        
        return {
            "detected_urls_count": len(detected_urls),
            "detected_samples_count": len(detected_samples),
            "country": response_data.get("country", "unknown"),
            "as_owner": response_data.get("as_owner", "unknown"),
            "asn": response_data.get("asn", "unknown"),
            "source": "VirusTotal",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        }
    
    return {"detected_urls_count": 0, "detected_samples_count": 0}





def check_threat_feeds(ip: str) -> List[str]:
    """Comprueba fuentes de inteligencia de amenazas (OTX, AbuseIPDB) para una IP.
    
    NOTA: Esta función mantiene compatibilidad con el código existente.
    Para análisis más detallado, usar comprehensive_threat_analysis.

    Args:
        ip: Dirección IP a comprobar.

    Returns:
        Lista de fuentes donde se encontró la IP.
    """
    hits = []
    
    # OTX check
    otx_pulses = get_otx_pulses_by_indicator("IPv4", ip)
    if otx_pulses:
        hits.append("OTX")
    
    # AbuseIPDB check
    abuseipdb_data = get_abuseipdb_score(ip)
    if abuseipdb_data.get("score", 0) > 50:
        hits.append("AbuseIPDB")
    
    # VirusTotal check
    vt_data = get_virustotal_ip_report(ip)
    if vt_data.get("detected_urls_count", 0) > 0 or vt_data.get("detected_samples_count", 0) > 0:
        hits.append("VirusTotal")
    

    
    return hits

def comprehensive_threat_analysis(ip: str) -> Dict[str, Any]:
    """Realiza un análisis completo de threat intelligence para una IP.
    
    Args:
        ip: Dirección IP a analizar.
        
    Returns:
        Diccionario con análisis completo de todas las fuentes.
    """
    if not _is_valid_ip(ip):
        return {
            "error": "IP inválida",
            "ip": ip,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        }
    
    log.info(f"🔍 [THREAT_INTEL] Iniciando análisis completo para IP: {ip}")
    
    # Ejecutar todas las consultas en paralelo
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            "otx": executor.submit(get_otx_pulses_by_indicator, "IPv4", ip),
            "abuseipdb": executor.submit(get_abuseipdb_score, ip),
            "virustotal": executor.submit(get_virustotal_ip_report, ip)
        }
        
        results = {}
        for source, future in futures.items():
            try:
                results[source] = future.result(timeout=30)
            except Exception as e:
                log.error(f"Error en consulta {source} para {ip}: {e}")
                results[source] = {"error": str(e)}
    
    # Calcular score de riesgo agregado
    risk_score = _calculate_risk_score(results)
    
    # Generar resumen
    summary = _generate_threat_summary(results, risk_score)
    
    return {
        "ip": ip,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
        "risk_score": risk_score,
        "risk_level": _get_risk_level(risk_score),
        "summary": summary,
        "sources": results,
        "recommendations": _get_threat_recommendations(results, risk_score)
    }

def comprehensive_domain_analysis(domain: str) -> Dict[str, Any]:
    """Realiza un análisis completo de threat intelligence para un dominio.
    
    Args:
        domain: Dominio a analizar.
        
    Returns:
        Diccionario con análisis completo de todas las fuentes.
    """
    if not _is_valid_domain(domain):
        return {
            "error": "Dominio inválido",
            "domain": domain,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime())
        }
    
    log.info(f"🔍 [THREAT_INTEL] Iniciando análisis completo para dominio: {domain}")
    
    # Ejecutar consultas en paralelo
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            "otx": executor.submit(get_otx_pulses_by_indicator, "domain", domain)
        }
        
        results = {}
        for source, future in futures.items():
            try:
                results[source] = future.result(timeout=30)
            except Exception as e:
                log.error(f"Error en consulta {source} para {domain}: {e}")
                results[source] = {"error": str(e)}
    
    # Calcular score de riesgo para dominio
    risk_score = _calculate_domain_risk_score(results)
    
    return {
        "domain": domain,
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
        "risk_score": risk_score,
        "risk_level": _get_risk_level(risk_score),
        "sources": results,
        "recommendations": _get_domain_recommendations(results, risk_score)
    }

def _calculate_risk_score(results: Dict[str, Any]) -> int:
    """Calcula un score de riesgo basado en los resultados de threat intelligence."""
    score = 0
    
    # AbuseIPDB (0-40 puntos)
    abuseipdb = results.get("abuseipdb", {})
    if isinstance(abuseipdb, dict):
        abuse_score = abuseipdb.get("score", 0)
        score += min(40, int(abuse_score * 0.4))
    
    # OTX (0-30 puntos)
    otx = results.get("otx", [])
    if isinstance(otx, list) and otx:
        score += min(30, len(otx) * 10)
    
    # VirusTotal (0-20 puntos)
    vt = results.get("virustotal", {})
    if isinstance(vt, dict):
        detected_urls = vt.get("detected_urls_count", 0)
        detected_samples = vt.get("detected_samples_count", 0)
        score += min(20, (detected_urls + detected_samples) * 2)
    

    
    return min(100, score)

def _calculate_domain_risk_score(results: Dict[str, Any]) -> int:
    """Calcula un score de riesgo para dominios."""
    score = 0
    
    # OTX (0-100 puntos)
    otx = results.get("otx", [])
    if isinstance(otx, list) and otx:
        score += min(100, len(otx) * 30)
    
    return min(100, score)

def _get_risk_level(score: int) -> str:
    """Convierte el score numérico a nivel de riesgo."""
    if score >= 80:
        return "CRÍTICO"
    elif score >= 60:
        return "ALTO"
    elif score >= 40:
        return "MEDIO"
    elif score >= 20:
        return "BAJO"
    else:
        return "MÍNIMO"

def _generate_threat_summary(results: Dict[str, Any], risk_score: int) -> str:
    """Genera un resumen textual del análisis de amenazas."""
    summary_parts = []
    
    abuseipdb = results.get("abuseipdb", {})
    if isinstance(abuseipdb, dict) and abuseipdb.get("score", 0) > 0:
        summary_parts.append(f"AbuseIPDB score: {abuseipdb.get('score', 0)}%")
    
    otx = results.get("otx", [])
    if isinstance(otx, list) and otx:
        summary_parts.append(f"OTX pulses: {len(otx)}")
    
    vt = results.get("virustotal", {})
    if isinstance(vt, dict):
        urls = vt.get("detected_urls_count", 0)
        samples = vt.get("detected_samples_count", 0)
        if urls > 0 or samples > 0:
            summary_parts.append(f"VirusTotal detecciones: {urls} URLs, {samples} muestras")
    

    
    if not summary_parts:
        return "No se encontraron indicadores de amenaza"
    
    return "; ".join(summary_parts)

def _get_threat_recommendations(results: Dict[str, Any], risk_score: int) -> List[str]:
    """Genera recomendaciones basadas en el análisis de amenazas."""
    recommendations = []
    
    if risk_score >= 80:
        recommendations.append("🚨 CRÍTICO: Bloquear inmediatamente esta IP")
        recommendations.append("🔍 Investigar posible compromiso de sistemas")
    elif risk_score >= 60:
        recommendations.append("⚠️ ALTO: Monitorear tráfico desde esta IP")
        recommendations.append("🛡️ Implementar controles de acceso adicionales")
    elif risk_score >= 40:
        recommendations.append("📊 MEDIO: Revisar logs de acceso")
        recommendations.append("🔍 Monitoreo continuo recomendado")
    elif risk_score >= 20:
        recommendations.append("📋 BAJO: Mantener en lista de observación")
    else:
        recommendations.append("✅ MÍNIMO: No se requieren acciones inmediatas")
    
    # Recomendaciones específicas por fuente
    abuseipdb = results.get("abuseipdb", {})
    if isinstance(abuseipdb, dict) and abuseipdb.get("score", 0) > 75:
        recommendations.append("🚫 IP reportada frecuentemente por abuso")
    

    
    return recommendations

def bulk_threat_analysis(targets: List[str], target_type: str = "auto") -> Dict[str, Any]:
    """Realiza análisis de threat intelligence en lote para múltiples objetivos.
    
    Args:
        targets: Lista de IPs o dominios a analizar.
        target_type: Tipo de objetivo ('ip', 'domain', 'auto').
        
    Returns:
        Diccionario con resultados del análisis en lote.
    """
    if not targets:
        return {"error": "No se proporcionaron objetivos"}
    
    log.info(f"🔍 [THREAT_INTEL] Iniciando análisis en lote para {len(targets)} objetivos")
    
    results = {
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
        "total_targets": len(targets),
        "completed": 0,
        "failed": 0,
        "results": {},
        "summary": {
            "high_risk": [],
            "medium_risk": [],
            "low_risk": [],
            "clean": []
        }
    }
    
    # Procesar en lotes para evitar sobrecarga
    batch_size = min(10, MAX_WORKERS)
    
    for i in range(0, len(targets), batch_size):
        batch = targets[i:i + batch_size]
        
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = {}
            
            for target in batch:
                # Determinar tipo automáticamente si es necesario
                if target_type == "auto":
                    if _is_valid_ip(target):
                        futures[target] = executor.submit(comprehensive_threat_analysis, target)
                    elif _is_valid_domain(target):
                        futures[target] = executor.submit(comprehensive_domain_analysis, target)
                    else:
                        log.warning(f"Objetivo inválido: {target}")
                        results["failed"] += 1
                        continue
                elif target_type == "ip":
                    futures[target] = executor.submit(comprehensive_threat_analysis, target)
                elif target_type == "domain":
                    futures[target] = executor.submit(comprehensive_domain_analysis, target)
            
            # Recopilar resultados
            for target, future in futures.items():
                try:
                    result = future.result(timeout=60)
                    results["results"][target] = result
                    results["completed"] += 1
                    
                    # Categorizar por nivel de riesgo
                    risk_score = result.get("risk_score", 0)
                    if risk_score >= 60:
                        results["summary"]["high_risk"].append(target)
                    elif risk_score >= 40:
                        results["summary"]["medium_risk"].append(target)
                    elif risk_score >= 20:
                        results["summary"]["low_risk"].append(target)
                    else:
                        results["summary"]["clean"].append(target)
                        
                except Exception as e:
                    log.error(f"Error analizando {target}: {e}")
                    results["results"][target] = {"error": str(e)}
                    results["failed"] += 1
        
        # Rate limiting entre lotes
        if i + batch_size < len(targets):
            time.sleep(RATE_LIMIT_DELAY)
    
    # Generar estadísticas finales
    results["statistics"] = {
        "success_rate": (results["completed"] / results["total_targets"]) * 100,
        "high_risk_count": len(results["summary"]["high_risk"]),
        "medium_risk_count": len(results["summary"]["medium_risk"]),
        "low_risk_count": len(results["summary"]["low_risk"]),
        "clean_count": len(results["summary"]["clean"])
    }
    
    log.info(f"✅ [THREAT_INTEL] Análisis en lote completado: {results['completed']}/{results['total_targets']} exitosos")
    
    return results

def export_threat_data(data: Dict[str, Any], format_type: str = "json", output_file: Optional[str] = None) -> str:
    """Exporta datos de threat intelligence en diferentes formatos.
    
    Args:
        data: Datos de threat intelligence a exportar.
        format_type: Formato de exportación ('json', 'csv', 'txt').
        output_file: Archivo de salida (opcional).
        
    Returns:
        Ruta del archivo generado o contenido como string.
    """
    timestamp = time.strftime("%Y%m%d_%H%M%S", time.gmtime())
    
    if format_type == "json":
        content = json.dumps(data, indent=2, ensure_ascii=False)
        if output_file:
            file_path = output_file
        else:
            file_path = f"threat_intel_{timestamp}.json"
            
    elif format_type == "csv":
        content = _convert_to_csv(data)
        if output_file:
            file_path = output_file
        else:
            file_path = f"threat_intel_{timestamp}.csv"
            
    elif format_type == "txt":
        content = _convert_to_text_report(data)
        if output_file:
            file_path = output_file
        else:
            file_path = f"threat_intel_{timestamp}.txt"
    else:
        raise ValueError(f"Formato no soportado: {format_type}")
    
    if output_file or format_type != "json":
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            log.info(f"📄 [THREAT_INTEL] Datos exportados a: {file_path}")
            return file_path
        except Exception as e:
            log.error(f"Error exportando datos: {e}")
            return content
    
    return content

def _convert_to_csv(data: Dict[str, Any]) -> str:
    """Convierte datos de threat intelligence a formato CSV."""
    lines = []
    lines.append("Target,Type,Risk_Score,Risk_Level,Summary,Recommendations")
    
    if "results" in data:
        # Datos de análisis en lote
        for target, result in data["results"].items():
            if "error" in result:
                lines.append(f"{target},ERROR,0,ERROR,{result['error']},")
            else:
                target_type = "IP" if "ip" in result else "Domain"
                risk_score = result.get("risk_score", 0)
                risk_level = result.get("risk_level", "UNKNOWN")
                summary = result.get("summary", "").replace(",", ";")
                recommendations = "; ".join(result.get("recommendations", [])).replace(",", ";")
                lines.append(f"{target},{target_type},{risk_score},{risk_level},{summary},{recommendations}")
    else:
        # Datos de análisis individual
        target = data.get("ip", data.get("domain", "Unknown"))
        target_type = "IP" if "ip" in data else "Domain"
        risk_score = data.get("risk_score", 0)
        risk_level = data.get("risk_level", "UNKNOWN")
        summary = data.get("summary", "").replace(",", ";")
        recommendations = "; ".join(data.get("recommendations", [])).replace(",", ";")
        lines.append(f"{target},{target_type},{risk_score},{risk_level},{summary},{recommendations}")
    
    return "\n".join(lines)

def _convert_to_text_report(data: Dict[str, Any]) -> str:
    """Convierte datos de threat intelligence a reporte de texto."""
    lines = []
    lines.append("=" * 80)
    lines.append("REPORTE DE INTELIGENCIA DE AMENAZAS")
    lines.append("=" * 80)
    lines.append(f"Generado: {data.get('timestamp', 'N/A')}")
    lines.append("")
    
    if "results" in data:
        # Reporte de análisis en lote
        lines.append(f"RESUMEN EJECUTIVO:")
        lines.append(f"- Total de objetivos analizados: {data.get('total_targets', 0)}")
        lines.append(f"- Análisis completados: {data.get('completed', 0)}")
        lines.append(f"- Análisis fallidos: {data.get('failed', 0)}")
        
        stats = data.get("statistics", {})
        lines.append(f"- Tasa de éxito: {stats.get('success_rate', 0):.1f}%")
        lines.append("")
        
        lines.append("DISTRIBUCIÓN DE RIESGO:")
        lines.append(f"- Alto riesgo: {stats.get('high_risk_count', 0)}")
        lines.append(f"- Riesgo medio: {stats.get('medium_risk_count', 0)}")
        lines.append(f"- Bajo riesgo: {stats.get('low_risk_count', 0)}")
        lines.append(f"- Sin riesgo: {stats.get('clean_count', 0)}")
        lines.append("")
        
        # Detalles por objetivo
        lines.append("DETALLES POR OBJETIVO:")
        lines.append("-" * 40)
        
        for target, result in data["results"].items():
            lines.append(f"\nObjetivo: {target}")
            if "error" in result:
                lines.append(f"  Estado: ERROR - {result['error']}")
            else:
                lines.append(f"  Puntuación de riesgo: {result.get('risk_score', 0)}/100")
                lines.append(f"  Nivel de riesgo: {result.get('risk_level', 'UNKNOWN')}")
                lines.append(f"  Resumen: {result.get('summary', 'N/A')}")
                
                recommendations = result.get("recommendations", [])
                if recommendations:
                    lines.append("  Recomendaciones:")
                    for rec in recommendations:
                        lines.append(f"    - {rec}")
    else:
        # Reporte de análisis individual
        target = data.get("ip", data.get("domain", "Unknown"))
        lines.append(f"OBJETIVO: {target}")
        lines.append(f"Puntuación de riesgo: {data.get('risk_score', 0)}/100")
        lines.append(f"Nivel de riesgo: {data.get('risk_level', 'UNKNOWN')}")
        lines.append(f"Resumen: {data.get('summary', 'N/A')}")
        lines.append("")
        
        recommendations = data.get("recommendations", [])
        if recommendations:
            lines.append("RECOMENDACIONES:")
            for rec in recommendations:
                lines.append(f"- {rec}")
            lines.append("")
        
        # Detalles por fuente
        sources = data.get("sources", {})
        if sources:
            lines.append("DETALLES POR FUENTE:")
            lines.append("-" * 30)
            
            for source, source_data in sources.items():
                lines.append(f"\n{source.upper()}:")
                if isinstance(source_data, dict):
                    if "error" in source_data:
                        lines.append(f"  Error: {source_data['error']}")
                    else:
                        for key, value in source_data.items():
                            if key not in ["timestamp", "source"]:
                                lines.append(f"  {key}: {value}")
                elif isinstance(source_data, list):
                    lines.append(f"  Elementos encontrados: {len(source_data)}")
    
    lines.append("")
    lines.append("=" * 80)
    
    return "\n".join(lines)

def get_threat_intel_summary() -> Dict[str, Any]:
    """Obtiene un resumen del estado del módulo de threat intelligence.
    
    Returns:
        Diccionario con información del estado del módulo.
    """
    # Verificar configuración de APIs
    api_status = {
        "otx": bool(OTX_API_KEY),
        "abuseipdb": bool(ABUSEIPDB_API_KEY),
        "virustotal": bool(VIRUSTOTAL_API_KEY)
    }
    
    configured_apis = sum(api_status.values())
    total_apis = len(api_status)
    
    return {
        "module_version": "2.0",
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
        "api_status": api_status,
        "configured_apis": configured_apis,
        "total_apis": total_apis,
        "configuration_completeness": (configured_apis / total_apis) * 100,
        "available_functions": [
            "check_threat_feeds",
            "comprehensive_threat_analysis", 
            "comprehensive_domain_analysis",
            "bulk_threat_analysis",
            "export_threat_data"
        ],
        "supported_formats": ["json", "csv", "txt"],
        "performance_settings": {
            "max_workers": MAX_WORKERS,
            "request_timeout": REQUEST_TIMEOUT,
            "retry_attempts": RETRY_ATTEMPTS,
            "cache_size": CACHE_SIZE
        }
    }

def _get_domain_recommendations(results: Dict[str, Any], risk_score: int) -> List[str]:
    """Genera recomendaciones para dominios."""
    recommendations = []
    
    if risk_score >= 60:
        recommendations.append("🚨 Dominio potencialmente malicioso")
        recommendations.append("🚫 Considerar bloqueo en firewall/proxy")
    elif risk_score >= 40:
        recommendations.append("⚠️ Dominio sospechoso - monitorear accesos")
    else:
        recommendations.append("✅ Dominio sin indicadores de amenaza")
    
    return recommendations