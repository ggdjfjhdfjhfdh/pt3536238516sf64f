import requests
import json
import logging
import random
import time
from datetime import datetime
from pathlib import Path

from pentest.config import WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS

log = logging.getLogger("pentest")

CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"

def download_cisa_kev_list():
    """Descarga la lista de CISA KEV con evasi칩n anti-WAF."""
    try:
        # Configurar headers con evasi칩n anti-WAF
        headers = WAF_COMMON_HEADERS.copy()
        headers['User-Agent'] = random.choice(WAF_USER_AGENTS)
        
        config = WAF_EVASION_CONFIG
        
        # Realizar petici칩n con configuraci칩n anti-WAF
        response = requests.get(
            CISA_KEV_URL,
            headers=headers,
            timeout=config['max_time'],
            verify=False  # Ignorar certificados SSL si es necesario
        )
        response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)
        return response.json()
    except requests.exceptions.RequestException as e:
        log.error(f"Error al descargar la lista de CISA KEV: {e}")
        return None

def filter_cisa_kev_by_tech(cisa_kev_list: dict, tech_stack: list) -> list:
    """Filtra la lista de CISA KEV por tecnolog칤a detectada."""
    if not cisa_kev_list or not tech_stack:
        return []

    filtered_vulnerabilities = []
    for vulnerability in cisa_kev_list.get("vulnerabilities", []):
        vendor_product = vulnerability.get("vendorProduct", "").lower()
        for tech in tech_stack:
            if tech.lower() in vendor_product:
                filtered_vulnerabilities.append(vulnerability)
                break
    return filtered_vulnerabilities

def cisa_kev_monitor(domain: str, tmp_dir: Path, tech_stack: list) -> Path:
    """Monitoriza CISA KEV y alerta sobre vulnerabilidades relevantes.
    
    Returns:
        Path al archivo JSON con los resultados de CISA KEV.
    """
    log.info("Iniciando monitorizaci칩n de CISA KEV...")
    cisa_kev_file = tmp_dir / "cisa_kev.json"
    
    kev_list = download_cisa_kev_list()
    if kev_list:
        relevant_vulnerabilities = filter_cisa_kev_by_tech(kev_list, tech_stack)
        if relevant_vulnerabilities:
            log.warning("游뚿 춰Alerta! Se encontraron vulnerabilidades de CISA KEV relevantes para la tecnolog칤a detectada:")
            try:
                with open(cisa_kev_file, 'w') as f:
                    json.dump(relevant_vulnerabilities, f, indent=4)
                log.info(f"Resultados de CISA KEV guardados en {cisa_kev_file}")
            except IOError as e:
                log.error(f"Error al guardar los resultados de CISA KEV en {cisa_kev_file}: {e}")
                # Crear archivo vac칤o en caso de error
                with open(cisa_kev_file, 'w') as f:
                    json.dump([], f)

            for vul in relevant_vulnerabilities:
                log.warning(f"  - CVE ID: {vul.get('cveID')}, Vendor/Product: {vul.get('vendorProduct')}, Due Date: {vul.get('dueDate')}")
        else:
            log.info("No se encontraron vulnerabilidades de CISA KEV relevantes para la tecnolog칤a detectada.")
            # Crear archivo vac칤o cuando no hay vulnerabilidades
            with open(cisa_kev_file, 'w') as f:
                json.dump([], f)
    else:
        log.warning("No se pudo descargar la lista de CISA KEV")
        # Crear archivo vac칤o cuando no se puede descargar
        with open(cisa_kev_file, 'w') as f:
            json.dump([], f)
    
    return cisa_kev_file