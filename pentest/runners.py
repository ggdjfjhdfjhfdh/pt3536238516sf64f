"""Utilidades para ejecutar comandos y gestionar hilos."""

import logging
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor
from shlex import quote
from typing import List, Union, Optional

from pentest.config import DEFAULT_TIMEOUT

# Configuración de logging
log = logging.getLogger(__name__)

# Executor global para reutilizar hilos
thread_pool = ThreadPoolExecutor(max_workers=10)

def run_cmd(
    cmd: Union[str, List[str]], 
    ignore: bool = False, 
    timeout: int = DEFAULT_TIMEOUT,
    cwd: Optional[str] = None,
    retries: int = 0,
    delay: float = 1.0
) -> str:
    """Ejecuta un comando shell de forma segura y captura su salida.
    
    Args:
        cmd: Comando a ejecutar (string o lista de argumentos)
        ignore: Si es True, ignora errores de ejecución
        timeout: Tiempo máximo de ejecución en segundos
        cwd: Directorio de trabajo para el comando
        
    Returns:
        La salida estándar del comando como string
        
    Raises:
        subprocess.TimeoutExpired: Si el comando excede el timeout
        subprocess.CalledProcessError: Si el comando falla y ignore=False
    """
    # Convertir lista de argumentos a string con escape adecuado
    if isinstance(cmd, list):
        cmd = " ".join(quote(c) for c in cmd)
    
    log.info("⏩ Ejecutando comando: %s", cmd)
    log.info("⏩ Directorio de trabajo: %s", cwd or 'directorio actual')
    
    for i in range(retries + 1):
        try:
            res = subprocess.run(
                cmd, 
                shell=True,
                capture_output=True, 
                text=True,
                timeout=timeout, 
                check=not ignore,
                cwd=cwd
            )
            
            # Registrar la salida del comando independientemente del resultado
            if res.stdout.strip():
                log.info("stdout para '%s': %s", cmd, res.stdout.strip())
            if res.stderr.strip():
                log.info("stderr para '%s': %s", cmd, res.stderr.strip())
            
            # Verificar el código de salida
            log.info("Código de salida para '%s': %d", cmd, res.returncode)
            
            # Return both stdout and stderr if ignore is True, otherwise just stdout
            if ignore:
                return res.stdout + res.stderr
            else:
                return res.stdout
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:
            error_message = f"Fallo al ejecutar comando '{cmd}' después de {i + 1} intentos: {e}"
            if isinstance(e, subprocess.TimeoutExpired):
                error_message += f" (Timeout: {e.timeout}s)"
                if e.stdout:
                    log.info("stdout antes del timeout: %s", e.stdout.strip())
                if e.stderr:
                    log.info("stderr antes del timeout: %s", e.stderr.strip())
            
            if i < retries and not ignore:
                log.warning("Intento %d/%d fallido para '%s': %s. Reintentando en %.1f segundos...", i + 1, retries + 1, cmd, e, delay)
                time.sleep(delay)
                delay *= 2 # Retroceso exponencial
            else:
                log.error("❌ %s", error_message)
                if ignore:
                    return ""
                raise