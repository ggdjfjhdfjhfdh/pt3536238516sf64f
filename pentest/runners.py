"""Utilidades para ejecutar comandos y gestionar hilos."""

import logging
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor
from shlex import quote
from typing import List, Union, Optional

from pentest.config import DEFAULT_TIMEOUT

# Configuración de logging
log = logging.getLogger(__name__)

# Executor global para reutilizar hilos
thread_pool = ThreadPoolExecutor(max_workers=10)

def run_cmd(
    cmd: Union[str, List[str]], 
    ignore: bool = False, 
    timeout: int = DEFAULT_TIMEOUT,
    cwd: Optional[str] = None,
    retries: int = 0,
    delay: float = 1.0
) -> str:
    """Ejecuta un comando shell de forma segura y captura su salida.
    
    Args:
        cmd: Comando a ejecutar (string o lista de argumentos)
        ignore: Si es True, ignora errores de ejecución
        timeout: Tiempo máximo de ejecución en segundos
        cwd: Directorio de trabajo para el comando
        
    Returns:
        La salida estándar del comando como string
        
    Raises:
        subprocess.TimeoutExpired: Si el comando excede el timeout
        subprocess.CalledProcessError: Si el comando falla y ignore=False
    """
    # Log del comando original
    original_cmd = cmd
    log.info("🔧 [CMD] Comando original: %s (tipo: %s)", original_cmd, type(original_cmd))
    
    # Convertir lista de argumentos a string con escape adecuado
    if isinstance(cmd, list):
        # Para URLs, no usar quote() ya que añade backticks problemáticos
        escaped_args = []
        for arg in cmd:
            # Si es una URL, no escapar
            if arg.startswith(('http://', 'https://')):
                escaped_args.append(arg)
            # Si contiene espacios pero no es una URL, usar comillas dobles
            elif ' ' in arg:
                escaped_args.append(f'"{arg}"')
            else:
                escaped_args.append(arg)
        cmd = " ".join(escaped_args)
        log.info("🔧 [CMD] Comando convertido a string: %s", cmd)
    
    log.info("🔧 [CMD] ⏩ Ejecutando comando: %s", cmd)
    log.info("🔧 [CMD] Directorio de trabajo: %s", cwd or 'directorio actual')
    log.info("🔧 [CMD] Timeout: %d segundos", timeout)
    log.info("🔧 [CMD] Ignore errors: %s", ignore)
    log.info("🔧 [CMD] Reintentos: %d", retries)
    
    # Log del entorno
    import os
    log.info("🔧 [CMD] PATH actual: %s", os.environ.get('PATH', 'No definido')[:200] + '...')
    log.info("🔧 [CMD] SHELL: %s", os.environ.get('SHELL', 'No definido'))
    log.info("🔧 [CMD] USER: %s", os.environ.get('USER', 'No definido'))
    
    for i in range(retries + 1):
        try:
            log.info("🔧 [CMD] Intento %d/%d", i + 1, retries + 1)
            
            res = subprocess.run(
                cmd, 
                shell=True,
                capture_output=True, 
                text=True,
                timeout=timeout, 
                check=False,  # Siempre False para manejar errores manualmente
                cwd=cwd
            )
            
            # Manejar errores manualmente para preservar stderr
            if res.returncode != 0 and not ignore:
                # Crear excepción con stderr preservado
                error = subprocess.CalledProcessError(res.returncode, cmd, res.stdout, res.stderr)
                raise error
            
            log.info("🔧 [CMD] ✅ Comando ejecutado exitosamente")
            log.info("🔧 [CMD] Código de salida: %d", res.returncode)
            
            # Registrar la salida del comando independientemente del resultado
            if res.stdout.strip():
                log.info("🔧 [CMD] stdout (longitud %d): %s", len(res.stdout), res.stdout.strip()[:500] + ('...' if len(res.stdout) > 500 else ''))
            else:
                log.info("🔧 [CMD] stdout: (vacío)")
                
            if res.stderr.strip():
                log.info("🔧 [CMD] stderr (longitud %d): %s", len(res.stderr), res.stderr.strip()[:500] + ('...' if len(res.stderr) > 500 else ''))
            else:
                log.info("🔧 [CMD] stderr: (vacío)")
            
            # Return both stdout and stderr if ignore is True, otherwise just stdout
            result = res.stdout + res.stderr if ignore else res.stdout
            log.info("🔧 [CMD] ✅ Retornando resultado (longitud %d)", len(result))
            return result
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:
            log.error("🔧 [CMD] ❌ Error en intento %d/%d", i + 1, retries + 1)
            log.error("🔧 [CMD] ❌ Tipo de error: %s", type(e).__name__)
            log.error("🔧 [CMD] ❌ Mensaje de error: %s", str(e))
            
            error_message = f"Fallo al ejecutar comando '{cmd}' después de {i + 1} intentos: {e}"
            
            if isinstance(e, subprocess.TimeoutExpired):
                error_message += f" (Timeout: {e.timeout}s)"
                log.error("🔧 [CMD] ❌ Timeout después de %s segundos", e.timeout)
                if e.stdout:
                    log.info("🔧 [CMD] stdout antes del timeout: %s", e.stdout.strip()[:300])
                if e.stderr:
                    log.info("🔧 [CMD] stderr antes del timeout: %s", e.stderr.strip()[:300])
            elif isinstance(e, subprocess.CalledProcessError):
                log.error("🔧 [CMD] ❌ Código de salida: %d", e.returncode)
                if e.stdout:
                    log.error("🔧 [CMD] ❌ stdout del error: %s", e.stdout.strip()[:300])
                if e.stderr:
                    log.error("🔧 [CMD] ❌ stderr del error: %s", e.stderr.strip()[:300])
            
            if i < retries:
                log.warning("🔧 [CMD] ⚠️ Intento %d/%d fallido para '%s': %s. Reintentando en %.1f segundos...", i + 1, retries + 1, cmd, e, delay)
                time.sleep(delay)
                delay *= 2 # Retroceso exponencial
            else:
                log.error("🔧 [CMD] ❌ Todos los intentos fallaron: %s", error_message)
                if ignore:
                    log.warning("🔧 [CMD] ⚠️ Ignorando error y retornando string vacío")
                    return ""
                log.error("🔧 [CMD] ❌ Lanzando excepción")
                raise