#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Parche de integraci√≥n para core.py - Sistema mejorado de detecci√≥n de tecnolog√≠as.
Este archivo contiene las modificaciones necesarias para integrar las mejoras en el pipeline existente.
"""

import logging
import json
import time
from pathlib import Path
from typing import Dict, Any, Optional

# Importar el integrador mejorado
try:
    from .enhanced_integration import EnhancedTechIntegrator, detect_technologies_enhanced
except ImportError:
    print("‚ö†Ô∏è M√≥dulos de detecci√≥n mejorada no disponibles, usando detecci√≥n b√°sica")
    EnhancedTechIntegrator = None
    detect_technologies_enhanced = None

log = logging.getLogger(__name__)

class EnhancedCorePipeline:
    """
    Extensi√≥n del pipeline principal con capacidades mejoradas de detecci√≥n.
    Esta clase se integra con el core.py existente.
    """
    
    def __init__(self, original_core_instance=None):
        self.original_core = original_core_instance
        self.enhanced_integrator = None
        self.enhanced_enabled = False
        self.fallback_to_original = True
        
        # Configuraci√≥n de integraci√≥n
        self.integration_config = {
            "enable_enhanced_detection": True,
            "enable_legacy_fallback": True,
            "enable_security_analysis": True,
            "enable_metrics": True,
            "validate_tools_on_startup": False,  # Para evitar delays en producci√≥n
            "cache_enabled": True,
            "max_workers": 4,
            "timeout": 30
        }
        
        self._initialize_enhanced_system()
    
    def _initialize_enhanced_system(self):
        """Inicializa el sistema mejorado de detecci√≥n."""
        if not EnhancedTechIntegrator:
            log.warning("üîÑ Sistema mejorado no disponible, usando detecci√≥n b√°sica")
            return
        
        try:
            log.info("üöÄ Inicializando sistema mejorado de detecci√≥n...")
            
            self.enhanced_integrator = EnhancedTechIntegrator(config=self.integration_config)
            
            # Inicializaci√≥n as√≠ncrona para no bloquear el startup
            if self.integration_config.get("validate_tools_on_startup", False):
                success = self.enhanced_integrator.initialize()
                if success:
                    self.enhanced_enabled = True
                    log.info("‚úÖ Sistema mejorado inicializado correctamente")
                else:
                    log.warning("‚ö†Ô∏è Error inicializando sistema mejorado, usando fallback")
            else:
                # Inicializaci√≥n lazy - se inicializa en el primer uso
                self.enhanced_enabled = True
                log.info("‚úÖ Sistema mejorado configurado para inicializaci√≥n lazy")
                
        except Exception as e:
            log.error(f"‚ùå Error configurando sistema mejorado: {e}")
            self.enhanced_enabled = False
    
    def enhanced_fingerprint_step(self, url: str, output_dir: str, **kwargs) -> Dict[str, Any]:
        """
        Paso mejorado de fingerprinting que reemplaza o complementa el paso 'finger' original.
        
        Args:
            url: URL objetivo
            output_dir: Directorio de salida
            **kwargs: Argumentos adicionales
        
        Returns:
            Dict con resultados de detecci√≥n mejorada
        """
        step_start_time = time.time()
        
        try:
            log.info(f"üîç Iniciando detecci√≥n mejorada de tecnolog√≠as para {url}")
            
            # Intentar detecci√≥n mejorada
            if self.enhanced_enabled and self.enhanced_integrator:
                try:
                    # Inicializaci√≥n lazy si es necesario
                    if not self.enhanced_integrator.initialized:
                        log.info("üîß Inicializando sistema mejorado (lazy initialization)...")
                        success = self.enhanced_integrator.initialize()
                        if not success:
                            raise RuntimeError("Fallo en inicializaci√≥n lazy")
                    
                    # Ejecutar detecci√≥n mejorada
                    enhanced_result = self.enhanced_integrator.detect_technologies(url, **kwargs)
                    
                    # Convertir resultado al formato esperado por core.py
                    core_result = self._convert_enhanced_to_core_format(enhanced_result, output_dir)
                    
                    # Guardar resultados detallados
                    self._save_enhanced_results(enhanced_result, output_dir)
                    
                    log.info(f"‚úÖ Detecci√≥n mejorada completada en {enhanced_result.detection_time:.2f}s")
                    log.info(f"üìä Tecnolog√≠as detectadas: {len(enhanced_result.technologies)}")
                    log.info(f"üéØ Confianza promedio: {enhanced_result.confidence_score:.2f}")
                    
                    return core_result
                    
                except Exception as e:
                    log.error(f"‚ùå Error en detecci√≥n mejorada: {e}")
                    
                    if self.fallback_to_original:
                        log.info("üîÑ Fallback a detecci√≥n original...")
                        return self._fallback_to_original_fingerprint(url, output_dir, **kwargs)
                    else:
                        raise
            
            else:
                log.info("üîÑ Sistema mejorado no disponible, usando detecci√≥n original")
                return self._fallback_to_original_fingerprint(url, output_dir, **kwargs)
        
        except Exception as e:
            log.error(f"‚ùå Error cr√≠tico en fingerprinting: {e}")
            
            # Resultado m√≠nimo en caso de error total
            return {
                "status": "error",
                "error": str(e),
                "technologies": [],
                "detection_time": time.time() - step_start_time,
                "enhanced": False
            }
    
    def _convert_enhanced_to_core_format(self, enhanced_result, output_dir: str) -> Dict[str, Any]:
        """
        Convierte el resultado mejorado al formato esperado por core.py.
        """
        return {
            "status": "success",
            "url": enhanced_result.url,
            "technologies": enhanced_result.technologies,
            "confidence_score": enhanced_result.confidence_score,
            "detection_time": enhanced_result.detection_time,
            "tool_coverage": enhanced_result.tool_coverage,
            "security_analysis": enhanced_result.security_analysis,
            "recommendations": enhanced_result.recommendations,
            "vulnerabilities_found": enhanced_result.vulnerabilities_found,
            "enhanced": True,
            "output_dir": output_dir,
            "timestamp": time.time()
        }
    
    def _save_enhanced_results(self, enhanced_result, output_dir: str) -> None:
        """
        Guarda los resultados detallados de la detecci√≥n mejorada.
        """
        try:
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Guardar resultado principal
            main_result_file = output_path / "enhanced_fingerprint.json"
            with open(main_result_file, 'w', encoding='utf-8') as f:
                json.dump({
                    "url": enhanced_result.url,
                    "technologies": enhanced_result.technologies,
                    "security_analysis": enhanced_result.security_analysis,
                    "performance_metrics": enhanced_result.performance_metrics,
                    "tool_coverage": enhanced_result.tool_coverage,
                    "confidence_score": enhanced_result.confidence_score,
                    "detection_time": enhanced_result.detection_time,
                    "recommendations": enhanced_result.recommendations,
                    "vulnerabilities_found": enhanced_result.vulnerabilities_found,
                    "timestamp": time.time()
                }, f, indent=2, ensure_ascii=False)
            
            # Guardar recomendaciones por separado
            if enhanced_result.recommendations:
                recommendations_file = output_path / "security_recommendations.txt"
                with open(recommendations_file, 'w', encoding='utf-8') as f:
                    f.write("RECOMENDACIONES DE SEGURIDAD\n")
                    f.write("=" * 50 + "\n\n")
                    for i, rec in enumerate(enhanced_result.recommendations, 1):
                        f.write(f"{i}. {rec}\n")
            
            # Guardar vulnerabilidades encontradas
            if enhanced_result.vulnerabilities_found:
                vulns_file = output_path / "vulnerabilities_found.json"
                with open(vulns_file, 'w', encoding='utf-8') as f:
                    json.dump(enhanced_result.vulnerabilities_found, f, indent=2, ensure_ascii=False)
            
            log.info(f"üíæ Resultados detallados guardados en: {output_path}")
            
        except Exception as e:
            log.error(f"‚ùå Error guardando resultados detallados: {e}")
    
    def _fallback_to_original_fingerprint(self, url: str, output_dir: str, **kwargs) -> Dict[str, Any]:
        """
        Fallback a la detecci√≥n original de fingerprint.
        """
        try:
            if self.original_core and hasattr(self.original_core, 'fingerprint'):
                # Usar el m√©todo original si est√° disponible
                original_result = self.original_core.fingerprint(url, output_dir, **kwargs)
                
                # Adaptar formato si es necesario
                if isinstance(original_result, dict):
                    original_result["enhanced"] = False
                    original_result["fallback_used"] = True
                    return original_result
            
            # Fallback b√°sico usando funci√≥n de compatibilidad
            if detect_technologies_enhanced:
                basic_result = detect_technologies_enhanced(url, config={"enable_enhanced_detection": False})
                basic_result["enhanced"] = False
                basic_result["fallback_used"] = True
                return basic_result
            
            # √öltimo recurso: resultado m√≠nimo
            return {
                "status": "fallback",
                "url": url,
                "technologies": [],
                "enhanced": False,
                "fallback_used": True,
                "error": "No hay m√©todos de detecci√≥n disponibles"
            }
            
        except Exception as e:
            log.error(f"‚ùå Error en fallback: {e}")
            return {
                "status": "error",
                "url": url,
                "technologies": [],
                "enhanced": False,
                "fallback_used": True,
                "error": str(e)
            }
    
    def get_enhanced_nuclei_templates(self, fingerprint_result: Dict[str, Any]) -> list:
        """
        Obtiene plantillas Nuclei espec√≠ficas basadas en las tecnolog√≠as detectadas.
        
        Args:
            fingerprint_result: Resultado del fingerprinting mejorado
        
        Returns:
            Lista de plantillas Nuclei recomendadas
        """
        try:
            if not self.enhanced_integrator or not self.enhanced_integrator.tech_mapper:
                return []
            
            technologies = fingerprint_result.get("technologies", [])
            if not technologies:
                return []
            
            templates = self.enhanced_integrator.tech_mapper.get_nuclei_templates(technologies)
            
            log.info(f"üéØ Plantillas Nuclei recomendadas: {len(templates)}")
            return templates
            
        except Exception as e:
            log.error(f"‚ùå Error obteniendo plantillas Nuclei: {e}")
            return []
    
    def get_security_recommendations(self, fingerprint_result: Dict[str, Any]) -> list:
        """
        Obtiene recomendaciones de seguridad basadas en las tecnolog√≠as detectadas.
        
        Args:
            fingerprint_result: Resultado del fingerprinting mejorado
        
        Returns:
            Lista de recomendaciones de seguridad
        """
        try:
            recommendations = fingerprint_result.get("recommendations", [])
            security_analysis = fingerprint_result.get("security_analysis", {})
            
            if security_analysis.get("recommendations"):
                recommendations.extend(security_analysis["recommendations"])
            
            return list(set(recommendations))  # Eliminar duplicados
            
        except Exception as e:
            log.error(f"‚ùå Error obteniendo recomendaciones: {e}")
            return []
    
    def export_enhanced_metrics(self, output_dir: str) -> None:
        """
        Exporta m√©tricas del sistema mejorado.
        
        Args:
            output_dir: Directorio donde exportar las m√©tricas
        """
        try:
            if not self.enhanced_integrator:
                log.warning("‚ö†Ô∏è Sistema mejorado no disponible para exportar m√©tricas")
                return
            
            output_path = Path(output_dir) / "enhanced_metrics.json"
            self.enhanced_integrator.export_metrics(str(output_path))
            
            log.info(f"üìä M√©tricas exportadas a: {output_path}")
            
        except Exception as e:
            log.error(f"‚ùå Error exportando m√©tricas: {e}")
    
    def get_system_status(self) -> Dict[str, Any]:
        """
        Obtiene el estado del sistema mejorado.
        
        Returns:
            Dict con informaci√≥n del estado del sistema
        """
        try:
            status = {
                "enhanced_enabled": self.enhanced_enabled,
                "fallback_enabled": self.fallback_to_original,
                "integration_config": self.integration_config
            }
            
            if self.enhanced_integrator:
                enhanced_status = self.enhanced_integrator.get_system_status()
                status.update(enhanced_status)
            
            return status
            
        except Exception as e:
            log.error(f"‚ùå Error obteniendo estado del sistema: {e}")
            return {"error": str(e), "enhanced_enabled": False}


# Funciones de integraci√≥n para core.py
def patch_core_pipeline(core_instance):
    """
    Aplica el parche al pipeline principal.
    
    Args:
        core_instance: Instancia del core pipeline original
    
    Returns:
        Instancia del pipeline mejorado
    """
    try:
        log.info("üîß Aplicando parche de integraci√≥n al pipeline principal...")
        
        enhanced_pipeline = EnhancedCorePipeline(original_core_instance=core_instance)
        
        # Reemplazar el m√©todo de fingerprinting si es posible
        if hasattr(core_instance, 'fingerprint'):
            # Guardar m√©todo original como backup
            core_instance._original_fingerprint = core_instance.fingerprint
            # Reemplazar con m√©todo mejorado
            core_instance.fingerprint = enhanced_pipeline.enhanced_fingerprint_step
            log.info("‚úÖ M√©todo fingerprint reemplazado con versi√≥n mejorada")
        
        # Agregar m√©todos adicionales
        core_instance.get_enhanced_nuclei_templates = enhanced_pipeline.get_enhanced_nuclei_templates
        core_instance.get_security_recommendations = enhanced_pipeline.get_security_recommendations
        core_instance.export_enhanced_metrics = enhanced_pipeline.export_enhanced_metrics
        core_instance.get_enhanced_system_status = enhanced_pipeline.get_system_status
        
        # Guardar referencia al pipeline mejorado
        core_instance._enhanced_pipeline = enhanced_pipeline
        
        log.info("‚úÖ Parche de integraci√≥n aplicado correctamente")
        return enhanced_pipeline
        
    except Exception as e:
        log.error(f"‚ùå Error aplicando parche de integraci√≥n: {e}")
        return None


def update_pipeline_steps(pipeline_steps: Dict[str, Any]) -> Dict[str, Any]:
    """
    Actualiza la configuraci√≥n de pasos del pipeline para incluir mejoras.
    
    Args:
        pipeline_steps: Configuraci√≥n original de pasos
    
    Returns:
        Configuraci√≥n actualizada de pasos
    """
    try:
        # Crear copia de la configuraci√≥n original
        updated_steps = pipeline_steps.copy()
        
        # Actualizar paso de fingerprinting
        if "finger" in updated_steps:
            finger_config = updated_steps["finger"]
            finger_config["enhanced"] = True
            finger_config["description"] = "Enhanced Technology Detection"
            # Aumentar ligeramente el tiempo esperado debido a las mejoras
            if "expected_time" in finger_config:
                finger_config["expected_time"] = min(finger_config["expected_time"] * 1.2, 60)
        
        # Agregar nuevo paso de an√°lisis de seguridad si no existe
        if "security_analysis" not in updated_steps:
            updated_steps["security_analysis"] = {
                "percentage": 2,
                "depends_on": ["finger"],
                "timeout": 30,
                "description": "Security Analysis based on detected technologies",
                "enhanced": True,
                "optional": True
            }
        
        log.info("‚úÖ Configuraci√≥n de pasos actualizada con mejoras")
        return updated_steps
        
    except Exception as e:
        log.error(f"‚ùå Error actualizando configuraci√≥n de pasos: {e}")
        return pipeline_steps


# Funci√≥n de conveniencia para integraci√≥n completa
def integrate_enhanced_detection(core_instance, pipeline_steps: Optional[Dict[str, Any]] = None):
    """
    Integra completamente el sistema mejorado de detecci√≥n.
    
    Args:
        core_instance: Instancia del core pipeline
        pipeline_steps: Configuraci√≥n de pasos del pipeline (opcional)
    
    Returns:
        Tuple (enhanced_pipeline, updated_steps)
    """
    try:
        log.info("üöÄ Iniciando integraci√≥n completa del sistema mejorado...")
        
        # Aplicar parche al pipeline
        enhanced_pipeline = patch_core_pipeline(core_instance)
        
        # Actualizar configuraci√≥n de pasos si se proporciona
        updated_steps = None
        if pipeline_steps:
            updated_steps = update_pipeline_steps(pipeline_steps)
        
        if enhanced_pipeline:
            log.info("‚úÖ Integraci√≥n completa exitosa")
            
            # Mostrar estado del sistema
            status = enhanced_pipeline.get_system_status()
            log.info(f"üìä Estado del sistema mejorado: {status.get('enhanced_enabled', False)}")
            
        return enhanced_pipeline, updated_steps
        
    except Exception as e:
        log.error(f"‚ùå Error en integraci√≥n completa: {e}")
        return None, pipeline_steps


if __name__ == "__main__":
    # Ejemplo de uso del parche
    import logging
    logging.basicConfig(level=logging.INFO)
    
    print("üîß Parche de integraci√≥n para sistema mejorado de detecci√≥n")
    print("Este archivo debe ser importado y usado desde core.py")
    print("\nEjemplo de uso:")
    print("```python")
    print("from core_integration_patch import integrate_enhanced_detection")
    print("enhanced_pipeline, updated_steps = integrate_enhanced_detection(core_instance, pipeline_steps)")
    print("```")