#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Integrador principal para las mejoras de detecciÃ³n de tecnologÃ­as.
Conecta el sistema mejorado con el pipeline existente en core.py.
"""

import logging
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict

# Importar mÃ³dulos existentes
try:
    from .fingerprint import TechDetector
except ImportError:
    try:
        from fingerprint import TechDetector
    except ImportError:
        # Fallback si no existe el mÃ³dulo original
        TechDetector = None

# Importar nuevos mÃ³dulos
try:
    from .enhanced_fingerprint import EnhancedTechDetector
    from .tech_mapping import TechMapper
    from .metrics import TechDetectionMetrics
    from .tool_validator import ExternalToolValidator, ToolStatus
except ImportError:
    from enhanced_fingerprint import EnhancedTechDetector
    from tech_mapping import TechMapper
    from metrics import TechDetectionMetrics
    from tool_validator import ExternalToolValidator, ToolStatus

log = logging.getLogger(__name__)

@dataclass
class EnhancedDetectionResult:
    """Resultado mejorado de detecciÃ³n de tecnologÃ­as."""
    url: str
    technologies: List[Dict[str, Any]]
    security_analysis: Dict[str, Any]
    performance_metrics: Dict[str, Any]
    tool_coverage: Dict[str, bool]
    confidence_score: float
    detection_time: float
    recommendations: List[str]
    vulnerabilities_found: List[Dict[str, Any]]
    
class EnhancedTechIntegrator:
    """Integrador principal para el sistema mejorado de detecciÃ³n."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.enhanced_detector = None
        self.tech_mapper = None
        self.metrics = None
        self.validator = None
        self.legacy_detector = None
        self.initialized = False
        
        # ConfiguraciÃ³n por defecto
        self.default_config = {
            "enable_enhanced_detection": True,
            "enable_legacy_fallback": True,
            "enable_parallel_detection": True,
            "enable_security_analysis": True,
            "enable_metrics": True,
            "enable_web_content_analysis": True,
            "cache_enabled": True,
            "cache_ttl": 3600,
            "max_workers": 4,
            "timeout": 30,
            "confidence_threshold": 0.7,
            "validate_tools_on_startup": True
        }
        
        # Combinar configuraciÃ³n
        self.config = {**self.default_config, **self.config}
        
    def initialize(self) -> bool:
        """Inicializa todos los componentes del sistema mejorado."""
        try:
            log.info("ğŸš€ Inicializando sistema mejorado de detecciÃ³n de tecnologÃ­as...")
            
            # 1. Validar herramientas externas
            if self.config.get("validate_tools_on_startup", True):
                self._validate_external_tools()
            
            # 2. Inicializar detector mejorado
            self._initialize_enhanced_detector()
            
            # 3. Inicializar mapeador de tecnologÃ­as
            self._initialize_tech_mapper()
            
            # 4. Inicializar sistema de mÃ©tricas
            if self.config.get("enable_metrics", True):
                self._initialize_metrics()
            
            # 5. Inicializar detector legacy como fallback
            if self.config.get("enable_legacy_fallback", True):
                self._initialize_legacy_detector()
            
            self.initialized = True
            log.info("âœ… Sistema mejorado inicializado correctamente")
            return True
            
        except Exception as e:
            log.error(f"âŒ Error inicializando sistema mejorado: {e}")
            return False
    
    def _validate_external_tools(self) -> None:
        """Valida herramientas externas."""
        log.info("ğŸ” Validando herramientas externas...")
        
        self.validator = ExternalToolValidator(
            timeout=self.config.get("timeout", 30)
        )
        
        tools_info = self.validator.validate_all_tools()
        available_tools = self.validator.get_available_tools()
        
        if not available_tools:
            log.warning("âš ï¸ No hay herramientas externas disponibles, usando solo detecciÃ³n bÃ¡sica")
        else:
            log.info(f"âœ… Herramientas disponibles: {', '.join(available_tools)}")
    
    def _initialize_enhanced_detector(self) -> None:
        """Inicializa el detector mejorado."""
        log.info("ğŸ”§ Inicializando detector mejorado...")
        
        detector_config = {
            "cache_enabled": self.config.get("cache_enabled", True),
            "cache_ttl": self.config.get("cache_ttl", 3600),
            "max_workers": self.config.get("max_workers", 4),
            "timeout": self.config.get("timeout", 30),
            "enable_parallel": self.config.get("enable_parallel_detection", True),
            "enable_web_content_analysis": self.config.get("enable_web_content_analysis", True)
        }
        
        self.enhanced_detector = EnhancedTechDetector(config=detector_config)
        
        # Configurar herramientas disponibles
        if self.validator:
            available_tools = self.validator.get_available_tools()
            self.enhanced_detector.set_available_tools(available_tools)
    
    def _initialize_tech_mapper(self) -> None:
        """Inicializa el mapeador de tecnologÃ­as."""
        log.info("ğŸ—ºï¸ Inicializando mapeador de tecnologÃ­as...")
        
        # Buscar archivo de configuraciÃ³n
        config_paths = [
            Path("pentest/tech_mappings.yaml"),
            Path("tech_mappings.yaml"),
            Path("config/tech_mappings.yaml")
        ]
        
        config_file = None
        for path in config_paths:
            if path.exists():
                config_file = str(path)
                break
        
        if not config_file:
            log.warning("âš ï¸ No se encontrÃ³ archivo de configuraciÃ³n de mapeos, usando configuraciÃ³n por defecto")
        
        self.tech_mapper = TechMapper(config_file=config_file)
    
    def _initialize_metrics(self) -> None:
        """Inicializa el sistema de mÃ©tricas."""
        log.info("ğŸ“Š Inicializando sistema de mÃ©tricas...")
        
        self.metrics = TechDetectionMetrics()
    
    def _initialize_legacy_detector(self) -> None:
        """Inicializa el detector legacy como fallback."""
        if TechDetector:
            log.info("ğŸ”„ Inicializando detector legacy como fallback...")
            try:
                self.legacy_detector = TechDetector()
                log.info("âœ… Detector legacy inicializado")
            except Exception as e:
                log.warning(f"âš ï¸ No se pudo inicializar detector legacy: {e}")
        else:
            log.info("â„¹ï¸ Detector legacy no disponible")
    
    def detect_technologies(self, url: str, **kwargs) -> EnhancedDetectionResult:
        """Detecta tecnologÃ­as usando el sistema mejorado."""
        if not self.initialized:
            if not self.initialize():
                raise RuntimeError("No se pudo inicializar el sistema mejorado")
        
        start_time = time.time()
        
        try:
            # 1. DetecciÃ³n mejorada
            enhanced_result = self._run_enhanced_detection(url, **kwargs)
            
            # 2. AnÃ¡lisis de seguridad
            security_analysis = self._run_security_analysis(url, enhanced_result)
            
            # 3. Generar recomendaciones
            recommendations = self._generate_recommendations(enhanced_result, security_analysis)
            
            # 4. Calcular mÃ©tricas
            performance_metrics = self._calculate_performance_metrics(start_time)
            
            # 5. Registrar mÃ©tricas
            if self.metrics:
                self._record_metrics(url, enhanced_result, performance_metrics)
            
            # 6. Crear resultado final
            result = EnhancedDetectionResult(
                url=url,
                technologies=enhanced_result.get("technologies", []),
                security_analysis=security_analysis,
                performance_metrics=performance_metrics,
                tool_coverage=enhanced_result.get("tool_coverage", {}),
                confidence_score=enhanced_result.get("confidence_score", 0.0),
                detection_time=time.time() - start_time,
                recommendations=recommendations,
                vulnerabilities_found=security_analysis.get("vulnerabilities", [])
            )
            
            log.info(f"âœ… DetecciÃ³n completada para {url} en {result.detection_time:.2f}s")
            return result
            
        except Exception as e:
            log.error(f"âŒ Error en detecciÃ³n mejorada para {url}: {e}")
            
            # Fallback a detector legacy
            if self.config.get("enable_legacy_fallback", True):
                return self._fallback_detection(url, start_time, **kwargs)
            else:
                raise
    
    def _run_enhanced_detection(self, url: str, **kwargs) -> Dict[str, Any]:
        """Ejecuta detecciÃ³n mejorada."""
        if not self.enhanced_detector:
            raise RuntimeError("Detector mejorado no inicializado")
        
        # Configurar opciones de detecciÃ³n
        detection_options = {
            "enable_parallel": self.config.get("enable_parallel_detection", True),
            "confidence_threshold": self.config.get("confidence_threshold", 0.7),
            **kwargs
        }
        
        return self.enhanced_detector.detect_technologies(url, **detection_options)
    
    def _run_security_analysis(self, url: str, detection_result: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecuta anÃ¡lisis de seguridad basado en tecnologÃ­as detectadas."""
        if not self.config.get("enable_security_analysis", True) or not self.tech_mapper:
            return {"enabled": False, "vulnerabilities": []}
        
        try:
            technologies = detection_result.get("technologies", [])
            security_analysis = self.tech_mapper.get_security_analysis(technologies)
            
            return {
                "enabled": True,
                "vulnerabilities": security_analysis.get("vulnerabilities", []),
                "security_headers": security_analysis.get("security_headers", {}),
                "recommendations": security_analysis.get("recommendations", []),
                "risk_score": security_analysis.get("risk_score", 0)
            }
            
        except Exception as e:
            log.error(f"Error en anÃ¡lisis de seguridad: {e}")
            return {"enabled": True, "error": str(e), "vulnerabilities": []}
    
    def _generate_recommendations(self, detection_result: Dict[str, Any], security_analysis: Dict[str, Any]) -> List[str]:
        """Genera recomendaciones basadas en los resultados."""
        recommendations = []
        
        try:
            # Recomendaciones de seguridad
            if security_analysis.get("enabled", False):
                recommendations.extend(security_analysis.get("recommendations", []))
            
            # Recomendaciones de rendimiento
            technologies = detection_result.get("technologies", [])
            for tech in technologies:
                if tech.get("name") == "jQuery" and tech.get("version", "").startswith("1."):
                    recommendations.append("Considerar actualizar jQuery a una versiÃ³n mÃ¡s reciente")
                
                if tech.get("name") == "WordPress" and "version" in tech:
                    recommendations.append("Verificar que WordPress estÃ© actualizado a la Ãºltima versiÃ³n")
            
            # Recomendaciones de herramientas
            tool_coverage = detection_result.get("tool_coverage", {})
            missing_tools = [tool for tool, available in tool_coverage.items() if not available]
            if missing_tools:
                recommendations.append(f"Instalar herramientas faltantes para mejor detecciÃ³n: {', '.join(missing_tools)}")
            
        except Exception as e:
            log.error(f"Error generando recomendaciones: {e}")
        
        return recommendations
    
    def _calculate_performance_metrics(self, start_time: float) -> Dict[str, Any]:
        """Calcula mÃ©tricas de rendimiento."""
        return {
            "total_time": time.time() - start_time,
            "timestamp": time.time(),
            "tools_used": self.validator.get_available_tools() if self.validator else [],
            "cache_enabled": self.config.get("cache_enabled", False),
            "parallel_enabled": self.config.get("enable_parallel_detection", False)
        }
    
    def _record_metrics(self, url: str, detection_result: Dict[str, Any], performance_metrics: Dict[str, Any]) -> None:
        """Registra mÃ©tricas en el sistema de monitoreo."""
        if not self.metrics:
            return
        
        try:
            technologies = detection_result.get("technologies", [])
            confidence_score = detection_result.get("confidence_score", 0.0)
            detection_time = performance_metrics.get("total_time", 0.0)
            
            self.metrics.record_detection(
                url=url,
                technologies_found=len(technologies),
                confidence_score=confidence_score,
                detection_time=detection_time,
                tools_used=performance_metrics.get("tools_used", [])
            )
            
        except Exception as e:
            log.error(f"Error registrando mÃ©tricas: {e}")
    
    def _fallback_detection(self, url: str, start_time: float, **kwargs) -> EnhancedDetectionResult:
        """Ejecuta detecciÃ³n usando el sistema legacy como fallback."""
        log.warning(f"ğŸ”„ Usando detecciÃ³n legacy para {url}")
        
        try:
            if self.legacy_detector:
                legacy_result = self.legacy_detector.detect_technologies(url)
                
                # Convertir resultado legacy al formato mejorado
                technologies = legacy_result.get("technologies", [])
                
                return EnhancedDetectionResult(
                    url=url,
                    technologies=technologies,
                    security_analysis={"enabled": False, "fallback": True},
                    performance_metrics={
                        "total_time": time.time() - start_time,
                        "fallback_used": True
                    },
                    tool_coverage={},
                    confidence_score=0.5,  # Confianza reducida para fallback
                    detection_time=time.time() - start_time,
                    recommendations=["Sistema mejorado no disponible, usando detecciÃ³n bÃ¡sica"],
                    vulnerabilities_found=[]
                )
            else:
                # Sin detector disponible
                return EnhancedDetectionResult(
                    url=url,
                    technologies=[],
                    security_analysis={"enabled": False, "error": "No hay detectores disponibles"},
                    performance_metrics={"total_time": time.time() - start_time, "error": True},
                    tool_coverage={},
                    confidence_score=0.0,
                    detection_time=time.time() - start_time,
                    recommendations=["Instalar herramientas de detecciÃ³n de tecnologÃ­as"],
                    vulnerabilities_found=[]
                )
                
        except Exception as e:
            log.error(f"Error en detecciÃ³n fallback: {e}")
            raise
    
    def get_system_status(self) -> Dict[str, Any]:
        """Obtiene el estado del sistema mejorado."""
        status = {
            "initialized": self.initialized,
            "enhanced_detector": self.enhanced_detector is not None,
            "tech_mapper": self.tech_mapper is not None,
            "metrics": self.metrics is not None,
            "legacy_detector": self.legacy_detector is not None,
            "config": self.config
        }
        
        if self.validator:
            status["external_tools"] = {
                "available": self.validator.get_available_tools(),
                "total_validated": len(self.validator.tools_info)
            }
        
        if self.metrics:
            status["metrics_summary"] = self.metrics.get_summary()
        
        return status
    
    def export_metrics(self, output_path: str) -> None:
        """Exporta mÃ©tricas del sistema."""
        if self.metrics:
            self.metrics.export_metrics(output_path)
            log.info(f"ğŸ“Š MÃ©tricas exportadas a: {output_path}")
        else:
            log.warning("âš ï¸ Sistema de mÃ©tricas no inicializado")
    
    def reset_metrics(self) -> None:
        """Reinicia las mÃ©tricas del sistema."""
        if self.metrics:
            self.metrics.reset_metrics()
            log.info("ğŸ”„ MÃ©tricas reiniciadas")
        else:
            log.warning("âš ï¸ Sistema de mÃ©tricas no inicializado")


# FunciÃ³n de conveniencia para integraciÃ³n con core.py
def create_enhanced_integrator(config: Optional[Dict[str, Any]] = None) -> EnhancedTechIntegrator:
    """Crea una instancia del integrador mejorado."""
    return EnhancedTechIntegrator(config=config)


# FunciÃ³n de compatibilidad con la API existente
def detect_technologies_enhanced(url: str, config: Optional[Dict[str, Any]] = None, **kwargs) -> Dict[str, Any]:
    """FunciÃ³n de compatibilidad para detecciÃ³n mejorada."""
    integrator = create_enhanced_integrator(config)
    result = integrator.detect_technologies(url, **kwargs)
    
    # Convertir a formato compatible
    return {
        "url": result.url,
        "technologies": result.technologies,
        "security_analysis": result.security_analysis,
        "performance_metrics": result.performance_metrics,
        "confidence_score": result.confidence_score,
        "detection_time": result.detection_time,
        "recommendations": result.recommendations,
        "enhanced": True
    }


if __name__ == "__main__":
    # Ejemplo de uso
    logging.basicConfig(level=logging.INFO)
    
    # Crear integrador
    integrator = create_enhanced_integrator()
    
    # Obtener estado del sistema
    status = integrator.get_system_status()
    print("\nğŸ” Estado del sistema:")
    print(json.dumps(status, indent=2))
    
    # Ejemplo de detecciÃ³n
    if integrator.initialized:
        test_url = "https://example.com"
        print(f"\nğŸ¯ Probando detecciÃ³n en: {test_url}")
        
        try:
            result = integrator.detect_technologies(test_url)
            print(f"âœ… TecnologÃ­as encontradas: {len(result.technologies)}")
            print(f"ğŸ“Š Tiempo de detecciÃ³n: {result.detection_time:.2f}s")
            print(f"ğŸ¯ PuntuaciÃ³n de confianza: {result.confidence_score:.2f}")
        except Exception as e:
            print(f"âŒ Error en detecciÃ³n: {e}")