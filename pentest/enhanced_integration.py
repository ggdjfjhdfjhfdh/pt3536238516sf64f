#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Integrador principal para las mejoras de detecci√≥n de tecnolog√≠as.
Conecta el sistema mejorado con el pipeline existente en core.py.
"""

import logging
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict

# Importar m√≥dulos existentes
try:
    from .fingerprint import TechDetector
except ImportError:
    try:
        from fingerprint import TechDetector
    except ImportError:
        # Fallback si no existe el m√≥dulo original
        TechDetector = None

# Importar nuevos m√≥dulos
try:
    from .enhanced_fingerprint import EnhancedTechDetector
    from .tech_mapping import TechMapper
    from .metrics import TechDetectionMetrics
    from .tool_validator import ExternalToolValidator, ToolStatus
except ImportError:
    from enhanced_fingerprint import EnhancedTechDetector
    from tech_mapping import TechMapper
    from metrics import TechDetectionMetrics
    from tool_validator import ExternalToolValidator, ToolStatus

log = logging.getLogger(__name__)

@dataclass
class EnhancedDetectionResult:
    """Resultado mejorado de detecci√≥n de tecnolog√≠as."""
    url: str
    technologies: List[Dict[str, Any]]
    security_analysis: Dict[str, Any]
    performance_metrics: Dict[str, Any]
    tool_coverage: Dict[str, bool]
    confidence_score: float
    detection_time: float
    recommendations: List[str]
    vulnerabilities_found: List[Dict[str, Any]]
    
class EnhancedTechIntegrator:
    """Integrador principal para el sistema mejorado de detecci√≥n."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self.enhanced_detector = None
        self.tech_mapper = None
        self.metrics = None
        self.validator = None
        self.legacy_detector = None
        self.initialized = False
        
        # Configuraci√≥n por defecto
        self.default_config = {
            "enable_enhanced_detection": True,
            "enable_legacy_fallback": True,
            "enable_parallel_detection": True,
            "enable_security_analysis": True,
            "enable_metrics": True,
            "enable_web_content_analysis": True,
            "cache_enabled": True,
            "cache_ttl": 3600,
            "max_workers": 4,
            "timeout": 30,
            "confidence_threshold": 0.7,
            "validate_tools_on_startup": True
        }
        
        # Combinar configuraci√≥n
        self.config = {**self.default_config, **self.config}
        
    def initialize(self) -> bool:
        """Inicializa todos los componentes del sistema mejorado."""
        try:
            log.info("üöÄ Inicializando sistema mejorado de detecci√≥n de tecnolog√≠as...")
            
            # 1. Validar herramientas externas
            if self.config.get("validate_tools_on_startup", True):
                self._validate_external_tools()
            
            # 2. Inicializar detector mejorado
            self._initialize_enhanced_detector()
            
            # 3. Inicializar mapeador de tecnolog√≠as
            self._initialize_tech_mapper()
            
            # 4. Inicializar sistema de m√©tricas
            if self.config.get("enable_metrics", True):
                self._initialize_metrics()
            
            # 5. Inicializar detector legacy como fallback
            if self.config.get("enable_legacy_fallback", True):
                self._initialize_legacy_detector()
            
            self.initialized = True
            log.info("‚úÖ Sistema mejorado inicializado correctamente")
            return True
            
        except Exception as e:
            log.error(f"‚ùå Error inicializando sistema mejorado: {e}")
            return False
    
    def _validate_external_tools(self) -> None:
        """Valida herramientas externas."""
        log.info("üîç Validando herramientas externas...")
        
        self.validator = ExternalToolValidator(
            timeout=self.config.get("timeout", 30)
        )
        
        tools_info = self.validator.validate_all_tools()
        available_tools = self.validator.get_available_tools()
        
        if not available_tools:
            log.warning("‚ö†Ô∏è No hay herramientas externas disponibles, usando solo detecci√≥n b√°sica")
        else:
            log.info(f"‚úÖ Herramientas disponibles: {', '.join(available_tools)}")
    
    def _initialize_enhanced_detector(self) -> None:
        """Inicializa el detector mejorado."""
        log.info("üîß Inicializando detector mejorado...")
        
        detector_config = {
            "cache_enabled": self.config.get("cache_enabled", True),
            "cache_ttl": self.config.get("cache_ttl", 3600),
            "max_workers": self.config.get("max_workers", 4),
            "timeout": self.config.get("timeout", 30),
            "enable_parallel": self.config.get("enable_parallel_detection", True),
            "enable_web_content_analysis": self.config.get("enable_web_content_analysis", True)
        }
        
        self.enhanced_detector = EnhancedTechDetector(config=detector_config)
        
        # Configurar herramientas disponibles
        if self.validator:
            available_tools = self.validator.get_available_tools()
            self.enhanced_detector.set_available_tools(available_tools)
    
    def _initialize_tech_mapper(self) -> None:
        """Inicializa el mapeador de tecnolog√≠as."""
        log.info("üó∫Ô∏è Inicializando mapeador de tecnolog√≠as...")
        
        # Buscar archivo de configuraci√≥n
        config_paths = [
            Path("pentest/tech_mappings.yaml"),
            Path("tech_mappings.yaml"),
            Path("config/tech_mappings.yaml")
        ]
        
        config_file = None
        for path in config_paths:
            if path.exists():
                config_file = str(path)
                break
        
        if not config_file:
            log.warning("‚ö†Ô∏è No se encontr√≥ archivo de configuraci√≥n de mapeos, usando configuraci√≥n por defecto")
        
        self.tech_mapper = TechMapper(config_file=config_file)
    
    def _initialize_metrics(self) -> None:
        """Inicializa el sistema de m√©tricas."""
        log.info("üìä Inicializando sistema de m√©tricas...")
        
        self.metrics = TechDetectionMetrics()
    
    def _initialize_legacy_detector(self) -> None:
        """Inicializa el detector legacy como fallback."""
        if TechDetector:
            log.info("üîÑ Inicializando detector legacy como fallback...")
            try:
                self.legacy_detector = TechDetector()
                log.info("‚úÖ Detector legacy inicializado")
            except Exception as e:
                log.warning(f"‚ö†Ô∏è No se pudo inicializar detector legacy: {e}")
        else:
            log.info("‚ÑπÔ∏è Detector legacy no disponible")
    
    def detect_technologies(self, url: str, **kwargs) -> EnhancedDetectionResult:
        """Detecta tecnolog√≠as usando el sistema mejorado."""
        if not self.initialized:
            if not self.initialize():
                raise RuntimeError("No se pudo inicializar el sistema mejorado")
        
        start_time = time.time()
        
        try:
            # 1. Detecci√≥n mejorada
            enhanced_result = self._run_enhanced_detection(url, **kwargs)
            
            # 2. An√°lisis de seguridad
            security_analysis = self._run_security_analysis(url, enhanced_result)
            
            # 3. Generar recomendaciones
            recommendations = self._generate_recommendations(enhanced_result, security_analysis)
            
            # 4. Calcular m√©tricas
            performance_metrics = self._calculate_performance_metrics(start_time)
            
            # 5. Registrar m√©tricas
            if self.metrics:
                self._record_metrics(url, enhanced_result, performance_metrics)
            
            # 6. Crear resultado final
            result = EnhancedDetectionResult(
                url=url,
                technologies=enhanced_result.get("technologies", []),
                security_analysis=security_analysis,
                performance_metrics=performance_metrics,
                tool_coverage=enhanced_result.get("tool_coverage", {}),
                confidence_score=enhanced_result.get("confidence_score", 0.0),
                detection_time=time.time() - start_time,
                recommendations=recommendations,
                vulnerabilities_found=security_analysis.get("vulnerabilities", [])
            )
            
            log.info(f"‚úÖ Detecci√≥n completada para {url} en {result.detection_time:.2f}s")
            return result
            
        except Exception as e:
            log.error(f"‚ùå Error en detecci√≥n mejorada para {url}: {e}")
            
            # Fallback a detector legacy
            if self.config.get("enable_legacy_fallback", True):
                return self._fallback_detection(url, start_time, **kwargs)
            else:
                raise
    
    def _run_enhanced_detection(self, url: str, **kwargs) -> Dict[str, Any]:
        """Ejecuta detecci√≥n mejorada."""
        if not self.enhanced_detector:
            raise RuntimeError("Detector mejorado no inicializado")
        
        # Configurar opciones de detecci√≥n
        detection_options = {
            "enable_parallel": self.config.get("enable_parallel_detection", True),
            "confidence_threshold": self.config.get("confidence_threshold", 0.7),
            **kwargs
        }
        
        return self.enhanced_detector.detect_technologies(url, **detection_options)
    
    def _run_security_analysis(self, url: str, detection_result: Dict[str, Any]) -> Dict[str, Any]:
        """Ejecuta an√°lisis de seguridad basado en tecnolog√≠as detectadas."""
        if not self.config.get("enable_security_analysis", True) or not self.tech_mapper:
            return {"enabled": False, "vulnerabilities": []}
        
        try:
            technologies = detection_result.get("technologies", [])
            security_analysis = self.tech_mapper.get_security_analysis(technologies)
            
            return {
                "enabled": True,
                "vulnerabilities": security_analysis.get("vulnerabilities", []),
                "security_headers": security_analysis.get("security_headers", {}),
                "recommendations": security_analysis.get("recommendations", []),
                "risk_score": security_analysis.get("risk_score", 0)
            }
            
        except Exception as e:
            log.error(f"Error en an√°lisis de seguridad: {e}")
            return {"enabled": True, "error": str(e), "vulnerabilities": []}
    
    def _generate_recommendations(self, detection_result: Dict[str, Any], security_analysis: Dict[str, Any]) -> List[str]:
        """Genera recomendaciones basadas en los resultados."""
        recommendations = []
        
        try:
            # Recomendaciones de seguridad
            if security_analysis.get("enabled", False):
                recommendations.extend(security_analysis.get("recommendations", []))
            
            # Recomendaciones de rendimiento
            technologies = detection_result.get("technologies", [])
            for tech in technologies:
                if tech.get("name") == "jQuery" and tech.get("version", "").startswith("1."):
                    recommendations.append("Considerar actualizar jQuery a una versi√≥n m√°s reciente")
                
                if tech.get("name") == "WordPress" and "version" in tech:
                    recommendations.append("Verificar que WordPress est√© actualizado a la √∫ltima versi√≥n")
            
            # Recomendaciones de herramientas
            tool_coverage = detection_result.get("tool_coverage", {})
            missing_tools = [tool for tool, available in tool_coverage.items() if not available]
            if missing_tools:
                recommendations.append(f"Instalar herramientas faltantes para mejor detecci√≥n: {', '.join(missing_tools)}")
            
        except Exception as e:
            log.error(f"Error generando recomendaciones: {e}")
        
        return recommendations
    
    def _calculate_performance_metrics(self, start_time: float) -> Dict[str, Any]:
        """Calcula m√©tricas de rendimiento."""
        return {
            "total_time": time.time() - start_time,
            "timestamp": time.time(),
            "tools_used": self.validator.get_available_tools() if self.validator else [],
            "cache_enabled": self.config.get("cache_enabled", False),
            "parallel_enabled": self.config.get("enable_parallel_detection", False)
        }
    
    def _record_metrics(self, url: str, detection_result: Dict[str, Any], performance_metrics: Dict[str, Any]) -> None:
        """Registra m√©tricas en el sistema de monitoreo."""
        if not self.metrics:
            return
        
        try:
            technologies = detection_result.get("technologies", [])
            confidence_score = detection_result.get("confidence_score", 0.0)
            detection_time = performance_metrics.get("total_time", 0.0)
            
            self.metrics.record_detection(
                url=url,
                technologies_found=len(technologies),
                confidence_score=confidence_score,
                detection_time=detection_time,
                tools_used=performance_metrics.get("tools_used", [])
            )
            
        except Exception as e:
            log.error(f"Error registrando m√©tricas: {e}")
    
    def _fallback_detection(self, url: str, start_time: float, **kwargs) -> EnhancedDetectionResult:
        """Ejecuta detecci√≥n usando el sistema legacy como fallback."""
        log.warning(f"üîÑ Usando detecci√≥n legacy para {url}")
        
        try:
            if self.legacy_detector:
                legacy_result = self.legacy_detector.detect_technologies(url)
                
                # Convertir resultado legacy al formato mejorado
                technologies = legacy_result.get("technologies", [])
                
                return EnhancedDetectionResult(
                    url=url,
                    technologies=technologies,
                    security_analysis={"enabled": False, "fallback": True},
                    performance_metrics={
                        "total_time": time.time() - start_time,
                        "fallback_used": True
                    },
                    tool_coverage={},
                    confidence_score=0.5,  # Confianza reducida para fallback
                    detection_time=time.time() - start_time,
                    recommendations=["Sistema mejorado no disponible, usando detecci√≥n b√°sica"],
                    vulnerabilities_found=[]
                )
            else:
                # Sin detector disponible
                return EnhancedDetectionResult(
                    url=url,
                    technologies=[],
                    security_analysis={"enabled": False, "error": "No hay detectores disponibles"},
                    performance_metrics={"total_time": time.time() - start_time, "error": True},
                    tool_coverage={},
                    confidence_score=0.0,
                    detection_time=time.time() - start_time,
                    recommendations=["Instalar herramientas de detecci√≥n de tecnolog√≠as"],
                    vulnerabilities_found=[]
                )
                
        except Exception as e:
            log.error(f"Error en detecci√≥n fallback: {e}")
            raise
    
    def get_system_status(self) -> Dict[str, Any]:
        """Obtiene el estado del sistema mejorado."""
        status = {
            "initialized": self.initialized,
            "enhanced_detector": self.enhanced_detector is not None,
            "tech_mapper": self.tech_mapper is not None,
            "metrics": self.metrics is not None,
            "legacy_detector": self.legacy_detector is not None,
            "config": self.config
        }
        
        if self.validator:
            status["external_tools"] = {
                "available": self.validator.get_available_tools(),
                "total_validated": len(self.validator.tools_info)
            }
        
        if self.metrics:
            status["metrics_summary"] = self.metrics.get_summary()
        
        return status
    
    def export_metrics(self, output_path: str) -> None:
        """Exporta m√©tricas del sistema."""
        if self.metrics:
            self.metrics.export_metrics(output_path)
            log.info(f"üìä M√©tricas exportadas a: {output_path}")
        else:
            log.warning("‚ö†Ô∏è Sistema de m√©tricas no inicializado")
    
    def reset_metrics(self) -> None:
        """Reinicia las m√©tricas del sistema."""
        if self.metrics:
            self.metrics.reset_metrics()
            log.info("üîÑ M√©tricas reiniciadas")
        else:
            log.warning("‚ö†Ô∏è Sistema de m√©tricas no inicializado")


# Funci√≥n de conveniencia para integraci√≥n con core.py
def create_enhanced_integrator(config: Optional[Dict[str, Any]] = None) -> EnhancedTechIntegrator:
    """Crea una instancia del integrador mejorado."""
    return EnhancedTechIntegrator(config=config)


# Funci√≥n de compatibilidad con la API existente
def detect_technologies_enhanced(url: str, config: Optional[Dict[str, Any]] = None, **kwargs) -> Dict[str, Any]:
    """Funci√≥n de compatibilidad para detecci√≥n mejorada."""
    integrator = create_enhanced_integrator(config)
    result = integrator.detect_technologies(url, **kwargs)
    
    # Convertir a formato compatible
    return {
        "url": result.url,
        "technologies": result.technologies,
        "security_analysis": result.security_analysis,
        "performance_metrics": result.performance_metrics,
        "confidence_score": result.confidence_score,
        "detection_time": result.detection_time,
        "recommendations": result.recommendations,
        "enhanced": True
    }


if __name__ == "__main__":
    # Ejemplo de uso
    logging.basicConfig(level=logging.INFO)
    
    # Crear integrador
    integrator = create_enhanced_integrator()
    
    # Obtener estado del sistema
    status = integrator.get_system_status()
    print("\nüîç Estado del sistema:")
    print(json.dumps(status, indent=2))
    
    # Ejemplo de detecci√≥n
    if integrator.initialized:
        test_url = "https://example.com"
        print(f"\nüéØ Probando detecci√≥n en: {test_url}")
        
        try:
            result = integrator.detect_technologies(test_url)
            print(f"‚úÖ Tecnolog√≠as encontradas: {len(result.technologies)}")
            print(f"üìä Tiempo de detecci√≥n: {result.detection_time:.2f}s")
            print(f"üéØ Puntuaci√≥n de confianza: {result.confidence_score:.2f}")
        except Exception as e:
            print(f"‚ùå Error en detecci√≥n: {e}")