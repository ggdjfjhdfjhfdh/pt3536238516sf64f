#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de Escaneo Premium Adaptativo basado en detección de CMS y tecnologías.
Implementa escaneos profundos específicos según la tecnología detectada.
"""

import json
import logging
import subprocess
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Set, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse
from dataclasses import dataclass

# Importaciones locales
try:
    from .enhanced_fingerprint import EnhancedTechDetector
    from .tech_mapping import TechMapper
    from .runners import run_cmd
    from .config import DEFAULT_TIMEOUT
    from .api_scanner import APIScanner
    from .container_scanner import ContainerScanner
except ImportError:
    from enhanced_fingerprint import EnhancedTechDetector
    from tech_mapping import TechMapper
    from runners import run_cmd
    from config import DEFAULT_TIMEOUT
    from api_scanner import APIScanner
    from container_scanner import ContainerScanner

log = logging.getLogger(__name__)

@dataclass
class PremiumScanResult:
    """Resultado completo del escaneo premium adaptativo."""
    target: str
    detected_technologies: Dict[str, Any]
    cms_specific_scans: Dict[str, Any]
    framework_specific_scans: Dict[str, Any]
    api_specific_scans: Dict[str, Any]
    container_scans: Dict[str, Any]
    advanced_vulnerability_scans: Dict[str, Any]
    security_assessment: Dict[str, Any]
    scan_duration: float
    confidence_score: float
    recommendations: List[str]

class CMSSpecificScanner:
    """Escáner específico para diferentes CMS."""
    
    def __init__(self):
        self.cms_scanners = {
            'wordpress': self._scan_wordpress,
            'drupal': self._scan_drupal,
            'joomla': self._scan_joomla,
            'magento': self._scan_magento,
            'prestashop': self._scan_prestashop,
            'opencart': self._scan_opencart
        }
    
    def scan_cms(self, cms_name: str, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Ejecuta escaneo específico para el CMS detectado."""
        cms_lower = cms_name.lower()
        
        if cms_lower in self.cms_scanners:
            log.info(f"Ejecutando escaneo específico para {cms_name} en {target}")
            return self.cms_scanners[cms_lower](target, output_dir, **kwargs)
        else:
            log.warning(f"No hay escáner específico para {cms_name}")
            return self._generic_cms_scan(target, output_dir, **kwargs)
    
    def _scan_wordpress(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para WordPress usando WPScan."""
        results = {
            'cms': 'WordPress',
            'vulnerabilities': [],
            'plugins': [],
            'themes': [],
            'users': [],
            'config_issues': [],
            'security_headers': {},
            'scan_status': 'completed'
        }
        
        try:
            # WPScan básico
            wpscan_file = output_dir / f"wpscan_{int(time.time())}.json"
            wpscan_cmd = [
                'wpscan',
                '--url', target,
                '--format', 'json',
                '--output', str(wpscan_file),
                '--enumerate', 'p,t,u',  # plugins, themes, users
                '--plugins-detection', 'aggressive',
                '--themes-detection', 'aggressive',
                '--random-user-agent',
                '--disable-tls-checks'
            ]
            
            # Agregar API token si está disponible
            api_token = kwargs.get('wpscan_api_token')
            if api_token:
                wpscan_cmd.extend(['--api-token', api_token])
            
            log.info(f"Ejecutando WPScan: {' '.join(wpscan_cmd)}")
            result = subprocess.run(
                wpscan_cmd,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minutos
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if wpscan_file.exists():
                with open(wpscan_file, 'r', encoding='utf-8') as f:
                    wpscan_data = json.load(f)
                
                # Procesar resultados de WPScan
                results.update(self._process_wpscan_results(wpscan_data))
            
            # Escaneos adicionales específicos de WordPress
            results.update(self._wordpress_additional_checks(target, output_dir))
            
        except subprocess.TimeoutExpired:
            log.error(f"WPScan timeout para {target}")
            results['scan_status'] = 'timeout'
        except Exception as e:
            log.error(f"Error en escaneo WordPress para {target}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_drupal(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Drupal usando Droopescan."""
        results = {
            'cms': 'Drupal',
            'vulnerabilities': [],
            'modules': [],
            'themes': [],
            'version': '',
            'config_issues': [],
            'scan_status': 'completed'
        }
        
        try:
            # Droopescan
            droope_file = output_dir / f"droopescan_{int(time.time())}.json"
            droope_cmd = [
                'droopescan',
                'scan', 'drupal',
                '-u', target,
                '--output', 'json',
                '--save', str(droope_file)
            ]
            
            log.info(f"Ejecutando Droopescan: {' '.join(droope_cmd)}")
            result = subprocess.run(
                droope_cmd,
                capture_output=True,
                text=True,
                timeout=300,
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if droope_file.exists():
                with open(droope_file, 'r', encoding='utf-8') as f:
                    droope_data = json.load(f)
                results.update(self._process_droopescan_results(droope_data))
            
            # Escaneos adicionales específicos de Drupal
            results.update(self._drupal_additional_checks(target, output_dir))
            
        except subprocess.TimeoutExpired:
            log.error(f"Droopescan timeout para {target}")
            results['scan_status'] = 'timeout'
        except Exception as e:
            log.error(f"Error en escaneo Drupal para {target}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_joomla(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Joomla usando JoomScan."""
        results = {
            'cms': 'Joomla',
            'vulnerabilities': [],
            'extensions': [],
            'version': '',
            'config_issues': [],
            'scan_status': 'completed'
        }
        
        try:
            # JoomScan (si está disponible) o CMSmap
            joom_file = output_dir / f"joomscan_{int(time.time())}.txt"
            
            # Intentar con JoomScan primero
            joom_cmd = [
                'joomscan',
                '-u', target,
                '--output', str(joom_file)
            ]
            
            log.info(f"Ejecutando JoomScan: {' '.join(joom_cmd)}")
            result = subprocess.run(
                joom_cmd,
                capture_output=True,
                text=True,
                timeout=300,
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if joom_file.exists():
                results.update(self._process_joomscan_results(joom_file))
            
            # Fallback a CMSmap si JoomScan no está disponible
            if result.returncode != 0:
                results.update(self._cmsmap_scan(target, 'joomla', output_dir))
            
        except Exception as e:
            log.error(f"Error en escaneo Joomla para {target}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_magento(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Magento."""
        results = {
            'cms': 'Magento',
            'vulnerabilities': [],
            'modules': [],
            'version': '',
            'config_issues': [],
            'scan_status': 'completed'
        }
        
        try:
            # Usar CMSmap para Magento
            results.update(self._cmsmap_scan(target, 'magento', output_dir))
            
            # Checks específicos de Magento
            results.update(self._magento_specific_checks(target, output_dir))
            
        except Exception as e:
            log.error(f"Error en escaneo Magento para {target}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_prestashop(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para PrestaShop."""
        return self._cmsmap_scan(target, 'prestashop', output_dir)
    
    def _scan_opencart(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para OpenCart."""
        return self._cmsmap_scan(target, 'opencart', output_dir)
    
    def _generic_cms_scan(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo genérico usando CMSmap."""
        return self._cmsmap_scan(target, 'auto', output_dir)
    
    def _cmsmap_scan(self, target: str, cms_type: str, output_dir: Path) -> Dict[str, Any]:
        """Escaneo usando CMSmap."""
        results = {
            'cms': cms_type,
            'vulnerabilities': [],
            'scan_status': 'completed'
        }
        
        try:
            cmsmap_file = output_dir / f"cmsmap_{cms_type}_{int(time.time())}.txt"
            cmsmap_cmd = [
                'cmsmap',
                '-t', target,
                '-o', str(cmsmap_file)
            ]
            
            if cms_type != 'auto':
                cmsmap_cmd.extend(['-f', cms_type])
            
            log.info(f"Ejecutando CMSmap: {' '.join(cmsmap_cmd)}")
            result = subprocess.run(
                cmsmap_cmd,
                capture_output=True,
                text=True,
                timeout=300,
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if cmsmap_file.exists():
                results.update(self._process_cmsmap_results(cmsmap_file))
            
        except Exception as e:
            log.error(f"Error en CMSmap para {target}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _process_wpscan_results(self, data: Dict) -> Dict[str, Any]:
        """Procesa resultados de WPScan."""
        processed = {
            'vulnerabilities': [],
            'plugins': [],
            'themes': [],
            'users': [],
            'version': ''
        }
        
        # Procesar versión de WordPress
        if 'version' in data:
            processed['version'] = data['version'].get('number', '')
        
        # Procesar vulnerabilidades
        if 'vulnerabilities' in data:
            for vuln in data['vulnerabilities']:
                processed['vulnerabilities'].append({
                    'title': vuln.get('title', ''),
                    'type': vuln.get('type', ''),
                    'references': vuln.get('references', {})
                })
        
        # Procesar plugins
        if 'plugins' in data:
            for plugin_name, plugin_data in data['plugins'].items():
                processed['plugins'].append({
                    'name': plugin_name,
                    'version': plugin_data.get('version', {}).get('number', ''),
                    'vulnerabilities': len(plugin_data.get('vulnerabilities', []))
                })
        
        # Procesar temas
        if 'themes' in data:
            for theme_name, theme_data in data['themes'].items():
                processed['themes'].append({
                    'name': theme_name,
                    'version': theme_data.get('version', {}).get('number', ''),
                    'vulnerabilities': len(theme_data.get('vulnerabilities', []))
                })
        
        # Procesar usuarios
        if 'users' in data:
            for user_id, user_data in data['users'].items():
                processed['users'].append({
                    'id': user_id,
                    'username': user_data.get('username', ''),
                    'display_name': user_data.get('display_name', '')
                })
        
        return processed
    
    def _process_droopescan_results(self, data: Dict) -> Dict[str, Any]:
        """Procesa resultados de Droopescan."""
        processed = {
            'modules': [],
            'themes': [],
            'version': ''
        }
        
        # Procesar según estructura de Droopescan
        if isinstance(data, list) and data:
            scan_result = data[0]  # Primer resultado
            
            if 'plugins' in scan_result:
                processed['modules'] = scan_result['plugins']
            
            if 'themes' in scan_result:
                processed['themes'] = scan_result['themes']
            
            if 'version' in scan_result:
                processed['version'] = scan_result['version']
        
        return processed
    
    def _process_joomscan_results(self, file_path: Path) -> Dict[str, Any]:
        """Procesa resultados de JoomScan."""
        processed = {
            'extensions': [],
            'version': '',
            'vulnerabilities': []
        }
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parsear contenido de JoomScan (formato texto)
            lines = content.split('\n')
            for line in lines:
                if 'Joomla version' in line:
                    processed['version'] = line.split(':')[-1].strip()
                elif 'Extension' in line and 'found' in line:
                    processed['extensions'].append(line.strip())
                elif 'Vulnerability' in line or 'CVE' in line:
                    processed['vulnerabilities'].append(line.strip())
        
        except Exception as e:
            log.error(f"Error procesando resultados JoomScan: {e}")
        
        return processed
    
    def _process_cmsmap_results(self, file_path: Path) -> Dict[str, Any]:
        """Procesa resultados de CMSmap."""
        processed = {
            'vulnerabilities': [],
            'modules': [],
            'version': ''
        }
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Parsear contenido de CMSmap
            lines = content.split('\n')
            for line in lines:
                if 'Version' in line:
                    processed['version'] = line.split(':')[-1].strip()
                elif 'Vulnerability' in line or 'CVE' in line:
                    processed['vulnerabilities'].append(line.strip())
                elif 'Module' in line or 'Plugin' in line:
                    processed['modules'].append(line.strip())
        
        except Exception as e:
            log.error(f"Error procesando resultados CMSmap: {e}")
        
        return processed
    
    def _wordpress_additional_checks(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Checks adicionales específicos de WordPress."""
        additional = {
            'config_issues': [],
            'security_headers': {}
        }
        
        try:
            # Check de archivos sensibles
            sensitive_files = [
                '/wp-config.php.bak',
                '/wp-config.php~',
                '/wp-config.txt',
                '/.wp-config.php.swp',
                '/wp-admin/install.php',
                '/readme.html',
                '/license.txt'
            ]
            
            for file_path in sensitive_files:
                try:
                    import requests
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        additional['config_issues'].append(f"Archivo sensible expuesto: {file_path}")
                except:
                    pass
            
            # Check de headers de seguridad
            try:
                import requests
                response = requests.head(target, timeout=10)
                headers = response.headers
                
                security_headers = [
                    'X-Frame-Options',
                    'X-Content-Type-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security',
                    'Content-Security-Policy'
                ]
                
                for header in security_headers:
                    additional['security_headers'][header] = headers.get(header, 'Missing')
            except:
                pass
        
        except Exception as e:
            log.error(f"Error en checks adicionales WordPress: {e}")
        
        return additional
    
    def _drupal_additional_checks(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Checks adicionales específicos de Drupal."""
        additional = {
            'config_issues': []
        }
        
        try:
            # Check de archivos sensibles de Drupal
            sensitive_files = [
                '/CHANGELOG.txt',
                '/COPYRIGHT.txt',
                '/INSTALL.txt',
                '/LICENSE.txt',
                '/MAINTAINERS.txt',
                '/UPGRADE.txt',
                '/sites/default/settings.php',
                '/sites/default/files/.htaccess'
            ]
            
            for file_path in sensitive_files:
                try:
                    import requests
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        additional['config_issues'].append(f"Archivo sensible expuesto: {file_path}")
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en checks adicionales Drupal: {e}")
        
        return additional
    
    def _magento_specific_checks(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Checks específicos de Magento."""
        additional = {
            'config_issues': [],
            'admin_panel': ''
        }
        
        try:
            # Check de panel de administración
            admin_paths = ['/admin', '/backend', '/administrator', '/admin_panel']
            
            for admin_path in admin_paths:
                try:
                    import requests
                    response = requests.get(f"{target.rstrip('/')}{admin_path}", timeout=10)
                    if response.status_code == 200 and 'magento' in response.text.lower():
                        additional['admin_panel'] = admin_path
                        break
                except:
                    pass
            
            # Check de archivos sensibles
            sensitive_files = [
                '/app/etc/local.xml',
                '/app/etc/config.xml',
                '/downloader/',
                '/dev/',
                '/var/log/'
            ]
            
            for file_path in sensitive_files:
                try:
                    import requests
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        additional['config_issues'].append(f"Directorio/archivo sensible: {file_path}")
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en checks específicos Magento: {e}")
        
        return additional

class FrameworkSpecificScanner:
    """Escáner específico para frameworks web."""
    
    def __init__(self):
        self.framework_scanners = {
            'laravel': self._scan_laravel,
            'django': self._scan_django,
            'flask': self._scan_flask,
            'spring': self._scan_spring,
            'rails': self._scan_rails,
            'express': self._scan_express,
            'react': self._scan_react,
            'vue': self._scan_vue,
            'angular': self._scan_angular
        }
    
    def scan_framework(self, framework_name: str, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Ejecuta escaneo específico para el framework detectado."""
        framework_lower = framework_name.lower()
        
        if framework_lower in self.framework_scanners:
            log.info(f"Ejecutando escaneo específico para {framework_name} en {target}")
            return self.framework_scanners[framework_lower](target, output_dir, **kwargs)
        else:
            log.warning(f"No hay escáner específico para {framework_name}")
            return self._generic_framework_scan(target, output_dir, **kwargs)
    
    def _scan_laravel(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Laravel."""
        results = {
            'framework': 'Laravel',
            'vulnerabilities': [],
            'config_issues': [],
            'debug_mode': False,
            'exposed_files': [],
            'scan_status': 'completed'
        }
        
        try:
            # Check de debug mode
            import requests
            response = requests.get(target, timeout=10)
            if 'laravel_session' in response.cookies or 'APP_DEBUG' in response.text:
                results['debug_mode'] = True
                results['config_issues'].append('Debug mode posiblemente habilitado')
            
            # Check de archivos sensibles de Laravel
            sensitive_files = [
                '/.env',
                '/.env.example',
                '/storage/logs/laravel.log',
                '/artisan',
                '/composer.json',
                '/composer.lock',
                '/config/app.php'
            ]
            
            for file_path in sensitive_files:
                try:
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        results['exposed_files'].append(file_path)
                        if file_path == '/.env':
                            results['config_issues'].append('Archivo .env expuesto - CRÍTICO')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Laravel: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_django(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Django."""
        results = {
            'framework': 'Django',
            'vulnerabilities': [],
            'config_issues': [],
            'debug_mode': False,
            'admin_panel': '',
            'scan_status': 'completed'
        }
        
        try:
            # Check de debug mode
            import requests
            response = requests.get(target, timeout=10)
            if 'django' in response.headers.get('Server', '').lower() or 'csrftoken' in response.cookies:
                if 'DEBUG = True' in response.text or 'DisallowedHost' in response.text:
                    results['debug_mode'] = True
                    results['config_issues'].append('Debug mode habilitado')
            
            # Check de panel de administración
            admin_paths = ['/admin/', '/admin', '/django-admin/']
            for admin_path in admin_paths:
                try:
                    response = requests.get(f"{target.rstrip('/')}{admin_path}", timeout=10)
                    if response.status_code == 200 and 'django' in response.text.lower():
                        results['admin_panel'] = admin_path
                        break
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Django: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_flask(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Flask."""
        results = {
            'framework': 'Flask',
            'vulnerabilities': [],
            'config_issues': [],
            'debug_mode': False,
            'scan_status': 'completed'
        }
        
        try:
            # Check de debug mode
            import requests
            response = requests.get(target, timeout=10)
            if 'werkzeug' in response.headers.get('Server', '').lower():
                results['config_issues'].append('Servidor Werkzeug detectado (posible desarrollo)')
            
            # Check de rutas comunes de Flask
            flask_routes = ['/debug', '/console', '/_debug_toolbar']
            for route in flask_routes:
                try:
                    response = requests.get(f"{target.rstrip('/')}{route}", timeout=10)
                    if response.status_code == 200:
                        results['config_issues'].append(f'Ruta de debug expuesta: {route}')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Flask: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_spring(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Spring Boot."""
        results = {
            'framework': 'Spring Boot',
            'vulnerabilities': [],
            'config_issues': [],
            'actuator_endpoints': [],
            'scan_status': 'completed'
        }
        
        try:
            # Check de Spring Boot Actuator
            actuator_endpoints = [
                '/actuator',
                '/actuator/health',
                '/actuator/info',
                '/actuator/env',
                '/actuator/configprops',
                '/actuator/beans',
                '/actuator/mappings',
                '/actuator/trace',
                '/actuator/dump',
                '/actuator/shutdown'
            ]
            
            import requests
            for endpoint in actuator_endpoints:
                try:
                    response = requests.get(f"{target.rstrip('/')}{endpoint}", timeout=10)
                    if response.status_code == 200:
                        results['actuator_endpoints'].append(endpoint)
                        if endpoint in ['/actuator/env', '/actuator/configprops', '/actuator/shutdown']:
                            results['config_issues'].append(f'Endpoint sensible expuesto: {endpoint}')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Spring Boot: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_rails(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Ruby on Rails."""
        results = {
            'framework': 'Ruby on Rails',
            'vulnerabilities': [],
            'config_issues': [],
            'debug_mode': False,
            'scan_status': 'completed'
        }
        
        try:
            # Check de archivos sensibles de Rails
            import requests
            sensitive_files = [
                '/config/database.yml',
                '/config/secrets.yml',
                '/log/development.log',
                '/log/production.log',
                '/Gemfile',
                '/Gemfile.lock'
            ]
            
            for file_path in sensitive_files:
                try:
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        results['config_issues'].append(f'Archivo sensible expuesto: {file_path}')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Rails: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_express(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Express.js."""
        results = {
            'framework': 'Express.js',
            'vulnerabilities': [],
            'config_issues': [],
            'scan_status': 'completed'
        }
        
        try:
            # Check de headers específicos de Express
            import requests
            response = requests.get(target, timeout=10)
            
            if 'express' in response.headers.get('X-Powered-By', '').lower():
                results['config_issues'].append('Header X-Powered-By expone Express.js')
            
            # Check de archivos sensibles de Node.js/Express
            sensitive_files = [
                '/package.json',
                '/package-lock.json',
                '/.env',
                '/node_modules/',
                '/npm-debug.log'
            ]
            
            for file_path in sensitive_files:
                try:
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        results['config_issues'].append(f'Archivo/directorio sensible: {file_path}')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo Express.js: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _scan_react(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para React."""
        return self._scan_spa_framework(target, 'React', output_dir)
    
    def _scan_vue(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Vue.js."""
        return self._scan_spa_framework(target, 'Vue.js', output_dir)
    
    def _scan_angular(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo específico para Angular."""
        return self._scan_spa_framework(target, 'Angular', output_dir)
    
    def _scan_spa_framework(self, target: str, framework_name: str, output_dir: Path) -> Dict[str, Any]:
        """Escaneo genérico para frameworks SPA."""
        results = {
            'framework': framework_name,
            'vulnerabilities': [],
            'config_issues': [],
            'source_maps': [],
            'scan_status': 'completed'
        }
        
        try:
            # Check de source maps expuestos
            import requests
            response = requests.get(target, timeout=10)
            
            # Buscar referencias a source maps en el HTML
            if '.js.map' in response.text or '.css.map' in response.text:
                results['config_issues'].append('Source maps posiblemente expuestos')
            
            # Check de archivos de configuración comunes
            config_files = [
                '/webpack.config.js',
                '/package.json',
                '/.babelrc',
                '/tsconfig.json',
                '/angular.json',
                '/vue.config.js'
            ]
            
            for file_path in config_files:
                try:
                    response = requests.get(f"{target.rstrip('/')}{file_path}", timeout=10)
                    if response.status_code == 200:
                        results['config_issues'].append(f'Archivo de configuración expuesto: {file_path}')
                except:
                    pass
        
        except Exception as e:
            log.error(f"Error en escaneo {framework_name}: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _generic_framework_scan(self, target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo genérico para frameworks no específicos."""
        results = {
            'framework': 'Generic',
            'vulnerabilities': [],
            'config_issues': [],
            'scan_status': 'completed'
        }
        
        try:
            # Checks genéricos de seguridad
            import requests
            response = requests.get(target, timeout=10)
            
            # Check de headers de seguridad
            security_headers = [
                'X-Frame-Options',
                'X-Content-Type-Options',
                'X-XSS-Protection',
                'Strict-Transport-Security',
                'Content-Security-Policy'
            ]
            
            for header in security_headers:
                if header not in response.headers:
                    results['config_issues'].append(f'Header de seguridad faltante: {header}')
        
        except Exception as e:
            log.error(f"Error en escaneo genérico: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results

class PremiumAdaptiveScanner:
    """Escáner premium adaptativo principal."""
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {}
        self.tech_detector = EnhancedTechDetector(
            use_cache=self.config.get('use_cache', True),
            enable_web_content_analysis=self.config.get('enable_web_content_analysis', True)
        )
        self.cms_scanner = CMSSpecificScanner()
        self.framework_scanner = FrameworkSpecificScanner()
        self.tech_mapper = TechMapper()
        self.api_scanner = APIScanner()
        self.container_scanner = ContainerScanner()
    
    def premium_scan(self, target: str, output_dir: Path, **kwargs) -> PremiumScanResult:
        """Ejecuta escaneo premium adaptativo completo."""
        start_time = time.time()
        
        log.info(f"Iniciando escaneo premium adaptativo para {target}")
        
        # Paso 1: Detección de tecnologías
        log.info("Paso 1: Detección de tecnologías")
        tech_detection = self.tech_detector.detect_technologies(target)
        detected_technologies = tech_detection.get('technologies', [])
        
        # Paso 2: Análisis y categorización de tecnologías
        log.info("Paso 2: Análisis y categorización")
        cms_list, framework_list = self._categorize_technologies(detected_technologies)
        
        # Paso 3: Escaneos específicos por CMS
        log.info("Paso 3: Escaneos específicos por CMS")
        cms_results = {}
        for cms in cms_list:
            cms_results[cms] = self.cms_scanner.scan_cms(cms, target, output_dir, **kwargs)
        
        # Paso 4: Escaneos específicos por Framework
        log.info("Paso 4: Escaneos específicos por Framework")
        framework_results = {}
        for framework in framework_list:
            framework_results[framework] = self.framework_scanner.scan_framework(framework, target, output_dir, **kwargs)
        
        # Paso 5: Escaneo especializado de APIs
        log.info("Paso 5: Escaneo especializado de APIs")
        api_results = self._advanced_api_scan(target, detected_technologies, output_dir, **kwargs)
        
        # Paso 6: Escaneo de contenedores
        log.info("Paso 6: Escaneo de contenedores")
        container_results = self._advanced_container_scan(target, detected_technologies, output_dir, **kwargs)
        
        # Paso 7: Escaneos avanzados de vulnerabilidades
        log.info("Paso 7: Escaneos avanzados de vulnerabilidades")
        advanced_vulns = self._advanced_vulnerability_scan(target, detected_technologies, output_dir, **kwargs)
        
        # Paso 8: Evaluación de seguridad
        log.info("Paso 8: Evaluación de seguridad")
        security_assessment = self._security_assessment(target, detected_technologies, cms_results, framework_results, output_dir)
        
        # Paso 9: Generar recomendaciones
        log.info("Paso 9: Generación de recomendaciones")
        recommendations = self._generate_recommendations(detected_technologies, cms_results, framework_results, advanced_vulns, security_assessment, api_results, container_results)
        
        # Calcular tiempo total y score de confianza
        scan_duration = time.time() - start_time
        confidence_score = self._calculate_confidence_score(tech_detection, cms_results, framework_results)
        
        log.info(f"Escaneo premium completado en {scan_duration:.2f} segundos")
        
        return PremiumScanResult(
            target=target,
            detected_technologies=detected_technologies,
            cms_specific_scans=cms_results,
            framework_specific_scans=framework_results,
            api_specific_scans=api_results,
            container_scans=container_results,
            advanced_vulnerability_scans=advanced_vulns,
            security_assessment=security_assessment,
            scan_duration=scan_duration,
            confidence_score=confidence_score,
            recommendations=recommendations
        )
    
    def _categorize_technologies(self, technologies: List[Dict]) -> Tuple[List[str], List[str]]:
        """Categoriza tecnologías en CMS y frameworks."""
        cms_list = []
        framework_list = []
        
        cms_keywords = ['wordpress', 'drupal', 'joomla', 'magento', 'prestashop', 'opencart', 'shopify']
        framework_keywords = ['laravel', 'django', 'flask', 'spring', 'rails', 'express', 'react', 'vue', 'angular']
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower()
            
            # Identificar CMS
            for cms in cms_keywords:
                if cms in tech_name and cms not in cms_list:
                    cms_list.append(cms)
            
            # Identificar frameworks
            for framework in framework_keywords:
                if framework in tech_name and framework not in framework_list:
                    framework_list.append(framework)
        
        return cms_list, framework_list
    
    def _advanced_vulnerability_scan(self, target: str, technologies: List[Dict], output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Ejecuta escaneos avanzados de vulnerabilidades basados en tecnologías detectadas."""
        results = {
            'nuclei_targeted': {},
            'custom_payloads': {},
            'api_security': {},
            'ssl_tls': {},
            'scan_status': 'completed'
        }
        
        try:
            # Nuclei con plantillas específicas
            nuclei_templates = self._get_nuclei_templates_for_technologies(technologies)
            if nuclei_templates:
                results['nuclei_targeted'] = self._run_targeted_nuclei(target, nuclei_templates, output_dir)
            
            # Escaneo de API si se detectan frameworks de API
            api_frameworks = ['express', 'flask', 'django', 'spring', 'rails']
            if any(fw in str(technologies).lower() for fw in api_frameworks):
                results['api_security'] = self._api_security_scan(target, output_dir)
            
            # Análisis SSL/TLS
            results['ssl_tls'] = self._ssl_tls_analysis(target, output_dir)
            
        except Exception as e:
            log.error(f"Error en escaneo avanzado de vulnerabilidades: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _get_nuclei_templates_for_technologies(self, technologies: List[Dict]) -> List[str]:
        """Obtiene plantillas Nuclei específicas para las tecnologías detectadas."""
        templates = []
        
        for tech in technologies:
            tech_name = tech.get('name', '').lower()
            
            # Mapeo de tecnologías a plantillas Nuclei
            tech_templates = self.tech_mapper.get_nuclei_templates(tech_name)
            if tech_templates:
                templates.extend(tech_templates)
        
        return list(set(templates))  # Eliminar duplicados
    
    def _run_targeted_nuclei(self, target: str, templates: List[str], output_dir: Path) -> Dict[str, Any]:
        """Ejecuta Nuclei con plantillas específicas."""
        results = {
            'vulnerabilities': [],
            'templates_used': templates,
            'scan_status': 'completed'
        }
        
        try:
            nuclei_file = output_dir / f"nuclei_targeted_{int(time.time())}.json"
            
            # Construir comando Nuclei
            cmd = [
                'nuclei',
                '-u', target,
                '-json',
                '-o', str(nuclei_file),
                '-rate-limit', '10',
                '-timeout', '10'
            ]
            
            # Agregar plantillas específicas
            for template in templates:
                cmd.extend(['-t', template])
            
            log.info(f"Ejecutando Nuclei dirigido: {' '.join(cmd)}")
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minutos
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if nuclei_file.exists():
                with open(nuclei_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        try:
                            vuln = json.loads(line.strip())
                            results['vulnerabilities'].append(vuln)
                        except json.JSONDecodeError:
                            continue
        
        except subprocess.TimeoutExpired:
            log.error(f"Nuclei dirigido timeout para {target}")
            results['scan_status'] = 'timeout'
        except Exception as e:
            log.error(f"Error en Nuclei dirigido: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _api_security_scan(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Escaneo de seguridad específico para APIs."""
        results = {
            'endpoints': [],
            'vulnerabilities': [],
            'authentication': {},
            'scan_status': 'completed'
        }
        
        try:
            # Descubrimiento de endpoints de API
            api_paths = [
                '/api',
                '/api/v1',
                '/api/v2',
                '/rest',
                '/graphql',
                '/swagger',
                '/openapi.json',
                '/api-docs'
            ]
            
            import requests
            for path in api_paths:
                try:
                    response = requests.get(f"{target.rstrip('/')}{path}", timeout=10)
                    if response.status_code == 200:
                        results['endpoints'].append({
                            'path': path,
                            'status_code': response.status_code,
                            'content_type': response.headers.get('Content-Type', '')
                        })
                except:
                    pass
            
            # Checks de autenticación
            auth_headers = ['Authorization', 'X-API-Key', 'X-Auth-Token']
            response = requests.get(target, timeout=10)
            
            for header in auth_headers:
                if header.lower() in [h.lower() for h in response.headers]:
                    results['authentication'][header] = 'Present'
                else:
                    results['authentication'][header] = 'Missing'
        
        except Exception as e:
            log.error(f"Error en escaneo de API: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _ssl_tls_analysis(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Análisis SSL/TLS."""
        results = {
            'certificate': {},
            'protocols': [],
            'ciphers': [],
            'vulnerabilities': [],
            'scan_status': 'completed'
        }
        
        try:
            # Usar testssl.sh si está disponible
            testssl_file = output_dir / f"testssl_{int(time.time())}.json"
            
            cmd = [
                'testssl.sh',
                '--jsonfile', str(testssl_file),
                '--quiet',
                target
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300,
                creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            )
            
            if testssl_file.exists():
                with open(testssl_file, 'r', encoding='utf-8') as f:
                    ssl_data = json.load(f)
                    results.update(self._process_testssl_results(ssl_data))
        
        except Exception as e:
            log.error(f"Error en análisis SSL/TLS: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _advanced_api_scan(self, target: str, detected_technologies: List[Dict], output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo avanzado de APIs basado en tecnologías detectadas."""
        results = {
            'rest_api': {},
            'graphql_api': {},
            'grpc_api': {},
            'api_documentation': {},
            'authentication_analysis': {},
            'rate_limiting': {},
            'scan_status': 'completed'
        }
        
        try:
            # Determinar si hay APIs basado en tecnologías detectadas
            api_technologies = ['rest', 'graphql', 'grpc', 'api', 'swagger', 'openapi', 'fastapi', 'express', 'flask', 'django']
            has_api = any(
                any(tech_keyword in tech.get('name', '').lower() for tech_keyword in api_technologies)
                for tech in detected_technologies
            )
            
            if not has_api:
                # Intentar detección automática de APIs
                has_api = self.api_scanner.detect_api_presence(target)
            
            if has_api:
                log.info(f"APIs detectadas en {target}, ejecutando escaneo especializado")
                
                # Escaneo REST API
                results['rest_api'] = self.api_scanner.scan_rest_api(target)
                
                # Escaneo GraphQL
                results['graphql_api'] = self.api_scanner.scan_graphql(target)
                
                # Escaneo gRPC
                results['grpc_api'] = self.api_scanner.scan_grpc(target)
                
                # Análisis de documentación
                results['api_documentation'] = self.api_scanner.analyze_api_documentation(target)
                
                # Análisis de autenticación
                results['authentication_analysis'] = self.api_scanner.analyze_authentication(target)
                
                # Análisis de rate limiting
                results['rate_limiting'] = self.api_scanner.test_rate_limiting(target)
                
                log.info(f"Escaneo de APIs completado para {target}")
            else:
                log.info(f"No se detectaron APIs en {target}")
                results['scan_status'] = 'no_apis_detected'
        
        except Exception as e:
            log.error(f"Error en escaneo avanzado de APIs: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _advanced_container_scan(self, target: str, detected_technologies: List[Dict], output_dir: Path, **kwargs) -> Dict[str, Any]:
        """Escaneo avanzado de contenedores Docker y Kubernetes."""
        results = {
            'docker_scan': {},
            'kubernetes_scan': {},
            'container_vulnerabilities': [],
            'misconfigurations': [],
            'exposed_services': [],
            'scan_status': 'completed'
        }
        
        try:
            # Detectar indicadores de contenedores
            container_indicators = [
                'docker', 'kubernetes', 'k8s', 'container', 'pod', 'deployment',
                'service', 'ingress', 'helm', 'kubectl', 'docker-compose'
            ]
            
            has_containers = any(
                any(indicator in tech.get('name', '').lower() for indicator in container_indicators)
                for tech in detected_technologies
            )
            
            # También verificar puertos comunes de contenedores
            container_ports = [2375, 2376, 2377, 6443, 8080, 9000, 10250]
            
            if has_containers or self.container_scanner.detect_docker(target) or self.container_scanner.detect_kubernetes(target):
                log.info(f"Contenedores detectados en {target}, ejecutando escaneo especializado")
                
                # Escaneo Docker
                results['docker_scan'] = self.container_scanner.scan_docker_vulnerabilities(target)
                
                # Escaneo Kubernetes
                results['kubernetes_scan'] = self.container_scanner.scan_kubernetes_security(target)
                
                # Detectar configuraciones incorrectas
                results['misconfigurations'] = self.container_scanner.detect_misconfigurations(target)
                
                # Detectar servicios expuestos
                results['exposed_services'] = self.container_scanner.detect_exposed_services(target)
                
                log.info(f"Escaneo de contenedores completado para {target}")
            else:
                # Escaneo básico de puertos relacionados con contenedores
                log.info(f"No se detectaron contenedores obvios en {target}, realizando escaneo básico")
                
                # Escanear puertos comunes de contenedores
                for port in container_ports:
                    try:
                        import socket
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(3)
                        result = sock.connect_ex((target, port))
                        if result == 0:
                            results['exposed_services'].append({
                                'port': port,
                                'service': f'Possible container service on port {port}',
                                'risk': 'Medium'
                            })
                        sock.close()
                    except Exception:
                        pass
                
                results['scan_status'] = 'basic_scan_completed'
        
        except Exception as e:
            log.error(f"Error en escaneo avanzado de contenedores: {e}")
            results['scan_status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def _process_testssl_results(self, data: Dict) -> Dict[str, Any]:
        """Procesa resultados de testssl.sh."""
        processed = {
            'certificate': {},
            'protocols': [],
            'vulnerabilities': []
        }
        
        # Procesar información del certificado
        if 'certificate' in data:
            cert_info = data['certificate']
            processed['certificate'] = {
                'subject': cert_info.get('subject', ''),
                'issuer': cert_info.get('issuer', ''),
                'expiry': cert_info.get('expiry', ''),
                'algorithm': cert_info.get('algorithm', '')
            }
        
        # Procesar protocolos
        if 'protocols' in data:
            processed['protocols'] = data['protocols']
        
        # Procesar vulnerabilidades
        if 'vulnerabilities' in data:
            processed['vulnerabilities'] = data['vulnerabilities']
        
        return processed
    
    def _security_assessment(self, target: str, technologies: List[Dict], cms_results: Dict, framework_results: Dict, output_dir: Path) -> Dict[str, Any]:
        """Evaluación general de seguridad."""
        assessment = {
            'risk_score': 0,
            'risk_level': 'Low',
            'critical_issues': [],
            'high_issues': [],
            'medium_issues': [],
            'low_issues': [],
            'recommendations_count': 0
        }
        
        try:
            # Calcular score de riesgo basado en hallazgos
            risk_score = 0
            
            # Evaluar resultados de CMS
            for cms, results in cms_results.items():
                if results.get('scan_status') == 'completed':
                    vulns = results.get('vulnerabilities', [])
                    risk_score += len(vulns) * 10
                    
                    config_issues = results.get('config_issues', [])
                    for issue in config_issues:
                        if 'CRÍTICO' in issue or 'critical' in issue.lower():
                            assessment['critical_issues'].append(f"{cms}: {issue}")
                            risk_score += 25
                        elif 'alto' in issue.lower() or 'high' in issue.lower():
                            assessment['high_issues'].append(f"{cms}: {issue}")
                            risk_score += 15
                        else:
                            assessment['medium_issues'].append(f"{cms}: {issue}")
                            risk_score += 5
            
            # Evaluar resultados de frameworks
            for framework, results in framework_results.items():
                if results.get('scan_status') == 'completed':
                    config_issues = results.get('config_issues', [])
                    for issue in config_issues:
                        if 'debug' in issue.lower() or 'expuesto' in issue.lower():
                            assessment['high_issues'].append(f"{framework}: {issue}")
                            risk_score += 15
                        else:
                            assessment['medium_issues'].append(f"{framework}: {issue}")
                            risk_score += 5
            
            # Determinar nivel de riesgo
            if risk_score >= 100:
                assessment['risk_level'] = 'Critical'
            elif risk_score >= 75:
                assessment['risk_level'] = 'High'
            elif risk_score >= 50:
                assessment['risk_level'] = 'Medium'
            elif risk_score >= 25:
                assessment['risk_level'] = 'Low'
            else:
                assessment['risk_level'] = 'Informational'
            
            assessment['risk_score'] = min(risk_score, 100)  # Máximo 100
        
        except Exception as e:
            log.error(f"Error en evaluación de seguridad: {e}")
            assessment['error'] = str(e)
        
        return assessment
    
    def _generate_recommendations(self, technologies: List[Dict], cms_results: Dict, framework_results: Dict, advanced_vulns: Dict, security_assessment: Dict, api_results: Dict = None, container_results: Dict = None) -> List[str]:
        """Genera recomendaciones específicas basadas en los hallazgos."""
        recommendations = []
        
        try:
            # Recomendaciones basadas en CMS
            for cms, results in cms_results.items():
                if results.get('scan_status') == 'completed':
                    if cms.lower() == 'wordpress':
                        recommendations.extend(self._wordpress_recommendations(results))
                    elif cms.lower() == 'drupal':
                        recommendations.extend(self._drupal_recommendations(results))
                    elif cms.lower() == 'joomla':
                        recommendations.extend(self._joomla_recommendations(results))
            
            # Recomendaciones basadas en frameworks
            for framework, results in framework_results.items():
                if results.get('scan_status') == 'completed':
                    if framework.lower() == 'laravel':
                        recommendations.extend(self._laravel_recommendations(results))
                    elif framework.lower() == 'django':
                        recommendations.extend(self._django_recommendations(results))
                    elif framework.lower() == 'spring':
                        recommendations.extend(self._spring_recommendations(results))
            
            # Recomendaciones basadas en APIs
            if api_results and api_results.get('scan_status') == 'completed':
                recommendations.extend(self._api_recommendations(api_results))
            
            # Recomendaciones basadas en contenedores
            if container_results and container_results.get('scan_status') in ['completed', 'basic_scan_completed']:
                recommendations.extend(self._container_recommendations(container_results))
            
            # Recomendaciones generales de seguridad
            recommendations.extend(self._general_security_recommendations(security_assessment))
            
            # Eliminar duplicados
            recommendations = list(set(recommendations))
        
        except Exception as e:
            log.error(f"Error generando recomendaciones: {e}")
            recommendations.append(f"Error generando recomendaciones: {e}")
        
        return recommendations
    
    def _wordpress_recommendations(self, results: Dict) -> List[str]:
        """Recomendaciones específicas para WordPress."""
        recommendations = []
        
        if results.get('vulnerabilities'):
            recommendations.append("Actualizar WordPress y todos los plugins/temas a las últimas versiones")
            recommendations.append("Implementar un plugin de seguridad como Wordfence o Sucuri")
        
        if any('config' in issue.lower() for issue in results.get('config_issues', [])):
            recommendations.append("Revisar y asegurar archivos de configuración (wp-config.php)")
            recommendations.append("Implementar permisos de archivo adecuados (644 para archivos, 755 para directorios)")
        
        if results.get('users'):
            recommendations.append("Implementar autenticación de dos factores para todos los usuarios")
            recommendations.append("Revisar y eliminar usuarios innecesarios")
        
        recommendations.append("Configurar copias de seguridad automáticas")
        recommendations.append("Implementar un WAF (Web Application Firewall)")
        
        return recommendations
    
    def _drupal_recommendations(self, results: Dict) -> List[str]:
        """Recomendaciones específicas para Drupal."""
        recommendations = []
        
        if results.get('vulnerabilities'):
            recommendations.append("Actualizar Drupal core y todos los módulos")
            recommendations.append("Suscribirse a las alertas de seguridad de Drupal")
        
        if results.get('config_issues'):
            recommendations.append("Revisar permisos de archivos y directorios")
            recommendations.append("Asegurar el directorio sites/default/files")
        
        recommendations.append("Implementar el módulo Security Kit")
        recommendations.append("Configurar logging de seguridad adecuado")
        
        return recommendations
    
    def _joomla_recommendations(self, results: Dict) -> List[str]:
        """Recomendaciones específicas para Joomla."""
        recommendations = []
        
        if results.get('vulnerabilities'):
            recommendations.append("Actualizar Joomla y todas las extensiones")
            recommendations.append("Remover extensiones no utilizadas")
        
        recommendations.append("Cambiar el prefijo de base de datos por defecto")
        recommendations.append("Implementar autenticación de dos factores")
        recommendations.append("Configurar el archivo .htaccess para mayor seguridad")
        
        return recommendations
    
    def _laravel_recommendations(self, results: Dict) -> List[str]:
        """Recomendaciones específicas para Laravel."""
        recommendations = []
        
        if results.get('debug_mode'):
            recommendations.append("Deshabilitar el modo debug en producción (DEBUG=False)")
        
        if results.get('admin_panel'):
            recommendations.append("Cambiar la URL del panel de administración por defecto")
            recommendations.append("Implementar restricciones de IP para el panel de admin")
        
        recommendations.append("Configurar ALLOWED_HOSTS correctamente")
        recommendations.append("Implementar middleware de seguridad")
        recommendations.append("Usar HTTPS y configurar headers de seguridad")
        
        return recommendations
    
    def _spring_recommendations(self, results: Dict) -> List[str]:
        """Recomendaciones específicas para Spring Boot."""
        recommendations = []
        
        if results.get('actuator_endpoints'):
            recommendations.append("Asegurar endpoints de Spring Boot Actuator")
            recommendations.append("Implementar autenticación para endpoints sensibles")
            recommendations.append("Deshabilitar endpoints innecesarios en producción")
        
        recommendations.append("Configurar Spring Security adecuadamente")
        recommendations.append("Implementar validación de entrada y CSRF protection")
        recommendations.append("Configurar logging de seguridad")
        
        return recommendations
    
    def _api_recommendations(self, api_results: Dict) -> List[str]:
        """Recomendaciones específicas para APIs."""
        recommendations = []
        
        try:
            # Recomendaciones para REST API
            if api_results.get('rest_api', {}).get('endpoints'):
                recommendations.append("Implementar autenticación robusta para todos los endpoints de API")
                recommendations.append("Configurar rate limiting para prevenir abuso de API")
                recommendations.append("Implementar validación estricta de entrada en todos los endpoints")
                
                # Verificar si hay endpoints sin autenticación
                if any(ep.get('requires_auth', True) == False for ep in api_results['rest_api'].get('endpoints', [])):
                    recommendations.append("CRÍTICO: Endpoints sin autenticación detectados - implementar autenticación")
            
            # Recomendaciones para GraphQL
            if api_results.get('graphql_api', {}).get('endpoint_found'):
                recommendations.append("Deshabilitar introspección de GraphQL en producción")
                recommendations.append("Implementar query depth limiting para prevenir ataques de DoS")
                recommendations.append("Configurar query complexity analysis")
                recommendations.append("Implementar autenticación y autorización granular en resolvers")
            
            # Recomendaciones para gRPC
            if api_results.get('grpc_api', {}).get('services'):
                recommendations.append("Implementar TLS para todas las comunicaciones gRPC")
                recommendations.append("Configurar autenticación mutual (mTLS) para servicios críticos")
                recommendations.append("Implementar interceptors para logging y monitoreo")
            
            # Recomendaciones de documentación
            if api_results.get('api_documentation', {}).get('swagger_exposed'):
                recommendations.append("Restringir acceso a documentación Swagger/OpenAPI en producción")
                recommendations.append("Remover información sensible de la documentación de API")
            
            # Recomendaciones de autenticación
            auth_analysis = api_results.get('authentication_analysis', {})
            if auth_analysis.get('weak_authentication'):
                recommendations.append("CRÍTICO: Esquemas de autenticación débiles detectados")
                recommendations.append("Implementar OAuth 2.0 o JWT con algoritmos seguros")
            
            if not auth_analysis.get('https_enforced'):
                recommendations.append("CRÍTICO: Forzar HTTPS para todas las comunicaciones de API")
            
            # Recomendaciones de rate limiting
            if not api_results.get('rate_limiting', {}).get('implemented'):
                recommendations.append("Implementar rate limiting para prevenir abuso y ataques DDoS")
                recommendations.append("Configurar diferentes límites para usuarios autenticados y anónimos")
            
            # Recomendaciones generales de API
            recommendations.extend([
                "Implementar logging detallado de todas las requests de API",
                "Configurar CORS de manera restrictiva",
                "Implementar versionado de API para mantener compatibilidad",
                "Usar HTTPS exclusivamente para todas las comunicaciones",
                "Implementar headers de seguridad específicos para APIs",
                "Configurar timeouts apropiados para prevenir ataques de slowloris",
                "Implementar validación de Content-Type",
                "Usar tokens de API con expiración y rotación automática"
            ])
        
        except Exception as e:
            log.error(f"Error generando recomendaciones de API: {e}")
            recommendations.append("Error generando recomendaciones específicas de API")
        
        return recommendations
    
    def _container_recommendations(self, container_results: Dict) -> List[str]:
        """Recomendaciones específicas para contenedores."""
        recommendations = []
        
        try:
            # Recomendaciones para Docker
            if container_results.get('docker_scan', {}).get('vulnerabilities'):
                recommendations.extend([
                    "Actualizar imágenes Docker a las últimas versiones",
                    "Escanear imágenes con herramientas como Trivy o Clair",
                    "Usar imágenes base mínimas (Alpine, Distroless)",
                    "Implementar multi-stage builds para reducir superficie de ataque"
                ])
            
            # Recomendaciones para Kubernetes
            if container_results.get('kubernetes_scan', {}).get('misconfigurations'):
                recommendations.extend([
                    "Implementar Network Policies para segmentar tráfico",
                    "Configurar RBAC (Role-Based Access Control) restrictivo",
                    "Usar Pod Security Standards/Policies",
                    "Implementar admission controllers para validación"
                ])
            
            # Recomendaciones para configuraciones incorrectas
            if container_results.get('misconfigurations'):
                recommendations.extend([
                    "Evitar ejecutar contenedores como root",
                    "Configurar límites de recursos (CPU, memoria)",
                    "Implementar health checks y readiness probes",
                    "Usar secrets management para credenciales",
                    "Configurar logging centralizado para contenedores"
                ])
            
            # Recomendaciones para servicios expuestos
            if container_results.get('exposed_services'):
                recommendations.extend([
                    "Revisar servicios expuestos innecesariamente",
                    "Implementar TLS para comunicaciones entre servicios",
                    "Configurar firewalls y security groups apropiados",
                    "Usar service mesh para comunicación segura"
                ])
            
            # Recomendaciones generales de contenedores
            recommendations.extend([
                "Implementar image signing y verification",
                "Configurar registry privado para imágenes",
                "Implementar runtime security monitoring",
                "Realizar auditorías regulares de configuración",
                "Usar herramientas de compliance como Falco o OPA Gatekeeper",
                "Implementar backup y disaster recovery para datos persistentes",
                "Configurar monitoring y alertas para contenedores",
                "Mantener Docker/Kubernetes actualizados"
            ])
        
        except Exception as e:
            log.error(f"Error generando recomendaciones de contenedores: {e}")
            recommendations.append("Error generando recomendaciones específicas de contenedores")
        
        return recommendations
    
    def _general_security_recommendations(self, security_assessment: Dict) -> List[str]:
        """Recomendaciones generales de seguridad."""
        recommendations = []
        
        risk_level = security_assessment.get('risk_level', 'Low')
        
        if risk_level in ['Critical', 'High']:
            recommendations.append("URGENTE: Revisar y corregir vulnerabilidades críticas inmediatamente")
            recommendations.append("Implementar monitoreo de seguridad en tiempo real")
            recommendations.append("Considerar una auditoría de seguridad profesional")
        
        recommendations.extend([
            "Implementar headers de seguridad HTTP",
            "Configurar HTTPS con certificados válidos",
            "Implementar rate limiting y protección DDoS",
            "Configurar logging y monitoreo de seguridad",
            "Realizar copias de seguridad regulares",
            "Implementar un plan de respuesta a incidentes",
            "Mantener todas las dependencias actualizadas",
            "Realizar pruebas de penetración regulares"
        ])
        
        return recommendations
    
    def _calculate_confidence_score(self, tech_detection: Dict, cms_results: Dict, framework_results: Dict) -> float:
        """Calcula el score de confianza del escaneo."""
        try:
            confidence = 0.0
            total_weight = 0.0
            
            # Peso de la detección de tecnologías
            tech_confidence = tech_detection.get('confidence', 0.0)
            confidence += tech_confidence * 0.3
            total_weight += 0.3
            
            # Peso de los escaneos de CMS
            cms_weight = 0.4
            cms_success = 0
            cms_total = len(cms_results)
            
            if cms_total > 0:
                for results in cms_results.values():
                    if results.get('scan_status') == 'completed':
                        cms_success += 1
                
                cms_confidence = cms_success / cms_total
                confidence += cms_confidence * cms_weight
                total_weight += cms_weight
            
            # Peso de los escaneos de frameworks
            framework_weight = 0.3
            framework_success = 0
            framework_total = len(framework_results)
            
            if framework_total > 0:
                for results in framework_results.values():
                    if results.get('scan_status') == 'completed':
                        framework_success += 1
                
                framework_confidence = framework_success / framework_total
                confidence += framework_confidence * framework_weight
                total_weight += framework_weight
            
            # Normalizar
            if total_weight > 0:
                confidence = confidence / total_weight
            
            return min(max(confidence, 0.0), 1.0)  # Entre 0 y 1
        
        except Exception as e:
            log.error(f"Error calculando score de confianza: {e}")
            return 0.5  # Valor por defecto

def save_premium_scan_results(scan_result: PremiumScanResult, output_file: Path) -> bool:
    """Guarda los resultados del escaneo premium en formato JSON."""
    try:
        result_data = {
            'target': scan_result.target,
            'scan_timestamp': time.time(),
            'scan_duration': scan_result.scan_duration,
            'confidence_score': scan_result.confidence_score,
            'detected_technologies': scan_result.detected_technologies,
            'cms_specific_scans': scan_result.cms_specific_scans,
            'framework_specific_scans': scan_result.framework_specific_scans,
            'api_specific_scans': scan_result.api_specific_scans,
            'container_scans': scan_result.container_scans,
            'advanced_vulnerability_scans': scan_result.advanced_vulnerability_scans,
            'security_assessment': scan_result.security_assessment,
            'recommendations': scan_result.recommendations,
            'scan_type': 'premium_adaptive'
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(result_data, f, indent=2, ensure_ascii=False)
        
        log.info(f"Resultados del escaneo premium guardados en {output_file}")
        return True
    
    except Exception as e:
        log.error(f"Error guardando resultados del escaneo premium: {e}")
        return False

def load_premium_scan_results(input_file: Path) -> Optional[PremiumScanResult]:
    """Carga los resultados de un escaneo premium desde archivo JSON."""
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        return PremiumScanResult(
            target=data['target'],
            detected_technologies=data['detected_technologies'],
            cms_specific_scans=data['cms_specific_scans'],
            framework_specific_scans=data['framework_specific_scans'],
            api_specific_scans=data.get('api_specific_scans', {}),
            container_scans=data.get('container_scans', {}),
            advanced_vulnerability_scans=data['advanced_vulnerability_scans'],
            security_assessment=data['security_assessment'],
            scan_duration=data['scan_duration'],
            confidence_score=data['confidence_score'],
            recommendations=data['recommendations']
        )
    
    except Exception as e:
        log.error(f"Error cargando resultados del escaneo premium: {e}")
        return None

# Función principal para integración con el pipeline existente
def premium_adaptive_scan_wrapper(target: str, output_dir: Path, **kwargs) -> Dict[str, Any]:
    """Wrapper para integración con el pipeline existente de pentest."""
    try:
        # Configuración del escáner premium
        config = {
            'use_cache': kwargs.get('use_cache', True),
            'enable_web_content_analysis': kwargs.get('enable_web_content_analysis', True)
        }
        
        # Crear instancia del escáner
        scanner = PremiumAdaptiveScanner(config)
        
        # Ejecutar escaneo premium
        scan_result = scanner.premium_scan(target, output_dir, **kwargs)
        
        # Guardar resultados
        output_file = output_dir / f"premium_adaptive_scan_{int(time.time())}.json"
        save_premium_scan_results(scan_result, output_file)
        
        # Retornar en formato compatible con el pipeline existente
        return {
            'target': scan_result.target,
            'scan_type': 'premium_adaptive',
            'scan_duration': scan_result.scan_duration,
            'confidence_score': scan_result.confidence_score,
            'technologies_detected': len(scan_result.detected_technologies),
            'cms_scanned': len(scan_result.cms_specific_scans),
            'frameworks_scanned': len(scan_result.framework_specific_scans),
            'vulnerabilities_found': sum(
                len(cms_result.get('vulnerabilities', [])) 
                for cms_result in scan_result.cms_specific_scans.values()
            ),
            'risk_level': scan_result.security_assessment.get('risk_level', 'Unknown'),
            'risk_score': scan_result.security_assessment.get('risk_score', 0),
            'recommendations_count': len(scan_result.recommendations),
            'output_file': str(output_file),
            'status': 'completed'
        }
    
    except Exception as e:
        log.error(f"Error en escaneo premium adaptativo: {e}")
        return {
            'target': target,
            'scan_type': 'premium_adaptive',
            'status': 'error',
            'error': str(e)
        }

if __name__ == "__main__":
    # Ejemplo de uso
    import sys
    from pathlib import Path
    
    if len(sys.argv) != 2:
        print("Uso: python premium_adaptive_scan.py <target_url>")
        sys.exit(1)
    
    target = sys.argv[1]
    output_dir = Path("./premium_scan_output")
    output_dir.mkdir(exist_ok=True)
    
    print(f"Iniciando escaneo premium adaptativo para: {target}")
    
    scanner = PremiumAdaptiveScanner()
    result = scanner.premium_scan(target, output_dir)
    
    print(f"\nEscaneo completado en {result.scan_duration:.2f} segundos")
    print(f"Tecnologías detectadas: {len(result.detected_technologies)}")
    print(f"CMS escaneados: {len(result.cms_specific_scans)}")
    print(f"Frameworks escaneados: {len(result.framework_specific_scans)}")
    print(f"Nivel de riesgo: {result.security_assessment.get('risk_level', 'Unknown')}")
    print(f"Score de confianza: {result.confidence_score:.2f}")
    print(f"Recomendaciones: {len(result.recommendations)}")
    
    # Guardar resultados
    output_file = output_dir / f"premium_scan_{int(time.time())}.json"
    if save_premium_scan_results(result, output_file):
        print(f"\nResultados guardados en: {output_file}")
    
    # Mostrar recomendaciones principales
    if result.recommendations:
        print("\nRecomendaciones principales:")
        for i, rec in enumerate(result.recommendations[:5], 1):
            print(f"{i}. {rec.get('title', rec) if isinstance(rec, dict) else rec}")