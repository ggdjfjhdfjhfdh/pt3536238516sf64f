import json
import logging
import requests
import random
import time
from urllib.parse import urljoin
from pathlib import Path
from typing import List, Dict, Any

from pentest.exceptions import SecurityConfigError
from pentest.config import DEFAULT_TIMEOUT, WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS

log = logging.getLogger(__name__)

def _make_waf_evasion_request(url: str, method: str = 'GET', **kwargs) -> requests.Response:
    """Realiza una petici√≥n HTTP con t√©cnicas de evasi√≥n anti-WAF.
    
    Args:
        url: URL objetivo
        method: M√©todo HTTP (GET, POST, etc.)
        **kwargs: Argumentos adicionales para requests
        
    Returns:
        Response object de requests
    """
    config = WAF_EVASION_CONFIG
    
    # Configurar headers con evasi√≥n anti-WAF
    headers = WAF_COMMON_HEADERS.copy()
    headers['User-Agent'] = random.choice(WAF_USER_AGENTS)
    
    # Merge con headers personalizados si se proporcionan
    if 'headers' in kwargs:
        headers.update(kwargs['headers'])
    kwargs['headers'] = headers
    
    # Configurar timeouts y otros par√°metros
    kwargs.setdefault('timeout', config['max_time'])
    kwargs.setdefault('verify', False)
    kwargs.setdefault('allow_redirects', True)
    
    # Realizar la petici√≥n con reintentos
    for attempt in range(config['retry_attempts'] + 1):
        try:
            if attempt > 0:
                delay = config['retry_delay']
                log.debug(f"Reintentando petici√≥n a {url} en {delay} segundos (intento {attempt + 1})")
                time.sleep(delay)
            
            response = requests.request(method, url, **kwargs)
            return response
            
        except requests.exceptions.RequestException as e:
            if attempt == config['retry_attempts']:
                raise
            log.debug(f"Error en petici√≥n a {url}: {e}. Reintentando...")
    
    # Este punto no deber√≠a alcanzarse nunca
    raise requests.exceptions.RequestException(f"Fall√≥ despu√©s de {config['retry_attempts'] + 1} intentos")

def security_config_scan(httpx_file: Path, tmp_dir: Path) -> Path:
    """Performs basic security configuration analysis on identified web servers.
    
    Args:
        httpx_file: Path to the JSON file containing httpx results (active hosts with tech-detect).
        tmp_dir: Temporary directory for storing results.
        
    Returns:
        Path to the JSON file with security configuration findings.
        
    Raises:
        SecurityConfigError: If the security configuration scan fails.
    """
    log.info("üîç Iniciando an√°lisis de configuraci√≥n de seguridad.")
    
    output_file = tmp_dir / "security_config.json"
    config_findings: List[Dict[str, Any]] = []

    if not httpx_file.exists():
        log.warning(f"Archivo httpx no encontrado: {httpx_file}. No se realizar√° an√°lisis de configuraci√≥n de seguridad.")
        with open(output_file, "w") as f:
            json.dump([], f)
        return output_file

    try:
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)

        for host_data in httpx_data:
            url = host_data.get("url")
            technologies = host_data.get("tech", [])

            if not url:
                continue

            log.info(f"Analizando configuraci√≥n de seguridad para {url}...")

            # Placeholder for actual security configuration checks
            # This would involve more sophisticated checks, potentially using external tools
            # or custom HTTP requests to look for common misconfigurations.
            
            # Example: Check for common server headers that indicate misconfigurations
            # Realizar comprobaciones de cabeceras de seguridad
            config_findings.extend(check_security_headers(url))

            # Comprobaciones espec√≠ficas de tecnolog√≠as
            if "nginx" in [t.lower() if isinstance(t, str) else t.get("name", "").lower() for t in technologies]:
                # Ejemplo: Comprobar si la p√°gina de estado de Nginx est√° expuesta
                nginx_status_url = urljoin(url, "/nginx_status")
                try:
                    response = _make_waf_evasion_request(nginx_status_url)
                    if response.status_code == 200 and "Active connections" in response.text:
                        config_findings.append({
                            "url": nginx_status_url,
                            "type": "Misconfiguration",
                            "description": "P√°gina de estado de Nginx expuesta, revelando informaci√≥n sensible.",
                            "severity": "High"
                        })
                except requests.exceptions.RequestException as e:
                    log.debug(f"No se pudo acceder a {nginx_status_url}: {e}")

            if "apache http server" in [t.lower() if isinstance(t, str) else t.get("name", "").lower() for t in technologies]:
                # Ejemplo: Comprobar si la p√°gina de estado de Apache est√° expuesta
                apache_status_url = urljoin(url, "/server-status")
                try:
                    response = _make_waf_evasion_request(apache_status_url)
                    if response.status_code == 200 and "Apache Server Status" in response.text:
                        config_findings.append({
                            "url": apache_status_url,
                            "type": "Misconfiguration",
                            "description": "P√°gina de estado de Apache expuesta, revelando informaci√≥n sensible.",
                            "severity": "High"
                        })
                except requests.exceptions.RequestException as e:
                    log.debug(f"No se pudo acceder a {apache_status_url}: {e}")

            # A√±adir m√°s comprobaciones aqu√≠ para otras tecnolog√≠as o configuraciones comunes

        with open(output_file, "w") as f:
            json.dump(config_findings, f, indent=2)

        log.info("‚úÖ An√°lisis de configuraci√≥n de seguridad completado: %d hallazgos", len(config_findings))
        return output_file

    except Exception as e:
        raise SecurityConfigError(f"Error durante el an√°lisis de configuraci√≥n de seguridad: {str(e)}") from e

def check_security_headers(url: str) -> List[Dict[str, Any]]:
    findings = []
    try:
        response = _make_waf_evasion_request(url)
        headers = {k.lower(): v for k, v in response.headers.items()}

        # Lista de cabeceras de seguridad recomendadas y su severidad si faltan
        security_headers = {
            "strict-transport-security": "High",
            "x-frame-options": "Medium",
            "content-security-policy": "Medium",
            "x-content-type-options": "Medium",
            "referrer-policy": "Medium",
            "permissions-policy": "Medium",
            "expect-ct": "Medium",
            "cross-origin-embedder-policy": "Medium",
            "cross-origin-opener-policy": "Medium",
            "cross-origin-resource-policy": "Medium",
        }

        for header, severity in security_headers.items():
            if header not in headers:
                findings.append({
                    "url": url,
                    "type": "Missing Security Header",
                    "description": f"La cabecera '{header}' no est√° presente.",
                    "severity": severity
                })

        # Comprobar la cabecera 'Server'
        server_header = headers.get("server")
        if server_header:
            findings.append({
                "url": url,
                "type": "Information Disclosure",
                "description": f"La cabecera 'Server' expone informaci√≥n sobre el servidor web: {server_header}.",
                "severity": "Low"
            })

    except requests.exceptions.RequestException as e:
        log.warning(f"No se pudo realizar la comprobaci√≥n de cabeceras para {url}: {e}")
    return findings