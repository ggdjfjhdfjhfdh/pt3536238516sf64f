#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de puntuaci贸n inteligente para evaluaci贸n de riesgo contextual.
Calcula puntuaciones de riesgo considerando m煤ltiples factores y contexto empresarial.
"""

import logging
import math
from collections import defaultdict, Counter
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Tuple
from enum import Enum

log = logging.getLogger(__name__)


class BusinessCriticality(Enum):
    """Niveles de criticidad empresarial."""
    CRITICAL = "critical"  # Sistemas cr铆ticos para el negocio
    HIGH = "high"         # Sistemas importantes
    MEDIUM = "medium"     # Sistemas est谩ndar
    LOW = "low"          # Sistemas de desarrollo/testing


class AssetType(Enum):
    """Tipos de activos."""
    WEB_APPLICATION = "web_application"
    DATABASE = "database"
    API = "api"
    INFRASTRUCTURE = "infrastructure"
    NETWORK_DEVICE = "network_device"
    ENDPOINT = "endpoint"


@dataclass
class AssetContext:
    """Contexto de un activo."""
    asset_id: str
    asset_type: AssetType
    business_criticality: BusinessCriticality
    data_classification: str  # public, internal, confidential, restricted
    compliance_requirements: List[str] = field(default_factory=list)
    business_functions: List[str] = field(default_factory=list)
    user_base_size: int = 0
    revenue_impact: float = 0.0  # Impacto en ingresos (0-1)
    availability_requirement: float = 0.99  # SLA de disponibilidad
    

@dataclass
class VulnerabilityContext:
    """Contexto de una vulnerabilidad."""
    vulnerability_id: str
    cvss_base_score: float
    severity: str
    exploitability: float  # 0-1
    exploit_availability: bool
    attack_vector: str  # network, adjacent, local, physical
    attack_complexity: str  # low, high
    privileges_required: str  # none, low, high
    user_interaction: str  # none, required
    scope: str  # unchanged, changed
    confidentiality_impact: str  # none, low, high
    integrity_impact: str  # none, low, high
    availability_impact: str  # none, low, high
    age_days: int = 0
    patch_available: bool = False
    in_cisa_kev: bool = False
    active_exploitation: bool = False


@dataclass
class RiskScore:
    """Puntuaci贸n de riesgo calculada."""
    base_score: float
    contextual_score: float
    business_impact_score: float
    exploitability_score: float
    temporal_score: float
    environmental_score: float
    final_score: float
    risk_level: str
    confidence: float
    contributing_factors: Dict[str, float]
    recommendations: List[str]


class IntelligentScoringEngine:
    """Motor de puntuaci贸n inteligente para evaluaci贸n de riesgo."""
    
    def __init__(self):
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        
        # Pesos para diferentes factores de riesgo
        self.weights = {
            'cvss_base': 0.25,
            'exploitability': 0.20,
            'business_impact': 0.20,
            'temporal_factors': 0.15,
            'environmental': 0.10,
            'correlation_bonus': 0.10
        }
        
        # Multiplicadores por criticidad empresarial
        self.criticality_multipliers = {
            BusinessCriticality.CRITICAL: 1.5,
            BusinessCriticality.HIGH: 1.2,
            BusinessCriticality.MEDIUM: 1.0,
            BusinessCriticality.LOW: 0.7
        }
        
        # Multiplicadores por clasificaci贸n de datos
        self.data_classification_multipliers = {
            'restricted': 1.4,
            'confidential': 1.2,
            'internal': 1.0,
            'public': 0.8
        }
        
        # Multiplicadores por vector de ataque
        self.attack_vector_multipliers = {
            'network': 1.2,
            'adjacent': 1.0,
            'local': 0.8,
            'physical': 0.6
        }
        
        # Base de conocimiento de amenazas
        self.threat_intelligence = {
            'trending_attacks': ['sql-injection', 'xss', 'rce', 'auth-bypass'],
            'seasonal_threats': {},
            'industry_specific': {}
        }
    
    def calculate_intelligent_score(
        self, 
        vulnerability: VulnerabilityContext,
        asset: AssetContext,
        correlations: List[Dict[str, Any]] = None,
        threat_context: Dict[str, Any] = None
    ) -> RiskScore:
        """Calcula puntuaci贸n de riesgo inteligente."""
        
        try:
            # 1. Puntuaci贸n base CVSS
            base_score = self._calculate_base_score(vulnerability)
            
            # 2. Puntuaci贸n de explotabilidad
            exploitability_score = self._calculate_exploitability_score(vulnerability, threat_context)
            
            # 3. Impacto empresarial
            business_impact_score = self._calculate_business_impact_score(vulnerability, asset)
            
            # 4. Factores temporales
            temporal_score = self._calculate_temporal_score(vulnerability)
            
            # 5. Factores ambientales
            environmental_score = self._calculate_environmental_score(vulnerability, asset)
            
            # 6. Bonus por correlaciones
            correlation_bonus = self._calculate_correlation_bonus(correlations or [])
            
            # Calcular puntuaci贸n final ponderada
            final_score = (
                base_score * self.weights['cvss_base'] +
                exploitability_score * self.weights['exploitability'] +
                business_impact_score * self.weights['business_impact'] +
                temporal_score * self.weights['temporal_factors'] +
                environmental_score * self.weights['environmental'] +
                correlation_bonus * self.weights['correlation_bonus']
            )
            
            # Aplicar multiplicadores contextuales
            contextual_multiplier = self._calculate_contextual_multiplier(asset, vulnerability)
            contextual_score = final_score * contextual_multiplier
            
            # Normalizar a escala 0-10
            normalized_score = min(10.0, max(0.0, contextual_score))
            
            # Determinar nivel de riesgo
            risk_level = self._determine_risk_level(normalized_score)
            
            # Calcular confianza
            confidence = self._calculate_confidence(vulnerability, asset, correlations)
            
            # Generar recomendaciones
            recommendations = self._generate_recommendations(vulnerability, asset, normalized_score)
            
            return RiskScore(
                base_score=base_score,
                contextual_score=contextual_score,
                business_impact_score=business_impact_score,
                exploitability_score=exploitability_score,
                temporal_score=temporal_score,
                environmental_score=environmental_score,
                final_score=normalized_score,
                risk_level=risk_level,
                confidence=confidence,
                contributing_factors={
                    'cvss_base': base_score,
                    'exploitability': exploitability_score,
                    'business_impact': business_impact_score,
                    'temporal': temporal_score,
                    'environmental': environmental_score,
                    'correlation_bonus': correlation_bonus,
                    'contextual_multiplier': contextual_multiplier
                },
                recommendations=recommendations
            )
            
        except Exception as e:
            self.log.error(f"Error calculando puntuaci贸n inteligente: {e}")
            # Fallback a puntuaci贸n CVSS b谩sica
            return self._create_fallback_score(vulnerability)
    
    def _calculate_base_score(self, vulnerability: VulnerabilityContext) -> float:
        """Calcula puntuaci贸n base normalizada."""
        return vulnerability.cvss_base_score
    
    def _calculate_exploitability_score(self, vulnerability: VulnerabilityContext, threat_context: Dict[str, Any] = None) -> float:
        """Calcula puntuaci贸n de explotabilidad."""
        score = vulnerability.exploitability * 10
        
        # Bonus por disponibilidad de exploit
        if vulnerability.exploit_availability:
            score += 2.0
        
        # Bonus por explotaci贸n activa
        if vulnerability.active_exploitation:
            score += 3.0
        
        # Bonus por CISA KEV
        if vulnerability.in_cisa_kev:
            score += 2.5
        
        # Ajuste por complejidad de ataque
        if vulnerability.attack_complexity == 'low':
            score += 1.0
        elif vulnerability.attack_complexity == 'high':
            score -= 0.5
        
        # Ajuste por privilegios requeridos
        if vulnerability.privileges_required == 'none':
            score += 1.5
        elif vulnerability.privileges_required == 'low':
            score += 0.5
        
        # Ajuste por interacci贸n del usuario
        if vulnerability.user_interaction == 'none':
            score += 1.0
        
        # Contexto de amenazas
        if threat_context:
            trending_multiplier = threat_context.get('trending_multiplier', 1.0)
            score *= trending_multiplier
        
        return min(10.0, max(0.0, score))
    
    def _calculate_business_impact_score(self, vulnerability: VulnerabilityContext, asset: AssetContext) -> float:
        """Calcula impacto empresarial."""
        # Impacto base por CIA
        cia_impacts = {
            'high': 3.0,
            'low': 1.0,
            'none': 0.0
        }
        
        confidentiality_impact = cia_impacts.get(vulnerability.confidentiality_impact, 0)
        integrity_impact = cia_impacts.get(vulnerability.integrity_impact, 0)
        availability_impact = cia_impacts.get(vulnerability.availability_impact, 0)
        
        base_impact = (confidentiality_impact + integrity_impact + availability_impact) / 3
        
        # Multiplicador por criticidad empresarial
        criticality_multiplier = self.criticality_multipliers[asset.business_criticality]
        
        # Multiplicador por clasificaci贸n de datos
        data_multiplier = self.data_classification_multipliers.get(asset.data_classification, 1.0)
        
        # Ajuste por tama帽o de base de usuarios
        user_multiplier = 1.0
        if asset.user_base_size > 10000:
            user_multiplier = 1.3
        elif asset.user_base_size > 1000:
            user_multiplier = 1.1
        
        # Ajuste por impacto en ingresos
        revenue_multiplier = 1.0 + asset.revenue_impact
        
        # Ajuste por requisitos de disponibilidad
        if availability_impact > 0 and asset.availability_requirement > 0.99:
            availability_multiplier = 1.2
        else:
            availability_multiplier = 1.0
        
        # Ajuste por cumplimiento normativo
        compliance_multiplier = 1.0
        if asset.compliance_requirements:
            compliance_multiplier = 1.0 + (len(asset.compliance_requirements) * 0.1)
        
        final_score = (
            base_impact * 
            criticality_multiplier * 
            data_multiplier * 
            user_multiplier * 
            revenue_multiplier * 
            availability_multiplier * 
            compliance_multiplier
        )
        
        return min(10.0, max(0.0, final_score))
    
    def _calculate_temporal_score(self, vulnerability: VulnerabilityContext) -> float:
        """Calcula factores temporales."""
        base_score = vulnerability.cvss_base_score
        
        # Ajuste por edad de la vulnerabilidad
        age_penalty = 0
        if vulnerability.age_days > 365:  # M谩s de 1 a帽o
            age_penalty = 1.0
        elif vulnerability.age_days > 180:  # M谩s de 6 meses
            age_penalty = 0.5
        elif vulnerability.age_days > 90:   # M谩s de 3 meses
            age_penalty = 0.2
        
        # Bonus por disponibilidad de parche
        patch_adjustment = 0
        if vulnerability.patch_available:
            # Si hay parche disponible, el riesgo aumenta por no aplicarlo
            if vulnerability.age_days > 30:  # Parche disponible hace m谩s de 30 d铆as
                patch_adjustment = 1.5
            else:
                patch_adjustment = 0.5
        
        # Ajuste por explotaci贸n activa reciente
        exploitation_bonus = 0
        if vulnerability.active_exploitation:
            exploitation_bonus = 2.0
        
        temporal_score = base_score + age_penalty + patch_adjustment + exploitation_bonus
        
        return min(10.0, max(0.0, temporal_score))
    
    def _calculate_environmental_score(self, vulnerability: VulnerabilityContext, asset: AssetContext) -> float:
        """Calcula factores ambientales."""
        base_score = vulnerability.cvss_base_score
        
        # Ajuste por vector de ataque
        attack_vector_multiplier = self.attack_vector_multipliers.get(vulnerability.attack_vector, 1.0)
        
        # Ajuste por tipo de activo
        asset_type_multiplier = {
            AssetType.WEB_APPLICATION: 1.2,  # M谩s expuesto
            AssetType.API: 1.1,
            AssetType.DATABASE: 1.3,         # Datos cr铆ticos
            AssetType.INFRASTRUCTURE: 1.0,
            AssetType.NETWORK_DEVICE: 1.1,
            AssetType.ENDPOINT: 0.9
        }.get(asset.asset_type, 1.0)
        
        # Ajuste por funciones empresariales
        business_function_multiplier = 1.0
        critical_functions = ['payment', 'authentication', 'data_processing', 'customer_data']
        if any(func in critical_functions for func in asset.business_functions):
            business_function_multiplier = 1.2
        
        environmental_score = base_score * attack_vector_multiplier * asset_type_multiplier * business_function_multiplier
        
        return min(10.0, max(0.0, environmental_score))
    
    def _calculate_correlation_bonus(self, correlations: List[Dict[str, Any]]) -> float:
        """Calcula bonus por correlaciones."""
        if not correlations:
            return 0.0
        
        # Bonus base por n煤mero de correlaciones
        correlation_count_bonus = min(3.0, len(correlations) * 0.5)
        
        # Bonus por confianza de correlaciones
        confidence_bonus = 0
        if correlations:
            avg_confidence = sum(c.get('confidence', 0) for c in correlations) / len(correlations)
            confidence_bonus = avg_confidence * 2.0
        
        # Bonus por multiplicador de riesgo
        risk_multiplier_bonus = 0
        max_risk_multiplier = max((c.get('risk_multiplier', 1.0) for c in correlations), default=1.0)
        if max_risk_multiplier > 1.5:
            risk_multiplier_bonus = (max_risk_multiplier - 1.0) * 2.0
        
        total_bonus = correlation_count_bonus + confidence_bonus + risk_multiplier_bonus
        
        return min(5.0, max(0.0, total_bonus))
    
    def _calculate_contextual_multiplier(self, asset: AssetContext, vulnerability: VulnerabilityContext) -> float:
        """Calcula multiplicador contextual general."""
        multiplier = 1.0
        
        # Multiplicador por criticidad empresarial
        multiplier *= self.criticality_multipliers[asset.business_criticality]
        
        # Multiplicador por clasificaci贸n de datos
        multiplier *= self.data_classification_multipliers.get(asset.data_classification, 1.0)
        
        # Multiplicador por scope de la vulnerabilidad
        if vulnerability.scope == 'changed':
            multiplier *= 1.2
        
        return multiplier
    
    def _determine_risk_level(self, score: float) -> str:
        """Determina nivel de riesgo basado en puntuaci贸n."""
        if score >= 9.0:
            return "Critical"
        elif score >= 7.0:
            return "High"
        elif score >= 4.0:
            return "Medium"
        elif score >= 1.0:
            return "Low"
        else:
            return "Info"
    
    def _calculate_confidence(self, vulnerability: VulnerabilityContext, asset: AssetContext, correlations: List[Dict[str, Any]]) -> float:
        """Calcula confianza en la puntuaci贸n."""
        confidence = 0.5  # Base
        
        # Confianza por completitud de datos de vulnerabilidad
        if vulnerability.cvss_base_score > 0:
            confidence += 0.2
        if vulnerability.exploit_availability is not None:
            confidence += 0.1
        if vulnerability.age_days > 0:
            confidence += 0.1
        
        # Confianza por completitud de contexto de activo
        if asset.business_criticality:
            confidence += 0.1
        if asset.data_classification:
            confidence += 0.1
        
        # Confianza por correlaciones
        if correlations:
            confidence += min(0.2, len(correlations) * 0.05)
        
        return min(1.0, confidence)
    
    def _generate_recommendations(self, vulnerability: VulnerabilityContext, asset: AssetContext, score: float) -> List[str]:
        """Genera recomendaciones basadas en el an谩lisis."""
        recommendations = []
        
        # Recomendaciones por nivel de riesgo
        if score >= 9.0:
            recommendations.extend([
                " ACCIN INMEDIATA: Aplicar parche o mitigaci贸n en las pr贸ximas 24 horas",
                "Aislar el sistema afectado si es posible",
                "Implementar monitoreo continuo"
            ])
        elif score >= 7.0:
            recommendations.extend([
                "锔 ALTA PRIORIDAD: Aplicar parche en los pr贸ximos 7 d铆as",
                "Implementar controles compensatorios"
            ])
        elif score >= 4.0:
            recommendations.extend([
                " PRIORIDAD MEDIA: Incluir en pr贸ximo ciclo de parches (30 d铆as)",
                "Evaluar controles existentes"
            ])
        
        # Recomendaciones espec铆ficas por vulnerabilidad
        if vulnerability.exploit_availability:
            recommendations.append("Exploit p煤blico disponible - priorizar remediaci贸n")
        
        if vulnerability.in_cisa_kev:
            recommendations.append("Vulnerabilidad en CISA KEV - seguir directrices federales")
        
        if vulnerability.active_exploitation:
            recommendations.append("Explotaci贸n activa detectada - implementar detecci贸n de IoCs")
        
        if vulnerability.patch_available and vulnerability.age_days > 30:
            recommendations.append("Parche disponible hace m谩s de 30 d铆as - aplicar urgentemente")
        
        # Recomendaciones por contexto empresarial
        if asset.business_criticality == BusinessCriticality.CRITICAL:
            recommendations.append("Sistema cr铆tico - considerar mantenimiento de emergencia")
        
        if asset.compliance_requirements:
            recommendations.append(f"Cumplimiento normativo requerido: {', '.join(asset.compliance_requirements)}")
        
        if asset.data_classification in ['restricted', 'confidential']:
            recommendations.append("Datos sensibles - evaluar impacto en privacidad")
        
        # Recomendaciones por vector de ataque
        if vulnerability.attack_vector == 'network':
            recommendations.append("Vector de red - considerar segmentaci贸n y firewall")
        
        return recommendations
    
    def _create_fallback_score(self, vulnerability: VulnerabilityContext) -> RiskScore:
        """Crea puntuaci贸n de fallback en caso de error."""
        base_score = vulnerability.cvss_base_score
        risk_level = self._determine_risk_level(base_score)
        
        return RiskScore(
            base_score=base_score,
            contextual_score=base_score,
            business_impact_score=base_score,
            exploitability_score=base_score,
            temporal_score=base_score,
            environmental_score=base_score,
            final_score=base_score,
            risk_level=risk_level,
            confidence=0.3,  # Baja confianza
            contributing_factors={'cvss_base': base_score},
            recommendations=["Puntuaci贸n basada solo en CVSS - revisar contexto"]
        )
    
    def calculate_portfolio_risk(self, vulnerabilities_with_context: List[Tuple[VulnerabilityContext, AssetContext]]) -> Dict[str, Any]:
        """Calcula riesgo a nivel de portafolio."""
        if not vulnerabilities_with_context:
            return {'portfolio_risk_score': 0, 'risk_distribution': {}, 'top_risks': []}
        
        # Calcular puntuaciones individuales
        scores = []
        for vuln, asset in vulnerabilities_with_context:
            score = self.calculate_intelligent_score(vuln, asset)
            scores.append(score)
        
        # Distribuci贸n de riesgo
        risk_distribution = Counter(score.risk_level for score in scores)
        
        # Top riesgos
        top_risks = sorted(scores, key=lambda x: x.final_score, reverse=True)[:10]
        
        # Puntuaci贸n de portafolio (promedio ponderado)
        if scores:
            # Ponderar por confianza
            weighted_scores = [score.final_score * score.confidence for score in scores]
            total_confidence = sum(score.confidence for score in scores)
            portfolio_score = sum(weighted_scores) / total_confidence if total_confidence > 0 else 0
        else:
            portfolio_score = 0
        
        return {
            'portfolio_risk_score': round(portfolio_score, 2),
            'portfolio_risk_level': self._determine_risk_level(portfolio_score),
            'total_vulnerabilities': len(scores),
            'risk_distribution': dict(risk_distribution),
            'average_confidence': round(sum(s.confidence for s in scores) / len(scores), 2) if scores else 0,
            'top_risks': [{
                'score': score.final_score,
                'risk_level': score.risk_level,
                'confidence': score.confidence
            } for score in top_risks]
        }


# ============================================================================
# FUNCIONES DE UTILIDAD
# ============================================================================

def create_asset_context(
    asset_id: str,
    asset_type: str,
    business_criticality: str = "medium",
    data_classification: str = "internal",
    **kwargs
) -> AssetContext:
    """Factory function para crear contexto de activo."""
    return AssetContext(
        asset_id=asset_id,
        asset_type=AssetType(asset_type),
        business_criticality=BusinessCriticality(business_criticality),
        data_classification=data_classification,
        compliance_requirements=kwargs.get('compliance_requirements', []),
        business_functions=kwargs.get('business_functions', []),
        user_base_size=kwargs.get('user_base_size', 0),
        revenue_impact=kwargs.get('revenue_impact', 0.0),
        availability_requirement=kwargs.get('availability_requirement', 0.99)
    )


def create_vulnerability_context(
    vulnerability_id: str,
    cvss_base_score: float,
    severity: str,
    **kwargs
) -> VulnerabilityContext:
    """Factory function para crear contexto de vulnerabilidad."""
    return VulnerabilityContext(
        vulnerability_id=vulnerability_id,
        cvss_base_score=cvss_base_score,
        severity=severity,
        exploitability=kwargs.get('exploitability', 0.5),
        exploit_availability=kwargs.get('exploit_availability', False),
        attack_vector=kwargs.get('attack_vector', 'network'),
        attack_complexity=kwargs.get('attack_complexity', 'low'),
        privileges_required=kwargs.get('privileges_required', 'none'),
        user_interaction=kwargs.get('user_interaction', 'none'),
        scope=kwargs.get('scope', 'unchanged'),
        confidentiality_impact=kwargs.get('confidentiality_impact', 'none'),
        integrity_impact=kwargs.get('integrity_impact', 'none'),
        availability_impact=kwargs.get('availability_impact', 'none'),
        age_days=kwargs.get('age_days', 0),
        patch_available=kwargs.get('patch_available', False),
        in_cisa_kev=kwargs.get('in_cisa_kev', False),
        active_exploitation=kwargs.get('active_exploitation', False)
    )


def create_scoring_engine() -> IntelligentScoringEngine:
    """Factory function para crear motor de puntuaci贸n."""
    return IntelligentScoringEngine()