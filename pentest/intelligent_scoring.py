#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de puntuación inteligente para evaluación de riesgo contextual.
Calcula puntuaciones de riesgo considerando múltiples factores y contexto empresarial.
"""

import logging
import math
from collections import defaultdict, Counter
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set, Tuple
from enum import Enum

log = logging.getLogger(__name__)


class BusinessCriticality(Enum):
    """Niveles de criticidad empresarial."""
    CRITICAL = "critical"  # Sistemas críticos para el negocio
    HIGH = "high"         # Sistemas importantes
    MEDIUM = "medium"     # Sistemas estándar
    LOW = "low"          # Sistemas de desarrollo/testing


class AssetType(Enum):
    """Tipos de activos."""
    WEB_APPLICATION = "web_application"
    DATABASE = "database"
    API = "api"
    INFRASTRUCTURE = "infrastructure"
    NETWORK_DEVICE = "network_device"
    ENDPOINT = "endpoint"


@dataclass
class AssetContext:
    """Contexto de un activo."""
    asset_id: str
    asset_type: AssetType
    business_criticality: BusinessCriticality
    data_classification: str  # public, internal, confidential, restricted
    compliance_requirements: List[str] = field(default_factory=list)
    business_functions: List[str] = field(default_factory=list)
    user_base_size: int = 0
    revenue_impact: float = 0.0  # Impacto en ingresos (0-1)
    availability_requirement: float = 0.99  # SLA de disponibilidad
    

@dataclass
class VulnerabilityContext:
    """Contexto de una vulnerabilidad."""
    vulnerability_id: str
    cvss_base_score: float
    severity: str
    exploitability: float  # 0-1
    exploit_availability: bool
    attack_vector: str  # network, adjacent, local, physical
    attack_complexity: str  # low, high
    privileges_required: str  # none, low, high
    user_interaction: str  # none, required
    scope: str  # unchanged, changed
    confidentiality_impact: str  # none, low, high
    integrity_impact: str  # none, low, high
    availability_impact: str  # none, low, high
    age_days: int = 0
    patch_available: bool = False
    in_cisa_kev: bool = False
    active_exploitation: bool = False


@dataclass
class RiskScore:
    """Puntuación de riesgo calculada."""
    base_score: float
    contextual_score: float
    business_impact_score: float
    exploitability_score: float
    temporal_score: float
    environmental_score: float
    final_score: float
    risk_level: str
    confidence: float
    contributing_factors: Dict[str, float]
    recommendations: List[str]


class IntelligentScoringEngine:
    """Motor de puntuación inteligente para evaluación de riesgo."""
    
    def __init__(self):
        self.log = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        
        # Pesos para diferentes factores de riesgo
        self.weights = {
            'cvss_base': 0.25,
            'exploitability': 0.20,
            'business_impact': 0.20,
            'temporal_factors': 0.15,
            'environmental': 0.10,
            'correlation_bonus': 0.10
        }
        
        # Multiplicadores por criticidad empresarial
        self.criticality_multipliers = {
            BusinessCriticality.CRITICAL: 1.5,
            BusinessCriticality.HIGH: 1.2,
            BusinessCriticality.MEDIUM: 1.0,
            BusinessCriticality.LOW: 0.7
        }
        
        # Multiplicadores por clasificación de datos
        self.data_classification_multipliers = {
            'restricted': 1.4,
            'confidential': 1.2,
            'internal': 1.0,
            'public': 0.8
        }
        
        # Multiplicadores por vector de ataque
        self.attack_vector_multipliers = {
            'network': 1.2,
            'adjacent': 1.0,
            'local': 0.8,
            'physical': 0.6
        }
        
        # Base de conocimiento de amenazas
        self.threat_intelligence = {
            'trending_attacks': ['sql-injection', 'xss', 'rce', 'auth-bypass'],
            'seasonal_threats': {},
            'industry_specific': {}
        }
    
    def calculate_intelligent_score(
        self, 
        vulnerability: VulnerabilityContext,
        asset: AssetContext,
        correlations: List[Dict[str, Any]] = None,
        threat_context: Dict[str, Any] = None
    ) -> RiskScore:
        """Calcula puntuación de riesgo inteligente."""
        
        try:
            # 1. Puntuación base CVSS
            base_score = self._calculate_base_score(vulnerability)
            
            # 2. Puntuación de explotabilidad
            exploitability_score = self._calculate_exploitability_score(vulnerability, threat_context)
            
            # 3. Impacto empresarial
            business_impact_score = self._calculate_business_impact_score(vulnerability, asset)
            
            # 4. Factores temporales
            temporal_score = self._calculate_temporal_score(vulnerability)
            
            # 5. Factores ambientales
            environmental_score = self._calculate_environmental_score(vulnerability, asset)
            
            # 6. Bonus por correlaciones
            correlation_bonus = self._calculate_correlation_bonus(correlations or [])
            
            # Calcular puntuación final ponderada
            final_score = (
                base_score * self.weights['cvss_base'] +
                exploitability_score * self.weights['exploitability'] +
                business_impact_score * self.weights['business_impact'] +
                temporal_score * self.weights['temporal_factors'] +
                environmental_score * self.weights['environmental'] +
                correlation_bonus * self.weights['correlation_bonus']
            )
            
            # Aplicar multiplicadores contextuales
            contextual_multiplier = self._calculate_contextual_multiplier(asset, vulnerability)
            contextual_score = final_score * contextual_multiplier
            
            # Normalizar a escala 0-10
            normalized_score = min(10.0, max(0.0, contextual_score))
            
            # Determinar nivel de riesgo
            risk_level = self._determine_risk_level(normalized_score)
            
            # Calcular confianza
            confidence = self._calculate_confidence(vulnerability, asset, correlations)
            
            # Generar recomendaciones
            recommendations = self._generate_recommendations(vulnerability, asset, normalized_score)
            
            return RiskScore(
                base_score=base_score,
                contextual_score=contextual_score,
                business_impact_score=business_impact_score,
                exploitability_score=exploitability_score,
                temporal_score=temporal_score,
                environmental_score=environmental_score,
                final_score=normalized_score,
                risk_level=risk_level,
                confidence=confidence,
                contributing_factors={
                    'cvss_base': base_score,
                    'exploitability': exploitability_score,
                    'business_impact': business_impact_score,
                    'temporal': temporal_score,
                    'environmental': environmental_score,
                    'correlation_bonus': correlation_bonus,
                    'contextual_multiplier': contextual_multiplier
                },
                recommendations=recommendations
            )
            
        except Exception as e:
            self.log.error(f"Error calculando puntuación inteligente: {e}")
            # Fallback a puntuación CVSS básica
            return self._create_fallback_score(vulnerability)
    
    def _calculate_base_score(self, vulnerability: VulnerabilityContext) -> float:
        """Calcula puntuación base normalizada."""
        return vulnerability.cvss_base_score
    
    def _calculate_exploitability_score(self, vulnerability: VulnerabilityContext, threat_context: Dict[str, Any] = None) -> float:
        """Calcula puntuación de explotabilidad."""
        score = vulnerability.exploitability * 10
        
        # Bonus por disponibilidad de exploit
        if vulnerability.exploit_availability:
            score += 2.0
        
        # Bonus por explotación activa
        if vulnerability.active_exploitation:
            score += 3.0
        
        # Bonus por CISA KEV
        if vulnerability.in_cisa_kev:
            score += 2.5
        
        # Ajuste por complejidad de ataque
        if vulnerability.attack_complexity == 'low':
            score += 1.0
        elif vulnerability.attack_complexity == 'high':
            score -= 0.5
        
        # Ajuste por privilegios requeridos
        if vulnerability.privileges_required == 'none':
            score += 1.5
        elif vulnerability.privileges_required == 'low':
            score += 0.5
        
        # Ajuste por interacción del usuario
        if vulnerability.user_interaction == 'none':
            score += 1.0
        
        # Contexto de amenazas
        if threat_context:
            trending_multiplier = threat_context.get('trending_multiplier', 1.0)
            score *= trending_multiplier
        
        return min(10.0, max(0.0, score))
    
    def _calculate_business_impact_score(self, vulnerability: VulnerabilityContext, asset: AssetContext) -> float:
        """Calcula impacto empresarial."""
        # Impacto base por CIA
        cia_impacts = {
            'high': 3.0,
            'low': 1.0,
            'none': 0.0
        }
        
        confidentiality_impact = cia_impacts.get(vulnerability.confidentiality_impact, 0)
        integrity_impact = cia_impacts.get(vulnerability.integrity_impact, 0)
        availability_impact = cia_impacts.get(vulnerability.availability_impact, 0)
        
        base_impact = (confidentiality_impact + integrity_impact + availability_impact) / 3
        
        # Multiplicador por criticidad empresarial
        criticality_multiplier = self.criticality_multipliers[asset.business_criticality]
        
        # Multiplicador por clasificación de datos
        data_multiplier = self.data_classification_multipliers.get(asset.data_classification, 1.0)
        
        # Ajuste por tamaño de base de usuarios
        user_multiplier = 1.0
        if asset.user_base_size > 10000:
            user_multiplier = 1.3
        elif asset.user_base_size > 1000:
            user_multiplier = 1.1
        
        # Ajuste por impacto en ingresos
        revenue_multiplier = 1.0 + asset.revenue_impact
        
        # Ajuste por requisitos de disponibilidad
        if availability_impact > 0 and asset.availability_requirement > 0.99:
            availability_multiplier = 1.2
        else:
            availability_multiplier = 1.0
        
        # Ajuste por cumplimiento normativo
        compliance_multiplier = 1.0
        if asset.compliance_requirements:
            compliance_multiplier = 1.0 + (len(asset.compliance_requirements) * 0.1)
        
        final_score = (
            base_impact * 
            criticality_multiplier * 
            data_multiplier * 
            user_multiplier * 
            revenue_multiplier * 
            availability_multiplier * 
            compliance_multiplier
        )
        
        return min(10.0, max(0.0, final_score))
    
    def _calculate_temporal_score(self, vulnerability: VulnerabilityContext) -> float:
        """Calcula factores temporales."""
        base_score = vulnerability.cvss_base_score
        
        # Ajuste por edad de la vulnerabilidad
        age_penalty = 0
        if vulnerability.age_days > 365:  # Más de 1 año
            age_penalty = 1.0
        elif vulnerability.age_days > 180:  # Más de 6 meses
            age_penalty = 0.5
        elif vulnerability.age_days > 90:   # Más de 3 meses
            age_penalty = 0.2
        
        # Bonus por disponibilidad de parche
        patch_adjustment = 0
        if vulnerability.patch_available:
            # Si hay parche disponible, el riesgo aumenta por no aplicarlo
            if vulnerability.age_days > 30:  # Parche disponible hace más de 30 días
                patch_adjustment = 1.5
            else:
                patch_adjustment = 0.5
        
        # Ajuste por explotación activa reciente
        exploitation_bonus = 0
        if vulnerability.active_exploitation:
            exploitation_bonus = 2.0
        
        temporal_score = base_score + age_penalty + patch_adjustment + exploitation_bonus
        
        return min(10.0, max(0.0, temporal_score))
    
    def _calculate_environmental_score(self, vulnerability: VulnerabilityContext, asset: AssetContext) -> float:
        """Calcula factores ambientales."""
        base_score = vulnerability.cvss_base_score
        
        # Ajuste por vector de ataque
        attack_vector_multiplier = self.attack_vector_multipliers.get(vulnerability.attack_vector, 1.0)
        
        # Ajuste por tipo de activo
        asset_type_multiplier = {
            AssetType.WEB_APPLICATION: 1.2,  # Más expuesto
            AssetType.API: 1.1,
            AssetType.DATABASE: 1.3,         # Datos críticos
            AssetType.INFRASTRUCTURE: 1.0,
            AssetType.NETWORK_DEVICE: 1.1,
            AssetType.ENDPOINT: 0.9
        }.get(asset.asset_type, 1.0)
        
        # Ajuste por funciones empresariales
        business_function_multiplier = 1.0
        critical_functions = ['payment', 'authentication', 'data_processing', 'customer_data']
        if any(func in critical_functions for func in asset.business_functions):
            business_function_multiplier = 1.2
        
        environmental_score = base_score * attack_vector_multiplier * asset_type_multiplier * business_function_multiplier
        
        return min(10.0, max(0.0, environmental_score))
    
    def _calculate_correlation_bonus(self, correlations: List[Dict[str, Any]]) -> float:
        """Calcula bonus por correlaciones."""
        if not correlations:
            return 0.0
        
        # Bonus base por número de correlaciones
        correlation_count_bonus = min(3.0, len(correlations) * 0.5)
        
        # Bonus por confianza de correlaciones
        confidence_bonus = 0
        if correlations:
            avg_confidence = sum(c.get('confidence', 0) for c in correlations) / len(correlations)
            confidence_bonus = avg_confidence * 2.0
        
        # Bonus por multiplicador de riesgo
        risk_multiplier_bonus = 0
        max_risk_multiplier = max((c.get('risk_multiplier', 1.0) for c in correlations), default=1.0)
        if max_risk_multiplier > 1.5:
            risk_multiplier_bonus = (max_risk_multiplier - 1.0) * 2.0
        
        total_bonus = correlation_count_bonus + confidence_bonus + risk_multiplier_bonus
        
        return min(5.0, max(0.0, total_bonus))
    
    def _calculate_contextual_multiplier(self, asset: AssetContext, vulnerability: VulnerabilityContext) -> float:
        """Calcula multiplicador contextual general."""
        multiplier = 1.0
        
        # Multiplicador por criticidad empresarial
        multiplier *= self.criticality_multipliers[asset.business_criticality]
        
        # Multiplicador por clasificación de datos
        multiplier *= self.data_classification_multipliers.get(asset.data_classification, 1.0)
        
        # Multiplicador por scope de la vulnerabilidad
        if vulnerability.scope == 'changed':
            multiplier *= 1.2
        
        return multiplier
    
    def _determine_risk_level(self, score: float) -> str:
        """Determina nivel de riesgo basado en puntuación."""
        if score >= 9.0:
            return "Critical"
        elif score >= 7.0:
            return "High"
        elif score >= 4.0:
            return "Medium"
        elif score >= 1.0:
            return "Low"
        else:
            return "Info"
    
    def _calculate_confidence(self, vulnerability: VulnerabilityContext, asset: AssetContext, correlations: List[Dict[str, Any]]) -> float:
        """Calcula confianza en la puntuación."""
        confidence = 0.5  # Base
        
        # Confianza por completitud de datos de vulnerabilidad
        if vulnerability.cvss_base_score > 0:
            confidence += 0.2
        if vulnerability.exploit_availability is not None:
            confidence += 0.1
        if vulnerability.age_days > 0:
            confidence += 0.1
        
        # Confianza por completitud de contexto de activo
        if asset.business_criticality:
            confidence += 0.1
        if asset.data_classification:
            confidence += 0.1
        
        # Confianza por correlaciones
        if correlations:
            confidence += min(0.2, len(correlations) * 0.05)
        
        return min(1.0, confidence)
    
    def _generate_recommendations(self, vulnerability: VulnerabilityContext, asset: AssetContext, score: float) -> List[str]:
        """Genera recomendaciones basadas en el análisis."""
        recommendations = []
        
        # Recomendaciones por nivel de riesgo
        if score >= 9.0:
            recommendations.extend([
                "🚨 ACCIÓN INMEDIATA: Aplicar parche o mitigación en las próximas 24 horas",
                "Aislar el sistema afectado si es posible",
                "Implementar monitoreo continuo"
            ])
        elif score >= 7.0:
            recommendations.extend([
                "⚠️ ALTA PRIORIDAD: Aplicar parche en los próximos 7 días",
                "Implementar controles compensatorios"
            ])
        elif score >= 4.0:
            recommendations.extend([
                "📋 PRIORIDAD MEDIA: Incluir en próximo ciclo de parches (30 días)",
                "Evaluar controles existentes"
            ])
        
        # Recomendaciones específicas por vulnerabilidad
        if vulnerability.exploit_availability:
            recommendations.append("Exploit público disponible - priorizar remediación")
        
        if vulnerability.in_cisa_kev:
            recommendations.append("Vulnerabilidad en CISA KEV - seguir directrices federales")
        
        if vulnerability.active_exploitation:
            recommendations.append("Explotación activa detectada - implementar detección de IoCs")
        
        if vulnerability.patch_available and vulnerability.age_days > 30:
            recommendations.append("Parche disponible hace más de 30 días - aplicar urgentemente")
        
        # Recomendaciones por contexto empresarial
        if asset.business_criticality == BusinessCriticality.CRITICAL:
            recommendations.append("Sistema crítico - considerar mantenimiento de emergencia")
        
        if asset.compliance_requirements:
            recommendations.append(f"Cumplimiento normativo requerido: {', '.join(asset.compliance_requirements)}")
        
        if asset.data_classification in ['restricted', 'confidential']:
            recommendations.append("Datos sensibles - evaluar impacto en privacidad")
        
        # Recomendaciones por vector de ataque
        if vulnerability.attack_vector == 'network':
            recommendations.append("Vector de red - considerar segmentación y firewall")
        
        return recommendations
    
    def _create_fallback_score(self, vulnerability: VulnerabilityContext) -> RiskScore:
        """Crea puntuación de fallback en caso de error."""
        base_score = vulnerability.cvss_base_score
        risk_level = self._determine_risk_level(base_score)
        
        return RiskScore(
            base_score=base_score,
            contextual_score=base_score,
            business_impact_score=base_score,
            exploitability_score=base_score,
            temporal_score=base_score,
            environmental_score=base_score,
            final_score=base_score,
            risk_level=risk_level,
            confidence=0.3,  # Baja confianza
            contributing_factors={'cvss_base': base_score},
            recommendations=["Puntuación basada solo en CVSS - revisar contexto"]
        )
    
    def calculate_portfolio_risk(self, vulnerabilities_with_context: List[Tuple[VulnerabilityContext, AssetContext]]) -> Dict[str, Any]:
        """Calcula riesgo a nivel de portafolio."""
        if not vulnerabilities_with_context:
            return {'portfolio_risk_score': 0, 'risk_distribution': {}, 'top_risks': []}
        
        # Calcular puntuaciones individuales
        scores = []
        for vuln, asset in vulnerabilities_with_context:
            score = self.calculate_intelligent_score(vuln, asset)
            scores.append(score)
        
        # Distribución de riesgo
        risk_distribution = Counter(score.risk_level for score in scores)
        
        # Top riesgos
        top_risks = sorted(scores, key=lambda x: x.final_score, reverse=True)[:10]
        
        # Puntuación de portafolio (promedio ponderado)
        if scores:
            # Ponderar por confianza
            weighted_scores = [score.final_score * score.confidence for score in scores]
            total_confidence = sum(score.confidence for score in scores)
            portfolio_score = sum(weighted_scores) / total_confidence if total_confidence > 0 else 0
        else:
            portfolio_score = 0
        
        return {
            'portfolio_risk_score': round(portfolio_score, 2),
            'portfolio_risk_level': self._determine_risk_level(portfolio_score),
            'total_vulnerabilities': len(scores),
            'risk_distribution': dict(risk_distribution),
            'average_confidence': round(sum(s.confidence for s in scores) / len(scores), 2) if scores else 0,
            'top_risks': [{
                'score': score.final_score,
                'risk_level': score.risk_level,
                'confidence': score.confidence
            } for score in top_risks]
        }


# ============================================================================
# FUNCIONES DE UTILIDAD
# ============================================================================

def create_asset_context(
    asset_id: str,
    asset_type: str,
    business_criticality: str = "medium",
    data_classification: str = "internal",
    **kwargs
) -> AssetContext:
    """Factory function para crear contexto de activo."""
    return AssetContext(
        asset_id=asset_id,
        asset_type=AssetType(asset_type),
        business_criticality=BusinessCriticality(business_criticality),
        data_classification=data_classification,
        compliance_requirements=kwargs.get('compliance_requirements', []),
        business_functions=kwargs.get('business_functions', []),
        user_base_size=kwargs.get('user_base_size', 0),
        revenue_impact=kwargs.get('revenue_impact', 0.0),
        availability_requirement=kwargs.get('availability_requirement', 0.99)
    )


def create_vulnerability_context(
    vulnerability_id: str,
    cvss_base_score: float,
    severity: str,
    **kwargs
) -> VulnerabilityContext:
    """Factory function para crear contexto de vulnerabilidad."""
    return VulnerabilityContext(
        vulnerability_id=vulnerability_id,
        cvss_base_score=cvss_base_score,
        severity=severity,
        exploitability=kwargs.get('exploitability', 0.5),
        exploit_availability=kwargs.get('exploit_availability', False),
        attack_vector=kwargs.get('attack_vector', 'network'),
        attack_complexity=kwargs.get('attack_complexity', 'low'),
        privileges_required=kwargs.get('privileges_required', 'none'),
        user_interaction=kwargs.get('user_interaction', 'none'),
        scope=kwargs.get('scope', 'unchanged'),
        confidentiality_impact=kwargs.get('confidentiality_impact', 'none'),
        integrity_impact=kwargs.get('integrity_impact', 'none'),
        availability_impact=kwargs.get('availability_impact', 'none'),
        age_days=kwargs.get('age_days', 0),
        patch_available=kwargs.get('patch_available', False),
        in_cisa_kev=kwargs.get('in_cisa_kev', False),
        active_exploitation=kwargs.get('active_exploitation', False)
    )


def create_scoring_engine() -> IntelligentScoringEngine:
    """Factory function para crear motor de puntuación."""
    return IntelligentScoringEngine()