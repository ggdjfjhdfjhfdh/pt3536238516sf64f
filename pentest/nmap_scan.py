import json
import logging
import os
import re
import subprocess
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Dict, Any
from functools import partial

from defusedxml import ElementTree as DefusedElementTree

from pentest.runners import run_cmd
from pentest.exceptions import ScanError
from pentest.config import DEFAULT_TIMEOUT

COMMON_PORTS = "21,22,23,25,53,80,110,139,143,443,445,3306,3389,8080,8443"
FAST_FLAGS   = ["-T4", "--open"]
FULL_FLAGS   = ["-p-", "-sC", "-A", *FAST_FLAGS]

@dataclass
class NmapFinding:
    host: str
    port: int
    protocol: str
    service: str
    product: str = ''
    version: str = ''
    extrainfo: str = ''
    url: str = ''
    status: str = ''

log = logging.getLogger(__name__)

def build_nmap_cmd(host: str, full: bool, unprivileged: bool = False) -> List[str]:
    base = ["nmap", "-sV", "-oX", "-"]
    if unprivileged:
        # If unprivileged, change -sS (default) to -sT (TCP connect scan)
        # and add --unprivileged flag
        base = ["nmap", "--unprivileged", "-sT", "-oX", "-"]
        base += [arg for arg in (FULL_FLAGS if full else ["-p", COMMON_PORTS, *FAST_FLAGS]) if arg not in ["-sV"]]
    else:
        base += FULL_FLAGS if full else ["-p", COMMON_PORTS, *FAST_FLAGS]
    return base + [host]

def _run_nmap_for_host(host_data: Dict[str, Any], full_scan: bool, tmp_dir: Path) -> Dict[str, Any]:
    host = host_data.get("host")
    url = host_data.get("url")

    if not host:
        return {}

    # Sanitize host input to prevent command injection
    if not re.match(r"^[\w\.:-]+$", host):
        log.error(f"Host inv√°lido detectado: {host}. Saltando escaneo.")
        return {}

    log.info(f"Escaneando puertos para {host}...")
    log.debug(f"Iniciando _run_nmap_for_host para {host}")
    
    timeout = DEFAULT_TIMEOUT * (10 if full_scan else 1)
    nmap_output = ""
    host_findings: Dict[str, Any] = {"url": url, "ports": {}}

    try:
        nmap_cmd = build_nmap_cmd(host, full_scan)
        log.debug(f"Comando Nmap a ejecutar: {' '.join(nmap_cmd)}")
        log.debug(f"Timeout configurado para Nmap: {timeout} segundos.")
        nmap_output = run_cmd(nmap_cmd, timeout=timeout, ignore=False)
        log.debug(f"Nmap finaliz√≥ para {host}. Procesando salida.")
    except subprocess.CalledProcessError as e:
        if "raw socket" in e.stderr.lower():
            log.warning(f"Error de raw socket para {host}. Reintentando con --unprivileged -sT.")
            nmap_cmd = build_nmap_cmd(host, full_scan, unprivileged=True)
            try:
                log.debug(f"Comando Nmap (unprivileged) a ejecutar: {' '.join(nmap_cmd)}")
                nmap_output = run_cmd(nmap_cmd, timeout=timeout, ignore=False)
            except subprocess.CalledProcessError as e_unpriv:
                log.error(f"Nmap scan failed for {host} even with --unprivileged: {e_unpriv.stderr}")
                log.debug(f"_run_nmap_for_host finaliz√≥ con error para {host}")
                return {}
        else:
            log.error(f"Nmap scan failed for {host}: {e.stderr}")
            log.debug(f"_run_nmap_for_host finaliz√≥ con error para {host}")
            return {}
    except Exception as e:
        log.error(f"Error inesperado durante el escaneo Nmap para {host}: {e}")
        log.debug(f"_run_nmap_for_host finaliz√≥ con error para {host}")
        return {}

    log.debug(f"Salida cruda de Nmap para {host}:\n{nmap_output[:1024]}..." if len(nmap_output) > 1024 else nmap_output)
    
    # Save XML for auditing
    xml_output_path = tmp_dir / f"{host}.xml"
    with open(xml_output_path, "w") as f:
        f.write(nmap_output)
    log.debug(f"XML de Nmap guardado en {xml_output_path}")

    try:
        root = DefusedElementTree.fromstring(nmap_output)
        for host_elem in root.findall('host'):
            address = host_elem.find('address').get('addr')
            # Ensure we are processing the correct host if Nmap output contains multiple
            if address != host:
                continue

            for port_elem in host_elem.findall('ports/port'):
                port_id = port_elem.get('portid')
                protocol = port_elem.get('protocol')
                state_elem = port_elem.find('state')
                state = state_elem.get('state') if state_elem is not None else 'unknown'
                
                service_elem = port_elem.find('service')
                service_name = service_elem.get('name') if service_elem is not None else 'unknown'
                product = service_elem.get('product') if service_elem is not None else ''
                version = service_elem.get('version') if service_elem is not None else ''
                extrainfo = service_elem.get('extrainfo') if service_elem is not None else ''

                if state == "open":
                    host_findings["ports"][port_id] = asdict(NmapFinding(
                        host=address,
                        port=int(port_id),
                        protocol=protocol,
                        service=service_name,
                        product=product,
                        version=version,
                        extrainfo=extrainfo,
                        url=url,
                        status=state
                    ))
    except DefusedElementTree.ParseError as e:
        log.warning(f"Error al parsear la salida XML de Nmap para {host}: {e}", exc_info=True)
    except Exception as e:
        log.warning(f"Error procesando la salida de Nmap para {host}: {str(e)}")

    log.debug(f"_run_nmap_for_host finaliz√≥ exitosamente para {host}")
    return {host: host_findings}

from typing import List, Dict, Any, Optional

def nmap_scan(httpx_file: Optional[Path], tmp_dir: Path, full_scan: bool = False) -> Path:
    """Performs port and service scanning using Nmap on active hosts.
    
    Args:
        httpx_file: Path to the JSON file containing httpx results (active hosts).
        tmp_dir: Temporary directory for storing results.
        full_scan: If True, performs a more exhaustive scan (all ports, default scripts).
        
    Returns:
        Path to the JSON file with Nmap findings.
        
    Raises:
        NmapScanError: If the Nmap scan fails.
    """
    log.info("üîç Iniciando escaneo de puertos y servicios con Nmap.")
    
    output_file = tmp_dir / "nmap.json"
    nmap_findings: Dict[str, Dict[str, Any]] = {}

    if httpx_file is None or not httpx_file.exists():
        log.warning(f"Archivo httpx no encontrado o es None: {httpx_file}. No se realizar√° escaneo con Nmap.")
        with open(output_file, "w") as f:
            json.dump({}, f)
        return output_file

    try:
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)

        # Paralelizar escaneos por host
        _scan_host = partial(_run_nmap_for_host, full_scan=full_scan, tmp_dir=tmp_dir)
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {executor.submit(_scan_host, host_data): host_data for host_data in httpx_data}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    nmap_findings.update(result)

        # Convert findings back to a list of dictionaries for consistency with other scan outputs
        final_findings_list = []
        for host_addr, data in nmap_findings.items():
            for port_id, port_data in data["ports"].items():
                # The port_data is already a dictionary from asdict(NmapFinding)
                final_findings_list.append(port_data)

        with open(output_file, "w") as f:
            json.dump(final_findings_list, f, indent=2)

        log.info("‚úÖ Escaneo de puertos y servicios completado: %d hallazgos", len(final_findings_list))
        return output_file

    except Exception as e:
        log.error(f"Error durante el escaneo Nmap: {e}")
        raise ScanError(f"Error durante el escaneo Nmap: {e}") from e