import json
import logging
import os
import re
import subprocess
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
from functools import partial

from defusedxml import ElementTree as DefusedElementTree

from pentest.runners import run_cmd
from pentest.exceptions import ScanError
from pentest.config import DEFAULT_TIMEOUT

COMMON_PORTS = "21,22,23,25,53,80,110,139,143,443,445,3306,3389,8080,8443"
FAST_FLAGS   = ["-T4", "--open"]
FULL_FLAGS   = ["-p-", "-sC", "-A", *FAST_FLAGS]

@dataclass
class NmapFinding:
    host: str
    port: int
    protocol: str
    service: str
    product: str = ''
    version: str = ''
    extrainfo: str = ''
    url: str = ''
    status: str = ''

log = logging.getLogger(__name__)

def build_nmap_cmd(host: str, full: bool, unprivileged: bool = False) -> List[str]:
    if unprivileged:
        # Modo no privilegiado: usar TCP connect scan sin flags que requieren root
        # Evitar -sC, -A y otros flags que requieren privilegios
        base = ["nmap", "--unprivileged", "-sT", "-sV", "-oX", "-"]
        if full:
            # Escaneo completo de todos los puertos pero sin scripts que requieren root
            base += ["-p-", "-T4", "--open"]
        else:
            # Escaneo r√°pido de puertos comunes
            base += ["-p", COMMON_PORTS, "-T4", "--open"]
    else:
        # Modo privilegiado normal
        base = ["nmap", "-sV", "-oX", "-"]
        base += FULL_FLAGS if full else ["-p", COMMON_PORTS, *FAST_FLAGS]
    
    return base + [host]

def _run_nmap_for_host(host_data: Dict[str, Any], full_scan: bool, tmp_dir: Path) -> Dict[str, Any]:
    host = host_data.get("host")
    url = host_data.get("url")

    if not host:
        return {}

    # Sanitize host input to prevent command injection
    if not re.match(r"^[\w\.:-]+$", host):
        log.error(f"Host inv√°lido detectado: {host}. Saltando escaneo.")
        return {}

    log.info(f"Escaneando puertos para {host}...")
    log.debug(f"Iniciando _run_nmap_for_host para {host}")
    
    timeout = DEFAULT_TIMEOUT * (10 if full_scan else 1)
    nmap_output = ""
    host_findings: Dict[str, Any] = {"url": url, "ports": {}}

    try:
        nmap_cmd = build_nmap_cmd(host, full_scan)
        log.debug(f"Comando Nmap a ejecutar: {' '.join(nmap_cmd)}")
        log.debug(f"Timeout configurado para Nmap: {timeout} segundos.")
        nmap_output = run_cmd(nmap_cmd, timeout=timeout, ignore=False)
        log.debug(f"Nmap finaliz√≥ para {host}. Procesando salida.")
    except subprocess.CalledProcessError as e:
        # Verificar si el error es de raw socket en stderr
        stderr_content = getattr(e, 'stderr', '') or ''
        stdout_content = getattr(e, 'stdout', '') or ''
        log.error(f"CalledProcessError capturado para {host}. C√≥digo de salida: {e.returncode}")
        log.error(f"stderr completo: '{stderr_content}'")
        log.error(f"stdout completo: '{stdout_content}'")
        
        # Verificar m√∫ltiples patrones de error de permisos
        permission_errors = [
            "raw socket",
            "operation not permitted", 
            "permission denied",
            "couldn't open a raw socket"
        ]
        
        has_permission_error = any(pattern in stderr_content.lower() for pattern in permission_errors)
        log.info(f"¬øDetectado error de permisos para {host}? {has_permission_error}")
        
        if has_permission_error:
            log.warning(f"Error de permisos detectado para {host}. Reintentando con --unprivileged -sT.")
            nmap_cmd_unpriv = build_nmap_cmd(host, full_scan, unprivileged=True)
            log.info(f"Comando unprivileged a ejecutar: {' '.join(nmap_cmd_unpriv)}")
            try:
                log.info(f"Iniciando reintento unprivileged para {host}...")
                nmap_output = run_cmd(nmap_cmd_unpriv, timeout=timeout, ignore=False)
                log.info(f"‚úÖ Comando unprivileged exitoso para {host}. Longitud de salida: {len(nmap_output)}")
            except subprocess.CalledProcessError as e_unpriv:
                stderr_unpriv = getattr(e_unpriv, 'stderr', '') or ''
                stdout_unpriv = getattr(e_unpriv, 'stdout', '') or ''
                log.error(f"‚ùå Nmap unprivileged tambi√©n fall√≥ para {host}. C√≥digo: {e_unpriv.returncode}")
                log.error(f"stderr unprivileged: '{stderr_unpriv}'")
                log.error(f"stdout unprivileged: '{stdout_unpriv}'")
                return {}
            except Exception as e_unpriv:
                log.error(f"‚ùå Error inesperado en comando unprivileged para {host}: {type(e_unpriv).__name__}: {e_unpriv}")
                return {}
        else:
            log.error(f"‚ùå Nmap fall√≥ para {host} (no es error de permisos): {stderr_content}")
            return {}
    except Exception as e:
        log.error(f"Error inesperado durante el escaneo Nmap para {host}: {e}")
        log.debug(f"_run_nmap_for_host finaliz√≥ con error para {host}")
        return {}

    log.debug(f"Salida cruda de Nmap para {host}:\n{nmap_output[:1024]}..." if len(nmap_output) > 1024 else nmap_output)
    
    # Verificar que tenemos salida XML v√°lida
    if not nmap_output.strip():
        log.warning(f"‚ö†Ô∏è Salida de Nmap vac√≠a para {host}")
        return {}
    
    if not nmap_output.strip().startswith('<?xml'):
        log.warning(f"‚ö†Ô∏è Salida de Nmap no parece ser XML v√°lido para {host}. Primeros 200 caracteres: {nmap_output[:200]}")
        return {}
    
    # Save XML for auditing
    xml_output_path = tmp_dir / f"{host}.xml"
    with open(xml_output_path, "w") as f:
        f.write(nmap_output)
    log.debug(f"XML de Nmap guardado en {xml_output_path}")
    log.info(f"üìÑ XML v√°lido recibido para {host}, procesando resultados...")

    try:
        root = DefusedElementTree.fromstring(nmap_output)
        for host_elem in root.findall('host'):
            address = host_elem.find('address').get('addr')
            # Ensure we are processing the correct host if Nmap output contains multiple
            if address != host:
                continue

            for port_elem in host_elem.findall('ports/port'):
                port_id = port_elem.get('portid')
                protocol = port_elem.get('protocol')
                state_elem = port_elem.find('state')
                state = state_elem.get('state') if state_elem is not None else 'unknown'
                
                service_elem = port_elem.find('service')
                service_name = service_elem.get('name') if service_elem is not None else 'unknown'
                product = service_elem.get('product') if service_elem is not None else ''
                version = service_elem.get('version') if service_elem is not None else ''
                extrainfo = service_elem.get('extrainfo') if service_elem is not None else ''

                if state == "open":
                    host_findings["ports"][port_id] = asdict(NmapFinding(
                        host=address,
                        port=int(port_id),
                        protocol=protocol,
                        service=service_name,
                        product=product,
                        version=version,
                        extrainfo=extrainfo,
                        url=url,
                        status=state
                    ))
    except DefusedElementTree.ParseError as e:
        log.warning(f"Error al parsear la salida XML de Nmap para {host}: {e}", exc_info=True)
    except Exception as e:
        log.warning(f"Error procesando la salida de Nmap para {host}: {str(e)}")

    log.debug(f"_run_nmap_for_host finaliz√≥ exitosamente para {host}")
    return {host: host_findings}

def nmap_scan(httpx_file: Optional[Path], tmp_dir: Path, full_scan: bool = False) -> Path:
    """Performs port and service scanning using Nmap on active hosts.
    
    Args:
        httpx_file: Path to the JSON file containing httpx results (active hosts).
        tmp_dir: Temporary directory for storing results.
        full_scan: If True, performs a more exhaustive scan (all ports, default scripts).
        
    Returns:
        Path to the JSON file with Nmap findings.
        
    Raises:
        NmapScanError: If the Nmap scan fails.
    """
    log.info("üîç Iniciando escaneo de puertos y servicios con Nmap.")
    
    output_file = tmp_dir / "nmap.json"
    nmap_findings: Dict[str, Dict[str, Any]] = {}

    if httpx_file is None or not httpx_file.exists():
        log.warning(f"Archivo httpx no encontrado o es None: {httpx_file}. No se realizar√° escaneo con Nmap.")
        with open(output_file, "w") as f:
            json.dump({}, f)
        return output_file

    try:
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)

        # Paralelizar escaneos por host
        _scan_host = partial(_run_nmap_for_host, full_scan=full_scan, tmp_dir=tmp_dir)
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {executor.submit(_scan_host, host_data): host_data for host_data in httpx_data}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    nmap_findings.update(result)

        # Convert findings back to a list of dictionaries for consistency with other scan outputs
        final_findings_list = []
        for host_addr, data in nmap_findings.items():
            for port_id, port_data in data["ports"].items():
                # The port_data is already a dictionary from asdict(NmapFinding)
                final_findings_list.append(port_data)

        with open(output_file, "w") as f:
            json.dump(final_findings_list, f, indent=2)

        log.info("‚úÖ Escaneo de puertos y servicios completado: %d hallazgos", len(final_findings_list))
        return output_file

    except Exception as e:
        log.error(f"Error durante el escaneo Nmap: {e}")
        raise ScanError(f"Error durante el escaneo Nmap: {e}") from e