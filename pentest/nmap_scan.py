import json
import logging
import os
import re
import subprocess
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
from functools import partial

from defusedxml import ElementTree as DefusedElementTree

from pentest.runners import run_cmd
from pentest.exceptions import ScanError
from pentest.config import DEFAULT_TIMEOUT

COMMON_PORTS = "21,22,23,25,53,80,110,139,143,443,445,3306,3389,8080,8443"
FAST_FLAGS   = ["-T4", "--open"]
FULL_FLAGS   = ["-p-", "-sC", "-A", *FAST_FLAGS]

@dataclass
class NmapFinding:
    host: str
    port: int
    protocol: str
    service: str
    product: str = ''
    version: str = ''
    extrainfo: str = ''
    url: str = ''
    status: str = ''

log = logging.getLogger(__name__)

def build_nmap_cmd(host: str, full: bool, unprivileged: bool = True) -> List[str]:
    if unprivileged:
        # Modo no privilegiado por defecto: usar TCP connect scan sin flags que requieren root
        # Evitar -sC, -A y otros flags que requieren privilegios
        base = ["nmap", "--unprivileged", "-sT", "-sV", "-oX", "-"]
        if full:
            # Escaneo completo de todos los puertos pero sin scripts que requieren root
            base += ["-p-", "-T4", "--open"]
        else:
            # Escaneo r√°pido de puertos comunes
            base += ["-p", COMMON_PORTS, "-T4", "--open"]
    else:
        # Modo privilegiado (solo para entornos locales con permisos)
        base = ["nmap", "-sV", "-oX", "-"]
        base += FULL_FLAGS if full else ["-p", COMMON_PORTS, *FAST_FLAGS]
    
    return base + [host]

def _run_nmap_for_host(host_data: Dict[str, Any], full_scan: bool, tmp_dir: Path) -> Dict[str, Any]:
    host = host_data.get("host")
    url = host_data.get("url")

    if not host:
        return {}

    # Sanitize host input to prevent command injection
    if not re.match(r"^[\w\.:-]+$", host):
        log.error(f"Host inv√°lido detectado: {host}. Saltando escaneo.")
        return {}

    log.info(f"Escaneando puertos para {host}...")
    log.debug(f"Iniciando _run_nmap_for_host para {host}")
    
    timeout = DEFAULT_TIMEOUT * (10 if full_scan else 1)
    nmap_output = ""
    host_findings: Dict[str, Any] = {"url": url, "ports": {}}

    try:
        # Usar modo sin privilegios por defecto para compatibilidad con contenedores
        nmap_cmd = build_nmap_cmd(host, full_scan, unprivileged=True)
        log.debug(f"Comando Nmap a ejecutar: {' '.join(nmap_cmd)}")
        log.debug(f"Timeout configurado para Nmap: {timeout} segundos.")
        nmap_output = run_cmd(nmap_cmd, timeout=timeout, ignore=False)
        log.debug(f"Nmap finaliz√≥ para {host}. Procesando salida.")
    except subprocess.CalledProcessError as e:
        stderr_content = getattr(e, 'stderr', '') or ''
        stdout_content = getattr(e, 'stdout', '') or ''
        log.error(f"‚ùå Nmap fall√≥ para {host}. C√≥digo de salida: {e.returncode}")
        log.error(f"stderr: '{stderr_content}'")
        log.error(f"stdout: '{stdout_content}'")
        return {}
    except Exception as e:
        log.error(f"Error inesperado durante el escaneo Nmap para {host}: {e}")
        log.debug(f"_run_nmap_for_host finaliz√≥ con error para {host}")
        return {}

    log.debug(f"Salida cruda de Nmap para {host}:\n{nmap_output[:1024]}..." if len(nmap_output) > 1024 else nmap_output)
    
    # Verificar que tenemos salida XML v√°lida
    if not nmap_output.strip():
        log.warning(f"‚ö†Ô∏è Salida de Nmap vac√≠a para {host}")
        return {}
    
    if not nmap_output.strip().startswith('<?xml'):
        log.warning(f"‚ö†Ô∏è Salida de Nmap no parece ser XML v√°lido para {host}. Primeros 200 caracteres: {nmap_output[:200]}")
        return {}
    
    # Save XML for auditing
    xml_output_path = tmp_dir / f"{host}.xml"
    with open(xml_output_path, "w") as f:
        f.write(nmap_output)
    log.debug(f"XML de Nmap guardado en {xml_output_path}")
    log.info(f"üìÑ XML v√°lido recibido para {host}, procesando resultados...")

    try:
        root = DefusedElementTree.fromstring(nmap_output)
        hosts_found = root.findall('host')
        log.debug(f"N√∫mero de hosts encontrados en XML: {len(hosts_found)}")
        
        for host_elem in hosts_found:
            address_elem = host_elem.find('address')
            if address_elem is None:
                log.warning(f"No se encontr√≥ elemento 'address' en host para {host}")
                continue
                
            address = address_elem.get('addr')
            log.debug(f"Procesando host con direcci√≥n: {address}")
            
            # Ensure we are processing the correct host if Nmap output contains multiple
            if address != host:
                log.debug(f"Saltando host {address}, no coincide con {host}")
                continue

            # Verificar si existe el elemento ports
            ports_elem = host_elem.find('ports')
            if ports_elem is None:
                log.info(f"No se encontr√≥ elemento 'ports' para {host} - posiblemente no hay puertos abiertos")
                continue
                
            port_elements = ports_elem.findall('port')
            log.debug(f"N√∫mero de puertos encontrados para {host}: {len(port_elements)}")
            
            for port_elem in port_elements:
                port_id = port_elem.get('portid')
                protocol = port_elem.get('protocol')
                state_elem = port_elem.find('state')
                state = state_elem.get('state') if state_elem is not None else 'unknown'
                
                log.debug(f"Puerto {port_id}/{protocol} en estado: {state}")
                
                service_elem = port_elem.find('service')
                service_name = service_elem.get('name') if service_elem is not None else 'unknown'
                product = service_elem.get('product') if service_elem is not None else ''
                version = service_elem.get('version') if service_elem is not None else ''
                extrainfo = service_elem.get('extrainfo') if service_elem is not None else ''

                if state == "open":
                    log.debug(f"A√±adiendo puerto abierto {port_id} para {host}")
                    host_findings["ports"][port_id] = asdict(NmapFinding(
                        host=address,
                        port=int(port_id),
                        protocol=protocol,
                        service=service_name,
                        product=product,
                        version=version,
                        extrainfo=extrainfo,
                        url=url,
                        status=state
                    ))
                else:
                    log.debug(f"Puerto {port_id} no est√° abierto (estado: {state})")
    except DefusedElementTree.ParseError as e:
        log.warning(f"Error al parsear la salida XML de Nmap para {host}: {e}", exc_info=True)
    except Exception as e:
        log.warning(f"Error procesando la salida de Nmap para {host}: {str(e)}")

    log.debug(f"_run_nmap_for_host finaliz√≥ exitosamente para {host}")
    return {host: host_findings}

def nmap_scan(httpx_file: Optional[Path], tmp_dir: Path, full_scan: bool = False) -> Path:
    """Performs port and service scanning using Nmap on active hosts.
    
    Args:
        httpx_file: Path to the JSON file containing httpx results (active hosts).
        tmp_dir: Temporary directory for storing results.
        full_scan: If True, performs a more exhaustive scan (all ports, default scripts).
        
    Returns:
        Path to the JSON file with Nmap findings.
        
    Raises:
        NmapScanError: If the Nmap scan fails.
    """
    log.info("üîç Iniciando escaneo de puertos y servicios con Nmap.")
    
    output_file = tmp_dir / "nmap.json"
    nmap_findings: Dict[str, Dict[str, Any]] = {}

    if httpx_file is None or not httpx_file.exists():
        log.warning(f"Archivo httpx no encontrado o es None: {httpx_file}. No se realizar√° escaneo con Nmap.")
        with open(output_file, "w") as f:
            json.dump({}, f)
        return output_file

    try:
        with open(httpx_file, "r") as f:
            httpx_data = json.load(f)

        # Paralelizar escaneos por host
        _scan_host = partial(_run_nmap_for_host, full_scan=full_scan, tmp_dir=tmp_dir)
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = {executor.submit(_scan_host, host_data): host_data for host_data in httpx_data}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    nmap_findings.update(result)

        # Convert findings back to a list of dictionaries for consistency with other scan outputs
        final_findings_list = []
        for host_addr, data in nmap_findings.items():
            for port_id, port_data in data["ports"].items():
                # The port_data is already a dictionary from asdict(NmapFinding)
                final_findings_list.append(port_data)

        with open(output_file, "w") as f:
            json.dump(final_findings_list, f, indent=2)

        log.info("‚úÖ Escaneo de puertos y servicios completado: %d hallazgos", len(final_findings_list))
        return output_file

    except Exception as e:
        log.error(f"Error durante el escaneo Nmap: {e}")
        raise ScanError(f"Error durante el escaneo Nmap: {e}") from e