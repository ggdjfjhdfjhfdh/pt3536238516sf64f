#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Escáner especializado para APIs REST, GraphQL y gRPC.
Parte de las mejoras del sistema de escaneo premium adaptativo.
"""

import json
import logging
import requests
import re
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from urllib.parse import urljoin, urlparse
from dataclasses import dataclass

log = logging.getLogger(__name__)

@dataclass
class APIEndpoint:
    """Representa un endpoint de API descubierto."""
    url: str
    method: str
    parameters: List[str]
    authentication_required: bool
    rate_limited: bool
    response_format: str
    security_issues: List[str]

class APIScanner:
    """Escáner especializado para APIs REST, GraphQL y gRPC."""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'APIScanner/1.0 (Security Testing)'
        })
        
        # Patrones comunes de APIs
        self.api_patterns = [
            r'/api/v\d+/',
            r'/api/',
            r'/rest/',
            r'/graphql',
            r'/v\d+/',
            r'/_api/',
            r'/api-docs',
            r'/swagger',
            r'/openapi'
        ]
        
        # Endpoints comunes a probar
        self.common_endpoints = [
            '/api/v1/users',
            '/api/v1/auth',
            '/api/v1/login',
            '/api/v1/admin',
            '/api/v1/config',
            '/api/v1/status',
            '/api/v1/health',
            '/api/v1/version',
            '/api/users',
            '/api/auth',
            '/api/login',
            '/rest/users',
            '/rest/auth',
            '/graphql',
            '/graphiql',
            '/api-docs',
            '/swagger.json',
            '/swagger-ui',
            '/openapi.json',
            '/docs',
            '/redoc'
        ]
    
    def scan_api_comprehensive(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Escaneo completo de APIs."""
        results = {
            'target': target,
            'rest_apis': {},
            'graphql_apis': {},
            'grpc_apis': {},
            'documentation': {},
            'security_issues': [],
            'endpoints_discovered': [],
            'scan_timestamp': time.time()
        }
        
        log.info(f"Iniciando escaneo completo de APIs para {target}")
        
        # 1. Descubrimiento de endpoints
        endpoints = self._discover_api_endpoints(target)
        results['endpoints_discovered'] = [ep.__dict__ for ep in endpoints]
        
        # 2. Escaneo REST API
        rest_results = self.scan_rest_api(target)
        results['rest_apis'] = rest_results
        
        # 3. Escaneo GraphQL
        graphql_results = self.scan_graphql(target)
        results['graphql_apis'] = graphql_results
        
        # 4. Escaneo gRPC
        grpc_results = self.scan_grpc(target)
        results['grpc_apis'] = grpc_results
        
        # 5. Búsqueda de documentación
        doc_results = self._scan_api_documentation(target)
        results['documentation'] = doc_results
        
        # 6. Análisis de seguridad general
        security_issues = self._analyze_api_security(target, endpoints)
        results['security_issues'] = security_issues
        
        return results
    
    def _discover_api_endpoints(self, target: str) -> List[APIEndpoint]:
        """Descubre endpoints de API."""
        endpoints = []
        
        # Probar endpoints comunes
        for endpoint in self.common_endpoints:
            full_url = urljoin(target, endpoint)
            try:
                response = self.session.get(full_url, timeout=self.timeout)
                if response.status_code in [200, 401, 403, 405]:
                    endpoint_obj = self._analyze_endpoint(full_url, response)
                    endpoints.append(endpoint_obj)
                    log.debug(f"Endpoint descubierto: {full_url}")
            except requests.RequestException:
                continue
        
        # Análisis de contenido web para encontrar más endpoints
        try:
            response = self.session.get(target, timeout=self.timeout)
            if response.status_code == 200:
                discovered_urls = self._extract_api_urls_from_content(response.text, target)
                for url in discovered_urls:
                    try:
                        api_response = self.session.get(url, timeout=self.timeout)
                        if api_response.status_code in [200, 401, 403, 405]:
                            endpoint_obj = self._analyze_endpoint(url, api_response)
                            endpoints.append(endpoint_obj)
                    except requests.RequestException:
                        continue
        except requests.RequestException:
            pass
        
        return endpoints
    
    def _analyze_endpoint(self, url: str, response: requests.Response) -> APIEndpoint:
        """Analiza un endpoint específico."""
        security_issues = []
        
        # Detectar si requiere autenticación
        auth_required = response.status_code in [401, 403]
        
        # Detectar rate limiting
        rate_limited = 'X-RateLimit-Limit' in response.headers or \
                      'X-Rate-Limit' in response.headers or \
                      response.status_code == 429
        
        # Detectar formato de respuesta
        content_type = response.headers.get('Content-Type', '')
        if 'application/json' in content_type:
            response_format = 'json'
        elif 'application/xml' in content_type:
            response_format = 'xml'
        elif 'text/html' in content_type:
            response_format = 'html'
        else:
            response_format = 'unknown'
        
        # Análisis de seguridad básico
        if not auth_required and response.status_code == 200:
            security_issues.append('Endpoint sin autenticación')
        
        if not rate_limited:
            security_issues.append('Sin rate limiting detectado')
        
        # Verificar headers de seguridad
        security_headers = ['X-Content-Type-Options', 'X-Frame-Options', 'X-XSS-Protection']
        for header in security_headers:
            if header not in response.headers:
                security_issues.append(f'Header de seguridad faltante: {header}')
        
        return APIEndpoint(
            url=url,
            method='GET',  # Por defecto, se puede expandir
            parameters=[],  # Se puede expandir con análisis más profundo
            authentication_required=auth_required,
            rate_limited=rate_limited,
            response_format=response_format,
            security_issues=security_issues
        )
    
    def _extract_api_urls_from_content(self, content: str, base_url: str) -> Set[str]:
        """Extrae URLs de API del contenido web."""
        urls = set()
        
        # Buscar patrones de API en JavaScript
        js_patterns = [
            r'["\'](/api/[^"\'\ ]+)["\']',
            r'["\'](/rest/[^"\'\ ]+)["\']',
            r'["\']([^"\'\ ]*graphql[^"\'\ ]*)["\']',
            r'fetch\(["\']([^"\'\ ]+)["\']\)',
            r'axios\.[a-z]+\(["\']([^"\'\ ]+)["\']\)',
            r'\$\.ajax\(["\']([^"\'\ ]+)["\']\)'
        ]
        
        for pattern in js_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if any(api_pattern in match for api_pattern in ['/api/', '/rest/', 'graphql']):
                    full_url = urljoin(base_url, match)
                    urls.add(full_url)
        
        return urls
    
    def scan_rest_api(self, target: str) -> Dict[str, Any]:
        """Escaneo específico para APIs REST."""
        results = {
            'endpoints': [],
            'authentication_methods': [],
            'rate_limiting': {},
            'cors_configuration': {},
            'vulnerabilities': [],
            'documentation_found': False
        }
        
        try:
            # Buscar documentación Swagger/OpenAPI
            swagger_urls = [
                '/swagger.json',
                '/swagger-ui',
                '/api-docs',
                '/openapi.json',
                '/docs',
                '/redoc'
            ]
            
            for swagger_url in swagger_urls:
                full_url = urljoin(target, swagger_url)
                try:
                    response = self.session.get(full_url, timeout=self.timeout)
                    if response.status_code == 200:
                        results['documentation_found'] = True
                        if 'application/json' in response.headers.get('Content-Type', ''):
                            # Analizar documentación OpenAPI/Swagger
                            swagger_data = response.json()
                            results['endpoints'].extend(self._parse_swagger_endpoints(swagger_data, target))
                        break
                except (requests.RequestException, json.JSONDecodeError):
                    continue
            
            # Análisis de CORS
            cors_result = self._test_cors_configuration(target)
            results['cors_configuration'] = cors_result
            
            # Pruebas de autenticación
            auth_methods = self._detect_authentication_methods(target)
            results['authentication_methods'] = auth_methods
            
            # Pruebas de rate limiting
            rate_limit_result = self._test_rate_limiting(target)
            results['rate_limiting'] = rate_limit_result
            
            # Pruebas de vulnerabilidades comunes
            vulns = self._test_rest_vulnerabilities(target)
            results['vulnerabilities'] = vulns
            
        except Exception as e:
            log.error(f"Error en escaneo REST API: {e}")
            results['error'] = str(e)
        
        return results
    
    def scan_graphql(self, target: str) -> Dict[str, Any]:
        """Escaneo específico para GraphQL."""
        results = {
            'endpoint_found': False,
            'introspection_enabled': False,
            'schema': {},
            'vulnerabilities': [],
            'queries_tested': []
        }
        
        graphql_endpoints = ['/graphql', '/graphiql', '/api/graphql', '/v1/graphql']
        
        for endpoint in graphql_endpoints:
            full_url = urljoin(target, endpoint)
            
            try:
                # Test básico de GraphQL
                test_query = {
                    'query': '{ __typename }'
                }
                
                response = self.session.post(
                    full_url,
                    json=test_query,
                    headers={'Content-Type': 'application/json'},
                    timeout=self.timeout
                )
                
                if response.status_code == 200 and 'data' in response.text:
                    results['endpoint_found'] = True
                    log.info(f"GraphQL endpoint encontrado: {full_url}")
                    
                    # Test de introspección
                    introspection_result = self._test_graphql_introspection(full_url)
                    results.update(introspection_result)
                    
                    # Pruebas de vulnerabilidades GraphQL
                    vulns = self._test_graphql_vulnerabilities(full_url)
                    results['vulnerabilities'] = vulns
                    
                    break
                    
            except requests.RequestException:
                continue
        
        return results
    
    def scan_grpc(self, target: str) -> Dict[str, Any]:
        """Escaneo específico para gRPC."""
        results = {
            'grpc_detected': False,
            'reflection_enabled': False,
            'services': [],
            'vulnerabilities': []
        }
        
        try:
            # Detectar gRPC por headers HTTP/2
            response = self.session.get(target, timeout=self.timeout)
            
            # Buscar indicadores de gRPC
            grpc_indicators = [
                'grpc',
                'application/grpc',
                'grpc-status',
                'grpc-message'
            ]
            
            response_text = response.text.lower()
            headers_text = str(response.headers).lower()
            
            for indicator in grpc_indicators:
                if indicator in response_text or indicator in headers_text:
                    results['grpc_detected'] = True
                    break
            
            if results['grpc_detected']:
                log.info(f"Posible servicio gRPC detectado en {target}")
                # Aquí se podrían agregar más pruebas específicas de gRPC
                # que requieren bibliotecas especializadas como grpcurl
        
        except Exception as e:
            log.error(f"Error en escaneo gRPC: {e}")
        
        return results
    
    def _scan_api_documentation(self, target: str) -> Dict[str, Any]:
        """Busca y analiza documentación de API."""
        results = {
            'swagger_found': False,
            'openapi_found': False,
            'postman_collection': False,
            'insomnia_collection': False,
            'documentation_urls': []
        }
        
        doc_endpoints = [
            '/swagger.json',
            '/swagger-ui',
            '/swagger-ui.html',
            '/api-docs',
            '/openapi.json',
            '/docs',
            '/redoc',
            '/api/docs',
            '/documentation',
            '/api-documentation',
            '/postman.json',
            '/insomnia.json'
        ]
        
        for endpoint in doc_endpoints:
            full_url = urljoin(target, endpoint)
            try:
                response = self.session.get(full_url, timeout=self.timeout)
                if response.status_code == 200:
                    results['documentation_urls'].append(full_url)
                    
                    content_type = response.headers.get('Content-Type', '')
                    if 'swagger' in endpoint.lower():
                        results['swagger_found'] = True
                    elif 'openapi' in endpoint.lower():
                        results['openapi_found'] = True
                    elif 'postman' in endpoint.lower():
                        results['postman_collection'] = True
                    elif 'insomnia' in endpoint.lower():
                        results['insomnia_collection'] = True
                        
            except requests.RequestException:
                continue
        
        return results
    
    def _analyze_api_security(self, target: str, endpoints: List[APIEndpoint]) -> List[Dict[str, Any]]:
        """Análisis de seguridad general de APIs."""
        security_issues = []
        
        # Análizar cada endpoint
        for endpoint in endpoints:
            for issue in endpoint.security_issues:
                security_issues.append({
                    'type': 'endpoint_security',
                    'severity': 'medium',
                    'endpoint': endpoint.url,
                    'description': issue
                })
        
        # Pruebas de seguridad adicionales
        try:
            # Test de información sensible en respuestas
            response = self.session.get(target, timeout=self.timeout)
            if self._contains_sensitive_info(response.text):
                security_issues.append({
                    'type': 'information_disclosure',
                    'severity': 'high',
                    'description': 'Posible exposición de información sensible'
                })
            
            # Test de headers de seguridad
            missing_headers = self._check_security_headers(response.headers)
            for header in missing_headers:
                security_issues.append({
                    'type': 'missing_security_header',
                    'severity': 'low',
                    'description': f'Header de seguridad faltante: {header}'
                })
        
        except Exception as e:
            log.error(f"Error en análisis de seguridad: {e}")
        
        return security_issues
    
    def _test_cors_configuration(self, target: str) -> Dict[str, Any]:
        """Prueba la configuración CORS."""
        cors_result = {
            'cors_enabled': False,
            'wildcard_origin': False,
            'credentials_allowed': False,
            'allowed_methods': [],
            'allowed_headers': []
        }
        
        try:
            headers = {
                'Origin': 'https://evil.com',
                'Access-Control-Request-Method': 'POST',
                'Access-Control-Request-Headers': 'Content-Type'
            }
            
            response = self.session.options(target, headers=headers, timeout=self.timeout)
            
            if 'Access-Control-Allow-Origin' in response.headers:
                cors_result['cors_enabled'] = True
                
                origin = response.headers.get('Access-Control-Allow-Origin')
                if origin == '*':
                    cors_result['wildcard_origin'] = True
                
                if response.headers.get('Access-Control-Allow-Credentials') == 'true':
                    cors_result['credentials_allowed'] = True
                
                methods = response.headers.get('Access-Control-Allow-Methods', '')
                cors_result['allowed_methods'] = [m.strip() for m in methods.split(',') if m.strip()]
                
                headers_allowed = response.headers.get('Access-Control-Allow-Headers', '')
                cors_result['allowed_headers'] = [h.strip() for h in headers_allowed.split(',') if h.strip()]
        
        except Exception as e:
            log.error(f"Error en test CORS: {e}")
        
        return cors_result
    
    def _test_graphql_introspection(self, graphql_url: str) -> Dict[str, Any]:
        """Prueba si la introspección GraphQL está habilitada."""
        result = {
            'introspection_enabled': False,
            'schema': {}
        }
        
        introspection_query = {
            'query': '''
            query IntrospectionQuery {
                __schema {
                    queryType { name }
                    mutationType { name }
                    subscriptionType { name }
                    types {
                        ...FullType
                    }
                }
            }
            
            fragment FullType on __Type {
                kind
                name
                description
                fields(includeDeprecated: true) {
                    name
                    description
                    args {
                        ...InputValue
                    }
                    type {
                        ...TypeRef
                    }
                    isDeprecated
                    deprecationReason
                }
            }
            
            fragment InputValue on __InputValue {
                name
                description
                type { ...TypeRef }
                defaultValue
            }
            
            fragment TypeRef on __Type {
                kind
                name
                ofType {
                    kind
                    name
                    ofType {
                        kind
                        name
                        ofType {
                            kind
                            name
                        }
                    }
                }
            }
            '''
        }
        
        try:
            response = self.session.post(
                graphql_url,
                json=introspection_query,
                headers={'Content-Type': 'application/json'},
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'data' in data and '__schema' in data['data']:
                    result['introspection_enabled'] = True
                    result['schema'] = data['data']['__schema']
                    log.warning(f"Introspección GraphQL habilitada en {graphql_url}")
        
        except Exception as e:
            log.error(f"Error en test de introspección GraphQL: {e}")
        
        return result
    
    def _contains_sensitive_info(self, content: str) -> bool:
        """Verifica si el contenido contiene información sensible."""
        sensitive_patterns = [
            r'password["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'api[_-]?key["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'secret["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'token["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'aws[_-]?access[_-]?key',
            r'private[_-]?key',
            r'database[_-]?url'
        ]
        
        for pattern in sensitive_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        
        return False
    
    def _check_security_headers(self, headers: Dict[str, str]) -> List[str]:
        """Verifica headers de seguridad faltantes."""
        required_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy'
        ]
        
        missing = []
        for header in required_headers:
            if header not in headers:
                missing.append(header)
        
        return missing
    
    def _parse_swagger_endpoints(self, swagger_data: Dict, base_url: str) -> List[Dict]:
        """Parsea endpoints desde documentación Swagger/OpenAPI."""
        endpoints = []
        
        try:
            paths = swagger_data.get('paths', {})
            for path, methods in paths.items():
                for method, details in methods.items():
                    if isinstance(details, dict):
                        endpoint = {
                            'path': path,
                            'method': method.upper(),
                            'summary': details.get('summary', ''),
                            'parameters': details.get('parameters', []),
                            'security': details.get('security', []),
                            'full_url': urljoin(base_url, path.lstrip('/'))
                        }
                        endpoints.append(endpoint)
        except Exception as e:
            log.error(f"Error parseando Swagger: {e}")
        
        return endpoints
    
    def _detect_authentication_methods(self, target: str) -> List[str]:
        """Detecta métodos de autenticación utilizados."""
        auth_methods = []
        
        try:
            response = self.session.get(target, timeout=self.timeout)
            
            # Verificar headers de autenticación
            if 'WWW-Authenticate' in response.headers:
                auth_header = response.headers['WWW-Authenticate']
                if 'Basic' in auth_header:
                    auth_methods.append('HTTP Basic')
                if 'Bearer' in auth_header:
                    auth_methods.append('Bearer Token')
                if 'Digest' in auth_header:
                    auth_methods.append('HTTP Digest')
            
            # Verificar cookies de sesión
            if 'Set-Cookie' in response.headers:
                cookies = response.headers['Set-Cookie']
                if 'session' in cookies.lower() or 'auth' in cookies.lower():
                    auth_methods.append('Session Cookies')
            
            # Verificar en contenido
            content = response.text.lower()
            if 'oauth' in content:
                auth_methods.append('OAuth')
            if 'jwt' in content or 'json web token' in content:
                auth_methods.append('JWT')
            if 'saml' in content:
                auth_methods.append('SAML')
        
        except Exception as e:
            log.error(f"Error detectando métodos de autenticación: {e}")
        
        return auth_methods
    
    def _test_rate_limiting(self, target: str) -> Dict[str, Any]:
        """Prueba la implementación de rate limiting."""
        result = {
            'rate_limiting_detected': False,
            'limit_headers': {},
            'blocked_after_requests': None
        }
        
        try:
            # Hacer múltiples requests rápidos
            for i in range(10):
                response = self.session.get(target, timeout=self.timeout)
                
                # Verificar headers de rate limiting
                rate_headers = {}
                for header, value in response.headers.items():
                    if 'rate' in header.lower() or 'limit' in header.lower():
                        rate_headers[header] = value
                
                if rate_headers:
                    result['rate_limiting_detected'] = True
                    result['limit_headers'] = rate_headers
                
                if response.status_code == 429:
                    result['rate_limiting_detected'] = True
                    result['blocked_after_requests'] = i + 1
                    break
                
                time.sleep(0.1)  # Pequeña pausa entre requests
        
        except Exception as e:
            log.error(f"Error en test de rate limiting: {e}")
        
        return result
    
    def _test_rest_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Prueba vulnerabilidades comunes en APIs REST."""
        vulnerabilities = []
        
        # Test de inyección SQL básica
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
        for payload in sql_payloads:
            try:
                response = self.session.get(f"{target}?id={payload}", timeout=self.timeout)
                if 'sql' in response.text.lower() or 'mysql' in response.text.lower():
                    vulnerabilities.append({
                        'type': 'sql_injection',
                        'severity': 'high',
                        'payload': payload,
                        'description': 'Posible vulnerabilidad de inyección SQL'
                    })
                    break
            except:
                continue
        
        # Test de XSS básico
        xss_payload = "<script>alert('XSS')</script>"
        try:
            response = self.session.get(f"{target}?q={xss_payload}", timeout=self.timeout)
            if xss_payload in response.text:
                vulnerabilities.append({
                    'type': 'xss',
                    'severity': 'medium',
                    'payload': xss_payload,
                    'description': 'Posible vulnerabilidad XSS reflejada'
                })
        except:
            pass
        
        return vulnerabilities
    
    def _test_graphql_vulnerabilities(self, graphql_url: str) -> List[Dict[str, Any]]:
        """Prueba vulnerabilidades específicas de GraphQL."""
        vulnerabilities = []
        
        # Test de query depth (DoS)
        deep_query = {
            'query': '''
            query {
                user {
                    posts {
                        comments {
                            user {
                                posts {
                                    comments {
                                        user {
                                            posts {
                                                comments {
                                                    id
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            '''
        }
        
        try:
            response = self.session.post(
                graphql_url,
                json=deep_query,
                headers={'Content-Type': 'application/json'},
                timeout=self.timeout
            )
            
            if response.status_code == 200 and 'data' in response.text:
                vulnerabilities.append({
                    'type': 'graphql_depth_limit',
                    'severity': 'medium',
                    'description': 'Query depth limiting no implementado - riesgo de DoS'
                })
        except:
            pass
        
        return vulnerabilities

# Función de integración con el sistema principal
def integrate_api_scanner_with_premium_scan():
    """Ejemplo de cómo integrar el APIScanner con el sistema premium."""
    
    # Esta función se agregaría al PremiumAdaptiveScanner
    def _advanced_api_scan(self, target: str, detected_technologies: List[Dict], output_dir: Path) -> Dict[str, Any]:
        """Escaneo avanzado de APIs basado en tecnologías detectadas."""
        api_scanner = APIScanner()
        
        # Determinar si hay APIs basado en tecnologías detectadas
        api_technologies = ['rest', 'graphql', 'grpc', 'api', 'swagger', 'openapi']
        has_api = any(
            any(tech_keyword in tech.get('name', '').lower() for tech_keyword in api_technologies)
            for tech in detected_technologies
        )
        
        if has_api:
            log.info(f"APIs detectadas, ejecutando escaneo especializado para {target}")
            return api_scanner.scan_api_comprehensive(target, output_dir)
        else:
            # Escaneo básico de descubrimiento
            return {
                'api_discovery_attempted': True,
                'endpoints_found': len(api_scanner._discover_api_endpoints(target))
            }

if __name__ == "__main__":
    # Ejemplo de uso
    import sys
    from pathlib import Path
    
    if len(sys.argv) != 2:
        print("Uso: python api_scanner.py <target_url>")
        sys.exit(1)
    
    target = sys.argv[1]
    output_dir = Path("./api_scan_output")
    output_dir.mkdir(exist_ok=True)
    
    scanner = APIScanner()
    results = scanner.scan_api_comprehensive(target, output_dir)
    
    print(f"\n=== Resultados del escaneo de APIs para {target} ===")
    print(f"Endpoints descubiertos: {len(results['endpoints_discovered'])}")
    print(f"APIs REST encontradas: {len(results['rest_apis'])}")
    print(f"GraphQL detectado: {results['graphql_apis'].get('endpoint_found', False)}")
    print(f"gRPC detectado: {results['grpc_apis'].get('grpc_detected', False)}")
    print(f"Documentación encontrada: {len(results['documentation']['documentation_urls'])}")
    print(f"Problemas de seguridad: {len(results['security_issues'])}")
    
    # Guardar resultados
    output_file = output_dir / f"api_scan_{int(time.time())}.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"\nResultados guardados en: {output_file}")