#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Esc谩ner especializado para APIs REST, GraphQL y gRPC.
Parte de las mejoras del sistema de escaneo premium adaptativo.
"""

import json
import logging
import requests
import re
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from urllib.parse import urljoin, urlparse
from dataclasses import dataclass

log = logging.getLogger(__name__)

@dataclass
class APIEndpoint:
    """Representa un endpoint de API descubierto."""
    url: str
    method: str
    parameters: List[str]
    authentication_required: bool
    rate_limited: bool
    response_format: str
    security_issues: List[str]

class APIScanner:
    """Esc谩ner especializado para APIs REST, GraphQL y gRPC."""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'APIScanner/1.0 (Security Testing)'
        })
        
        # Patrones comunes de APIs
        self.api_patterns = [
            r'/api/v\d+/',
            r'/api/',
            r'/rest/',
            r'/graphql',
            r'/v\d+/',
            r'/_api/',
            r'/api-docs',
            r'/swagger',
            r'/openapi'
        ]
        
        # Endpoints comunes a probar
        self.common_endpoints = [
            '/api/v1/users',
            '/api/v1/auth',
            '/api/v1/login',
            '/api/v1/admin',
            '/api/v1/config',
            '/api/v1/status',
            '/api/v1/health',
            '/api/v1/version',
            '/api/users',
            '/api/auth',
            '/api/login',
            '/rest/users',
            '/rest/auth',
            '/graphql',
            '/graphiql',
            '/api-docs',
            '/swagger.json',
            '/swagger-ui',
            '/openapi.json',
            '/docs',
            '/redoc'
        ]
    
    def _normalize_url(self, url: str) -> str:
        """Normaliza una URL agregando esquema si es necesario."""
        if not url.startswith(('http://', 'https://')):
            # Asumir HTTPS por defecto para APIs
            url = 'https://' + url
        return url
    
    def detect_api_presence(self, target: str) -> Dict[str, Any]:
        """Detecta la presencia de APIs en el objetivo.
        
        Args:
            target: URL objetivo
            
        Returns:
            Informaci贸n sobre APIs detectadas
        """
        log.info(f" Detectando presencia de APIs en {target}")
        
        # Normalizar URL
        target = self._normalize_url(target)
        
        results = {
            'target': target,
            'apis_detected': False,
            'api_types': [],
            'endpoints_found': [],
            'documentation_found': [],
            'confidence': 0
        }
        
        try:
            # Probar endpoints comunes de API
            api_indicators = 0
            total_checks = 0
            
            for endpoint in self.common_endpoints[:10]:  # Limitar para detecci贸n r谩pida
                full_url = urljoin(target, endpoint)
                try:
                    response = self.session.get(full_url, timeout=5)
                    total_checks += 1
                    
                    if response.status_code in [200, 401, 403, 405]:
                        api_indicators += 1
                        results['endpoints_found'].append({
                            'url': full_url,
                            'status': response.status_code,
                            'content_type': response.headers.get('Content-Type', '')
                        })
                        
                        # Detectar tipo de API
                        content_type = response.headers.get('Content-Type', '').lower()
                        if 'application/json' in content_type:
                            if 'REST' not in results['api_types']:
                                results['api_types'].append('REST')
                        
                        if 'graphql' in endpoint.lower():
                            if 'GraphQL' not in results['api_types']:
                                results['api_types'].append('GraphQL')
                                
                except requests.RequestException:
                    total_checks += 1
                    continue
            
            # Buscar documentaci贸n de API
            doc_endpoints = ['/api-docs', '/swagger.json', '/openapi.json', '/docs', '/redoc']
            for doc_endpoint in doc_endpoints:
                try:
                    doc_url = urljoin(target, doc_endpoint)
                    response = self.session.get(doc_url, timeout=5)
                    if response.status_code == 200:
                        results['documentation_found'].append(doc_url)
                        api_indicators += 1
                except requests.RequestException:
                    continue
            
            # Calcular confianza
            if total_checks > 0:
                results['confidence'] = min(100, (api_indicators / max(total_checks, 1)) * 100)
            
            # Determinar si hay APIs
            results['apis_detected'] = api_indicators > 0 or len(results['documentation_found']) > 0
            
            log.info(f"APIs detectadas: {results['apis_detected']} (confianza: {results['confidence']:.1f}%)")
            
        except Exception as e:
            log.error(f"Error detectando APIs: {e}")
            results['error'] = str(e)
        
        return results
    
    def analyze_api_documentation(self, target: str) -> Dict[str, Any]:
        """Analiza la documentaci贸n de API disponible."""
        try:
            return self._find_api_documentation(target)
        except Exception as e:
            log.error(f"Error analizando documentaci贸n de API: {e}")
            return {'documentation_urls': [], 'swagger_found': False, 'openapi_found': False}
    
    def analyze_authentication(self, target: str) -> Dict[str, Any]:
        """Analiza los m茅todos de autenticaci贸n de la API."""
        try:
            auth_methods = self._detect_auth_methods(target)
            return {
                'authentication_methods': auth_methods,
                'requires_auth': len(auth_methods) > 0,
                'auth_count': len(auth_methods)
            }
        except Exception as e:
            log.error(f"Error analizando autenticaci贸n: {e}")
            return {'authentication_methods': [], 'requires_auth': False, 'auth_count': 0}
    
    def test_rate_limiting(self, target: str) -> Dict[str, Any]:
        """Prueba la implementaci贸n de rate limiting."""
        try:
            return self._test_rate_limiting(target)
        except Exception as e:
            log.error(f"Error en test de rate limiting: {e}")
            return {'rate_limiting_detected': False, 'limit_headers': {}, 'blocked_after_requests': None}
    
    def _find_api_documentation(self, target: str) -> Dict[str, Any]:
        """Busca documentaci贸n de API."""
        return self._scan_api_documentation(target)
    
    def _detect_auth_methods(self, target: str) -> List[str]:
        """Detecta m茅todos de autenticaci贸n."""
        return self._detect_authentication_methods(target)
        
        # Patrones comunes de APIs
        self.api_patterns = [
            r'/api/v\d+/',
            r'/api/',
            r'/rest/',
            r'/graphql',
            r'/v\d+/',
            r'/_api/',
            r'/api-docs',
            r'/swagger',
            r'/openapi'
        ]
        
        # Endpoints comunes a probar
        self.common_endpoints = [
            '/api/v1/users',
            '/api/v1/auth',
            '/api/v1/login',
            '/api/v1/admin',
            '/api/v1/config',
            '/api/v1/status',
            '/api/v1/health',
            '/api/v1/version',
            '/api/users',
            '/api/auth',
            '/api/login',
            '/rest/users',
            '/rest/auth',
            '/graphql',
            '/graphiql',
            '/api-docs',
            '/swagger.json',
            '/swagger-ui',
            '/openapi.json',
            '/docs',
            '/redoc'
        ]
    
    def scan_api_comprehensive(self, target: str, output_dir: Path) -> Dict[str, Any]:
        """Escaneo completo de APIs."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        results = {
            'target': target,
            'rest_apis': {},
            'graphql_apis': {},
            'grpc_apis': {},
            'documentation': {},
            'security_issues': [],
            'endpoints_discovered': [],
            'scan_timestamp': time.time()
        }
        
        log.info(f"Iniciando escaneo completo de APIs para {target}")
        
        # 1. Descubrimiento de endpoints
        endpoints = self._discover_api_endpoints(target)
        results['endpoints_discovered'] = [ep.__dict__ for ep in endpoints]
        
        # 2. Escaneo REST API
        rest_results = self.scan_rest_api(target)
        results['rest_apis'] = rest_results
        
        # 3. Escaneo GraphQL
        graphql_results = self.scan_graphql(target)
        results['graphql_apis'] = graphql_results
        
        # 4. Escaneo gRPC
        grpc_results = self.scan_grpc(target)
        results['grpc_apis'] = grpc_results
        
        # 5. B煤squeda de documentaci贸n
        doc_results = self._scan_api_documentation(target)
        results['documentation'] = doc_results
        
        # 6. An谩lisis de seguridad general
        security_issues = self._analyze_api_security(target, endpoints)
        results['security_issues'] = security_issues
        
        return results
    
    def _discover_api_endpoints(self, target: str) -> List[APIEndpoint]:
        """Descubre endpoints de API."""
        endpoints = []
        
        # Normalizar URL
        target = self._normalize_url(target)
        
        # Probar endpoints comunes
        for endpoint in self.common_endpoints:
            full_url = urljoin(target, endpoint)
            try:
                response = self.session.get(full_url, timeout=self.timeout)
                if response.status_code in [200, 401, 403, 405]:
                    endpoint_obj = self._analyze_endpoint(full_url, response)
                    endpoints.append(endpoint_obj)
                    log.debug(f"Endpoint descubierto: {full_url}")
            except requests.RequestException:
                continue
        
        # An谩lisis de contenido web para encontrar m谩s endpoints
        try:
            response = self.session.get(target, timeout=self.timeout)
            if response.status_code == 200:
                discovered_urls = self._extract_api_urls_from_content(response.text, target)
                for url in discovered_urls:
                    try:
                        api_response = self.session.get(url, timeout=self.timeout)
                        if api_response.status_code in [200, 401, 403, 405]:
                            endpoint_obj = self._analyze_endpoint(url, api_response)
                            endpoints.append(endpoint_obj)
                    except requests.RequestException:
                        continue
        except requests.RequestException:
            pass
        
        return endpoints
    
    def _analyze_endpoint(self, url: str, response: requests.Response) -> APIEndpoint:
        """Analiza un endpoint espec铆fico."""
        security_issues = []
        
        # Detectar si requiere autenticaci贸n
        auth_required = response.status_code in [401, 403]
        
        # Detectar rate limiting
        rate_limited = 'X-RateLimit-Limit' in response.headers or \
                      'X-Rate-Limit' in response.headers or \
                      response.status_code == 429
        
        # Detectar formato de respuesta
        content_type = response.headers.get('Content-Type', '')
        if 'application/json' in content_type:
            response_format = 'json'
        elif 'application/xml' in content_type:
            response_format = 'xml'
        elif 'text/html' in content_type:
            response_format = 'html'
        else:
            response_format = 'unknown'
        
        # An谩lisis de seguridad b谩sico
        if not auth_required and response.status_code == 200:
            security_issues.append('Endpoint sin autenticaci贸n')
        
        if not rate_limited:
            security_issues.append('Sin rate limiting detectado')
        
        # Verificar headers de seguridad
        security_headers = ['X-Content-Type-Options', 'X-Frame-Options', 'X-XSS-Protection']
        for header in security_headers:
            if header not in response.headers:
                security_issues.append(f'Header de seguridad faltante: {header}')
        
        return APIEndpoint(
            url=url,
            method='GET',  # Por defecto, se puede expandir
            parameters=[],  # Se puede expandir con an谩lisis m谩s profundo
            authentication_required=auth_required,
            rate_limited=rate_limited,
            response_format=response_format,
            security_issues=security_issues
        )
    
    def _extract_api_urls_from_content(self, content: str, base_url: str) -> Set[str]:
        """Extrae URLs de API del contenido web."""
        urls = set()
        
        # Buscar patrones de API en JavaScript
        js_patterns = [
            r'["\'](/api/[^"\'\ ]+)["\']',
            r'["\'](/rest/[^"\'\ ]+)["\']',
            r'["\']([^"\'\ ]*graphql[^"\'\ ]*)["\']',
            r'fetch\(["\']([^"\'\ ]+)["\']\)',
            r'axios\.[a-z]+\(["\']([^"\'\ ]+)["\']\)',
            r'\$\.ajax\(["\']([^"\'\ ]+)["\']\)'
        ]
        
        for pattern in js_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            for match in matches:
                if any(api_pattern in match for api_pattern in ['/api/', '/rest/', 'graphql']):
                    full_url = urljoin(base_url, match)
                    urls.add(full_url)
        
        return urls
    
    def scan_rest_api(self, target: str) -> Dict[str, Any]:
        """Escaneo espec铆fico para APIs REST."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        results = {
            'endpoints': [],
            'authentication_methods': [],
            'rate_limiting': {},
            'cors_configuration': {},
            'vulnerabilities': [],
            'documentation_found': False
        }
        
        try:
            # Buscar documentaci贸n Swagger/OpenAPI
            swagger_urls = [
                '/swagger.json',
                '/swagger-ui',
                '/api-docs',
                '/openapi.json',
                '/docs',
                '/redoc'
            ]
            
            for swagger_url in swagger_urls:
                full_url = urljoin(target, swagger_url)
                try:
                    response = self.session.get(full_url, timeout=self.timeout)
                    if response.status_code == 200:
                        results['documentation_found'] = True
                        if 'application/json' in response.headers.get('Content-Type', ''):
                            # Analizar documentaci贸n OpenAPI/Swagger
                            swagger_data = response.json()
                            results['endpoints'].extend(self._parse_swagger_endpoints(swagger_data, target))
                        break
                except (requests.RequestException, json.JSONDecodeError):
                    continue
            
            # An谩lisis de CORS
            cors_result = self._test_cors_configuration(target)
            results['cors_configuration'] = cors_result
            
            # Pruebas de autenticaci贸n
            auth_methods = self._detect_authentication_methods(target)
            results['authentication_methods'] = auth_methods
            
            # Pruebas de rate limiting
            rate_limit_result = self._test_rate_limiting(target)
            results['rate_limiting'] = rate_limit_result
            
            # Pruebas de vulnerabilidades comunes
            vulns = self._test_rest_vulnerabilities(target)
            results['vulnerabilities'] = vulns
            
        except Exception as e:
            log.error(f"Error en escaneo REST API: {e}")
            results['error'] = str(e)
        
        return results
    
    def scan_graphql(self, target: str) -> Dict[str, Any]:
        """Escaneo espec铆fico para GraphQL."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        results = {
            'endpoint_found': False,
            'introspection_enabled': False,
            'schema': {},
            'vulnerabilities': [],
            'queries_tested': []
        }
        
        graphql_endpoints = ['/graphql', '/graphiql', '/api/graphql', '/v1/graphql']
        
        for endpoint in graphql_endpoints:
            full_url = urljoin(target, endpoint)
            
            try:
                # Test b谩sico de GraphQL
                test_query = {
                    'query': '{ __typename }'
                }
                
                response = self.session.post(
                    full_url,
                    json=test_query,
                    headers={'Content-Type': 'application/json'},
                    timeout=self.timeout
                )
                
                if response.status_code == 200 and 'data' in response.text:
                    results['endpoint_found'] = True
                    log.info(f"GraphQL endpoint encontrado: {full_url}")
                    
                    # Test de introspecci贸n
                    introspection_result = self._test_graphql_introspection(full_url)
                    results.update(introspection_result)
                    
                    # Pruebas de vulnerabilidades GraphQL
                    vulns = self._test_graphql_vulnerabilities(full_url)
                    results['vulnerabilities'] = vulns
                    
                    break
                    
            except requests.RequestException:
                continue
        
        return results
    
    def scan_grpc(self, target: str) -> Dict[str, Any]:
        """Escaneo espec铆fico para gRPC."""
        results = {
            'grpc_detected': False,
            'reflection_enabled': False,
            'services': [],
            'vulnerabilities': []
        }
        
        try:
            # Normalizar URL
            target = self._normalize_url(target)
            
            # Detectar gRPC por headers HTTP/2
            response = self.session.get(target, timeout=self.timeout)
            
            # Buscar indicadores de gRPC
            grpc_indicators = [
                'grpc',
                'application/grpc',
                'grpc-status',
                'grpc-message'
            ]
            
            response_text = response.text.lower()
            headers_text = str(response.headers).lower()
            
            for indicator in grpc_indicators:
                if indicator in response_text or indicator in headers_text:
                    results['grpc_detected'] = True
                    break
            
            if results['grpc_detected']:
                log.info(f"Posible servicio gRPC detectado en {target}")
                # Aqu铆 se podr铆an agregar m谩s pruebas espec铆ficas de gRPC
                # que requieren bibliotecas especializadas como grpcurl
        
        except Exception as e:
            log.error(f"Error en escaneo gRPC: {e}")
        
        return results
    
    def _scan_api_documentation(self, target: str) -> Dict[str, Any]:
        """Busca y analiza documentaci贸n de API."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        results = {
            'swagger_found': False,
            'openapi_found': False,
            'postman_collection': False,
            'insomnia_collection': False,
            'documentation_urls': []
        }
        
        doc_endpoints = [
            '/swagger.json',
            '/swagger-ui',
            '/swagger-ui.html',
            '/api-docs',
            '/openapi.json',
            '/docs',
            '/redoc',
            '/api/docs',
            '/documentation',
            '/api-documentation',
            '/postman.json',
            '/insomnia.json'
        ]
        
        for endpoint in doc_endpoints:
            full_url = urljoin(target, endpoint)
            try:
                response = self.session.get(full_url, timeout=self.timeout)
                if response.status_code == 200:
                    results['documentation_urls'].append(full_url)
                    
                    content_type = response.headers.get('Content-Type', '')
                    if 'swagger' in endpoint.lower():
                        results['swagger_found'] = True
                    elif 'openapi' in endpoint.lower():
                        results['openapi_found'] = True
                    elif 'postman' in endpoint.lower():
                        results['postman_collection'] = True
                    elif 'insomnia' in endpoint.lower():
                        results['insomnia_collection'] = True
                        
            except requests.RequestException:
                continue
        
        return results
    
    def _analyze_api_security(self, target: str, endpoints: List[APIEndpoint]) -> List[Dict[str, Any]]:
        """An谩lisis de seguridad general de APIs."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        security_issues = []
        
        # An谩lizar cada endpoint
        for endpoint in endpoints:
            for issue in endpoint.security_issues:
                security_issues.append({
                    'type': 'endpoint_security',
                    'severity': 'medium',
                    'endpoint': endpoint.url,
                    'description': issue
                })
        
        # Pruebas de seguridad adicionales
        try:
            # Test de informaci贸n sensible en respuestas
            response = self.session.get(target, timeout=self.timeout)
            if self._contains_sensitive_info(response.text):
                security_issues.append({
                    'type': 'information_disclosure',
                    'severity': 'high',
                    'description': 'Posible exposici贸n de informaci贸n sensible'
                })
            
            # Test de headers de seguridad
            missing_headers = self._check_security_headers(response.headers)
            for header in missing_headers:
                security_issues.append({
                    'type': 'missing_security_header',
                    'severity': 'low',
                    'description': f'Header de seguridad faltante: {header}'
                })
        
        except Exception as e:
            log.error(f"Error en an谩lisis de seguridad: {e}")
        
        return security_issues
    
    def _test_cors_configuration(self, target: str) -> Dict[str, Any]:
        """Prueba la configuraci贸n CORS."""
        cors_result = {
            'cors_enabled': False,
            'wildcard_origin': False,
            'credentials_allowed': False,
            'allowed_methods': [],
            'allowed_headers': []
        }
        
        try:
            # Normalizar URL
            target = self._normalize_url(target)
            
            headers = {
                'Origin': 'https://evil.com',
                'Access-Control-Request-Method': 'POST',
                'Access-Control-Request-Headers': 'Content-Type'
            }
            
            response = self.session.options(target, headers=headers, timeout=self.timeout)
            
            if 'Access-Control-Allow-Origin' in response.headers:
                cors_result['cors_enabled'] = True
                
                origin = response.headers.get('Access-Control-Allow-Origin')
                if origin == '*':
                    cors_result['wildcard_origin'] = True
                
                if response.headers.get('Access-Control-Allow-Credentials') == 'true':
                    cors_result['credentials_allowed'] = True
                
                methods = response.headers.get('Access-Control-Allow-Methods', '')
                cors_result['allowed_methods'] = [m.strip() for m in methods.split(',') if m.strip()]
                
                headers_allowed = response.headers.get('Access-Control-Allow-Headers', '')
                cors_result['allowed_headers'] = [h.strip() for h in headers_allowed.split(',') if h.strip()]
        
        except Exception as e:
            log.error(f"Error en test CORS: {e}")
        
        return cors_result
    
    def _test_graphql_introspection(self, graphql_url: str) -> Dict[str, Any]:
        """Prueba si la introspecci贸n GraphQL est谩 habilitada."""
        result = {
            'introspection_enabled': False,
            'schema': {}
        }
        
        introspection_query = {
            'query': '''
            query IntrospectionQuery {
                __schema {
                    queryType { name }
                    mutationType { name }
                    subscriptionType { name }
                    types {
                        ...FullType
                    }
                }
            }
            
            fragment FullType on __Type {
                kind
                name
                description
                fields(includeDeprecated: true) {
                    name
                    description
                    args {
                        ...InputValue
                    }
                    type {
                        ...TypeRef
                    }
                    isDeprecated
                    deprecationReason
                }
            }
            
            fragment InputValue on __InputValue {
                name
                description
                type { ...TypeRef }
                defaultValue
            }
            
            fragment TypeRef on __Type {
                kind
                name
                ofType {
                    kind
                    name
                    ofType {
                        kind
                        name
                        ofType {
                            kind
                            name
                        }
                    }
                }
            }
            '''
        }
        
        try:
            response = self.session.post(
                graphql_url,
                json=introspection_query,
                headers={'Content-Type': 'application/json'},
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'data' in data and '__schema' in data['data']:
                    result['introspection_enabled'] = True
                    result['schema'] = data['data']['__schema']
                    log.warning(f"Introspecci贸n GraphQL habilitada en {graphql_url}")
        
        except Exception as e:
            log.error(f"Error en test de introspecci贸n GraphQL: {e}")
        
        return result
    
    def _contains_sensitive_info(self, content: str) -> bool:
        """Verifica si el contenido contiene informaci贸n sensible."""
        sensitive_patterns = [
            r'password["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'api[_-]?key["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'secret["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'token["\']?\s*[:=]\s*["\'][^"\'\ ]+["\']',
            r'aws[_-]?access[_-]?key',
            r'private[_-]?key',
            r'database[_-]?url'
        ]
        
        for pattern in sensitive_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        
        return False
    
    def _check_security_headers(self, headers: Dict[str, str]) -> List[str]:
        """Verifica headers de seguridad faltantes."""
        required_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy'
        ]
        
        missing = []
        for header in required_headers:
            if header not in headers:
                missing.append(header)
        
        return missing
    
    def _parse_swagger_endpoints(self, swagger_data: Dict, base_url: str) -> List[Dict]:
        """Parsea endpoints desde documentaci贸n Swagger/OpenAPI."""
        endpoints = []
        
        try:
            paths = swagger_data.get('paths', {})
            for path, methods in paths.items():
                for method, details in methods.items():
                    if isinstance(details, dict):
                        endpoint = {
                            'path': path,
                            'method': method.upper(),
                            'summary': details.get('summary', ''),
                            'parameters': details.get('parameters', []),
                            'security': details.get('security', []),
                            'full_url': urljoin(base_url, path.lstrip('/'))
                        }
                        endpoints.append(endpoint)
        except Exception as e:
            log.error(f"Error parseando Swagger: {e}")
        
        return endpoints
    
    def _detect_authentication_methods(self, target: str) -> List[str]:
        """Detecta m茅todos de autenticaci贸n utilizados."""
        auth_methods = []
        
        try:
            # Normalizar URL
            target = self._normalize_url(target)
            response = self.session.get(target, timeout=self.timeout)
            
            # Verificar headers de autenticaci贸n
            if 'WWW-Authenticate' in response.headers:
                auth_header = response.headers['WWW-Authenticate']
                if 'Basic' in auth_header:
                    auth_methods.append('HTTP Basic')
                if 'Bearer' in auth_header:
                    auth_methods.append('Bearer Token')
                if 'Digest' in auth_header:
                    auth_methods.append('HTTP Digest')
            
            # Verificar cookies de sesi贸n
            if 'Set-Cookie' in response.headers:
                cookies = response.headers['Set-Cookie']
                if 'session' in cookies.lower() or 'auth' in cookies.lower():
                    auth_methods.append('Session Cookies')
            
            # Verificar en contenido
            content = response.text.lower()
            if 'oauth' in content:
                auth_methods.append('OAuth')
            if 'jwt' in content or 'json web token' in content:
                auth_methods.append('JWT')
            if 'saml' in content:
                auth_methods.append('SAML')
        
        except Exception as e:
            log.error(f"Error detectando m茅todos de autenticaci贸n: {e}")
        
        return auth_methods
    
    def _test_rate_limiting(self, target: str) -> Dict[str, Any]:
        """Prueba la implementaci贸n de rate limiting."""
        result = {
            'rate_limiting_detected': False,
            'limit_headers': {},
            'blocked_after_requests': None
        }
        
        try:
            # Normalizar URL
            target = self._normalize_url(target)
            
            # Hacer m煤ltiples requests r谩pidos
            for i in range(10):
                response = self.session.get(target, timeout=self.timeout)
                
                # Verificar headers de rate limiting
                rate_headers = {}
                for header, value in response.headers.items():
                    if 'rate' in header.lower() or 'limit' in header.lower():
                        rate_headers[header] = value
                
                if rate_headers:
                    result['rate_limiting_detected'] = True
                    result['limit_headers'] = rate_headers
                
                if response.status_code == 429:
                    result['rate_limiting_detected'] = True
                    result['blocked_after_requests'] = i + 1
                    break
                
                time.sleep(0.1)  # Peque帽a pausa entre requests
        
        except Exception as e:
            log.error(f"Error en test de rate limiting: {e}")
        
        return result
    
    def _test_rest_vulnerabilities(self, target: str) -> List[Dict[str, Any]]:
        """Prueba vulnerabilidades comunes en APIs REST."""
        # Normalizar URL
        target = self._normalize_url(target)
        
        vulnerabilities = []
        
        # Test de inyecci贸n SQL b谩sica
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
        for payload in sql_payloads:
            try:
                response = self.session.get(f"{target}?id={payload}", timeout=self.timeout)
                if 'sql' in response.text.lower() or 'mysql' in response.text.lower():
                    vulnerabilities.append({
                        'type': 'sql_injection',
                        'severity': 'high',
                        'payload': payload,
                        'description': 'Posible vulnerabilidad de inyecci贸n SQL'
                    })
                    break
            except:
                continue
        
        # Test de XSS b谩sico
        xss_payload = "<script>alert('XSS')</script>"
        try:
            response = self.session.get(f"{target}?q={xss_payload}", timeout=self.timeout)
            if xss_payload in response.text:
                vulnerabilities.append({
                    'type': 'xss',
                    'severity': 'medium',
                    'payload': xss_payload,
                    'description': 'Posible vulnerabilidad XSS reflejada'
                })
        except:
            pass
        
        return vulnerabilities
    
    def _test_graphql_vulnerabilities(self, graphql_url: str) -> List[Dict[str, Any]]:
        """Prueba vulnerabilidades espec铆ficas de GraphQL."""
        # Normalizar URL
        graphql_url = self._normalize_url(graphql_url)
        
        vulnerabilities = []
        
        # Test de query depth (DoS)
        deep_query = {
            'query': '''
            query {
                user {
                    posts {
                        comments {
                            user {
                                posts {
                                    comments {
                                        user {
                                            posts {
                                                comments {
                                                    id
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            '''
        }
        
        try:
            response = self.session.post(
                graphql_url,
                json=deep_query,
                headers={'Content-Type': 'application/json'},
                timeout=self.timeout
            )
            
            if response.status_code == 200 and 'data' in response.text:
                vulnerabilities.append({
                    'type': 'graphql_depth_limit',
                    'severity': 'medium',
                    'description': 'Query depth limiting no implementado - riesgo de DoS'
                })
        except:
            pass
        
        return vulnerabilities

# Funci贸n de integraci贸n con el sistema principal
def integrate_api_scanner_with_premium_scan():
    """Ejemplo de c贸mo integrar el APIScanner con el sistema premium."""
    
    # Esta funci贸n se agregar铆a al PremiumAdaptiveScanner
    def _advanced_api_scan(self, target: str, detected_technologies: List[Dict], output_dir: Path) -> Dict[str, Any]:
        """Escaneo avanzado de APIs basado en tecnolog铆as detectadas."""
        api_scanner = APIScanner()
        
        # Determinar si hay APIs basado en tecnolog铆as detectadas
        api_technologies = ['rest', 'graphql', 'grpc', 'api', 'swagger', 'openapi']
        has_api = any(
            any(tech_keyword in tech.get('name', '').lower() for tech_keyword in api_technologies)
            for tech in detected_technologies
        )
        
        if has_api:
            log.info(f"APIs detectadas, ejecutando escaneo especializado para {target}")
            return api_scanner.scan_api_comprehensive(target, output_dir)
        else:
            # Escaneo b谩sico de descubrimiento
            return {
                'api_discovery_attempted': True,
                'endpoints_found': len(api_scanner._discover_api_endpoints(target))
            }

if __name__ == "__main__":
    # Ejemplo de uso
    import sys
    from pathlib import Path
    
    if len(sys.argv) != 2:
        print("Uso: python api_scanner.py <target_url>")
        sys.exit(1)
    
    target = sys.argv[1]
    output_dir = Path("./api_scan_output")
    output_dir.mkdir(exist_ok=True)
    
    scanner = APIScanner()
    results = scanner.scan_api_comprehensive(target, output_dir)
    
    print(f"\n=== Resultados del escaneo de APIs para {target} ===")
    print(f"Endpoints descubiertos: {len(results['endpoints_discovered'])}")
    print(f"APIs REST encontradas: {len(results['rest_apis'])}")
    print(f"GraphQL detectado: {results['graphql_apis'].get('endpoint_found', False)}")
    print(f"gRPC detectado: {results['grpc_apis'].get('grpc_detected', False)}")
    print(f"Documentaci贸n encontrada: {len(results['documentation']['documentation_urls'])}")
    print(f"Problemas de seguridad: {len(results['security_issues'])}")
    
    # Guardar resultados
    output_file = output_dir / f"api_scan_{int(time.time())}.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"\nResultados guardados en: {output_file}")