#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Validador de herramientas externas para detección de tecnologías.
Verifica disponibilidad y funcionalidad de Wappalyzer, WhatWeb, httpx, etc.
"""

import subprocess
import shutil
import logging
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

log = logging.getLogger(__name__)

class ToolStatus(Enum):
    """Estados posibles de una herramienta."""
    AVAILABLE = "available"
    UNAVAILABLE = "unavailable"
    ERROR = "error"
    UNKNOWN = "unknown"

@dataclass
class ToolInfo:
    """Información sobre una herramienta externa."""
    name: str
    status: ToolStatus
    version: str = ""
    path: str = ""
    error: str = ""
    test_passed: bool = False
    response_time: float = 0.0

class ExternalToolValidator:
    """Validador para herramientas externas de detección de tecnologías."""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.tools_info: Dict[str, ToolInfo] = {}
        self.test_url = "https://httpbin.org/html"
        
    def validate_all_tools(self) -> Dict[str, ToolInfo]:
        """Valida todas las herramientas necesarias."""
        log.info("🔍 Iniciando validación de herramientas externas...")
        
        # Validar cada herramienta
        self._validate_wappalyzer()
        self._validate_whatweb()
        self._validate_httpx()
        self._validate_curl()
        self._validate_node()
        self._validate_npm()
        
        # Generar reporte
        self._generate_validation_report()
        
        return self.tools_info
    
    def _validate_wappalyzer(self) -> None:
        """Valida Wappalyzer CLI."""
        tool_name = "wappalyzer"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            # Verificar si está instalado
            path = shutil.which("wappalyzer")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="Wappalyzer CLI no encontrado en PATH"
                )
                return
            
            # Verificar versión
            start_time = time.time()
            result = subprocess.run(
                ["wappalyzer", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip()
            
            # Prueba funcional
            test_passed, test_error = self._test_wappalyzer()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout después de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_wappalyzer(self) -> Tuple[bool, str]:
        """Prueba funcional de Wappalyzer."""
        try:
            result = subprocess.run(
                ["wappalyzer", self.test_url],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                # Verificar que la salida sea JSON válido
                try:
                    json.loads(result.stdout)
                    return True, ""
                except json.JSONDecodeError:
                    return False, "Salida no es JSON válido"
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_whatweb(self) -> None:
        """Valida WhatWeb."""
        tool_name = "whatweb"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            # Verificar si está instalado
            path = shutil.which("whatweb")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="WhatWeb no encontrado en PATH"
                )
                return
            
            # Verificar versión
            start_time = time.time()
            result = subprocess.run(
                ["whatweb", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip().split('\n')[0] if result.stdout else "Unknown"
            
            # Prueba funcional
            test_passed, test_error = self._test_whatweb()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout después de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_whatweb(self) -> Tuple[bool, str]:
        """Prueba funcional de WhatWeb."""
        try:
            result = subprocess.run(
                ["whatweb", "--quiet", "--no-errors", self.test_url],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                return True, ""
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_httpx(self) -> None:
        """Valida httpx."""
        tool_name = "httpx"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            # Verificar si está instalado
            path = shutil.which("httpx")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="httpx no encontrado en PATH"
                )
                return
            
            # Verificar versión
            start_time = time.time()
            result = subprocess.run(
                ["httpx", "-version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip()
            
            # Prueba funcional
            test_passed, test_error = self._test_httpx()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout después de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_httpx(self) -> Tuple[bool, str]:
        """Prueba funcional de httpx."""
        try:
            result = subprocess.run(
                ["httpx", "-u", self.test_url, "-silent", "-json"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                # Verificar que la salida sea JSON válido
                try:
                    json.loads(result.stdout)
                    return True, ""
                except json.JSONDecodeError:
                    return False, "Salida no es JSON válido"
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_curl(self) -> None:
        """Valida curl (fallback)."""
        tool_name = "curl"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            path = shutil.which("curl")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="curl no encontrado en PATH"
                )
                return
            
            # Verificar versión
            start_time = time.time()
            result = subprocess.run(
                ["curl", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode == 0:
                version = result.stdout.split('\n')[0] if result.stdout else "Unknown"
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True,
                    response_time=response_time
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}",
                    response_time=response_time
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _validate_node(self) -> None:
        """Valida Node.js (requerido para Wappalyzer)."""
        tool_name = "node"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            path = shutil.which("node")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="Node.js no encontrado en PATH"
                )
                return
            
            # Verificar versión
            result = subprocess.run(
                ["node", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                version = result.stdout.strip()
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}"
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _validate_npm(self) -> None:
        """Valida npm (requerido para instalar Wappalyzer)."""
        tool_name = "npm"
        log.info(f"🔍 Validando {tool_name}...")
        
        try:
            path = shutil.which("npm")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="npm no encontrado en PATH"
                )
                return
            
            # Verificar versión
            result = subprocess.run(
                ["npm", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                version = result.stdout.strip()
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versión: {result.stderr}"
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _generate_validation_report(self) -> None:
        """Genera reporte de validación."""
        log.info("\n" + "="*60)
        log.info("🔍 REPORTE DE VALIDACIÓN DE HERRAMIENTAS")
        log.info("="*60)
        
        available_tools = []
        unavailable_tools = []
        error_tools = []
        
        for tool_name, tool_info in self.tools_info.items():
            status_icon = {
                ToolStatus.AVAILABLE: "✅",
                ToolStatus.UNAVAILABLE: "❌",
                ToolStatus.ERROR: "⚠️",
                ToolStatus.UNKNOWN: "❓"
            }.get(tool_info.status, "❓")
            
            log.info(f"{status_icon} {tool_name.upper()}:")
            log.info(f"   Estado: {tool_info.status.value}")
            if tool_info.version:
                log.info(f"   Versión: {tool_info.version}")
            if tool_info.path:
                log.info(f"   Ruta: {tool_info.path}")
            if tool_info.response_time > 0:
                log.info(f"   Tiempo respuesta: {tool_info.response_time:.2f}s")
            if tool_info.error:
                log.info(f"   Error: {tool_info.error}")
            log.info("")
            
            # Categorizar herramientas
            if tool_info.status == ToolStatus.AVAILABLE:
                available_tools.append(tool_name)
            elif tool_info.status == ToolStatus.UNAVAILABLE:
                unavailable_tools.append(tool_name)
            else:
                error_tools.append(tool_name)
        
        # Resumen
        log.info("📊 RESUMEN:")
        log.info(f"   ✅ Disponibles: {len(available_tools)} - {', '.join(available_tools)}")
        if unavailable_tools:
            log.info(f"   ❌ No disponibles: {len(unavailable_tools)} - {', '.join(unavailable_tools)}")
        if error_tools:
            log.info(f"   ⚠️ Con errores: {len(error_tools)} - {', '.join(error_tools)}")
        
        # Recomendaciones
        log.info("\n💡 RECOMENDACIONES:")
        if "wappalyzer" not in available_tools:
            log.info("   - Instalar Wappalyzer CLI: npm install -g wappalyzer")
        if "whatweb" not in available_tools:
            log.info("   - Instalar WhatWeb según tu sistema operativo")
        if "httpx" not in available_tools:
            log.info("   - Instalar httpx: go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest")
        
        log.info("="*60)
    
    def get_available_tools(self) -> List[str]:
        """Retorna lista de herramientas disponibles."""
        return [
            name for name, info in self.tools_info.items() 
            if info.status == ToolStatus.AVAILABLE
        ]
    
    def is_tool_available(self, tool_name: str) -> bool:
        """Verifica si una herramienta específica está disponible."""
        return (
            tool_name in self.tools_info and 
            self.tools_info[tool_name].status == ToolStatus.AVAILABLE
        )
    
    def get_fallback_tools(self) -> List[str]:
        """Retorna herramientas de fallback disponibles."""
        fallback_priority = ["curl", "httpx"]
        return [
            tool for tool in fallback_priority 
            if self.is_tool_available(tool)
        ]
    
    def export_validation_report(self, output_path: str) -> None:
        """Exporta reporte de validación a archivo JSON."""
        report_data = {
            "timestamp": time.time(),
            "tools": {
                name: {
                    "status": info.status.value,
                    "version": info.version,
                    "path": info.path,
                    "error": info.error,
                    "test_passed": info.test_passed,
                    "response_time": info.response_time
                }
                for name, info in self.tools_info.items()
            },
            "summary": {
                "available": self.get_available_tools(),
                "total_tools": len(self.tools_info),
                "available_count": len(self.get_available_tools())
            }
        }
        
        with open(output_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        log.info(f"📄 Reporte exportado a: {output_path}")


def validate_tools(timeout: int = 30) -> Dict[str, ToolInfo]:
    """Función de conveniencia para validar todas las herramientas."""
    validator = ExternalToolValidator(timeout=timeout)
    return validator.validate_all_tools()


if __name__ == "__main__":
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s"
    )
    
    # Ejecutar validación
    validator = ExternalToolValidator()
    tools_info = validator.validate_all_tools()
    
    # Exportar reporte
    validator.export_validation_report("tool_validation_report.json")
    
    # Mostrar herramientas disponibles
    available = validator.get_available_tools()
    print(f"\n🎯 Herramientas disponibles para detección mejorada: {len(available)}")
    for tool in available:
        print(f"   ✅ {tool}")