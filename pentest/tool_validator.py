#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Validador de herramientas externas para detecciÃ³n de tecnologÃ­as.
Verifica disponibilidad y funcionalidad de Wappalyzer, WhatWeb, httpx, etc.
"""

import subprocess
import shutil
import logging
import json
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

log = logging.getLogger(__name__)

class ToolStatus(Enum):
    """Estados posibles de una herramienta."""
    AVAILABLE = "available"
    UNAVAILABLE = "unavailable"
    ERROR = "error"
    UNKNOWN = "unknown"

@dataclass
class ToolInfo:
    """InformaciÃ³n sobre una herramienta externa."""
    name: str
    status: ToolStatus
    version: str = ""
    path: str = ""
    error: str = ""
    test_passed: bool = False
    response_time: float = 0.0

class ExternalToolValidator:
    """Validador para herramientas externas de detecciÃ³n de tecnologÃ­as."""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self.tools_info: Dict[str, ToolInfo] = {}
        self.test_url = "https://httpbin.org/html"
        
    def validate_all_tools(self) -> Dict[str, ToolInfo]:
        """Valida todas las herramientas necesarias."""
        log.info("ðŸ” Iniciando validaciÃ³n de herramientas externas...")
        
        # Validar cada herramienta
        self._validate_wappalyzer()
        self._validate_whatweb()
        self._validate_httpx()
        self._validate_curl()
        self._validate_node()
        self._validate_npm()
        
        # Generar reporte
        self._generate_validation_report()
        
        return self.tools_info
    
    def _validate_wappalyzer(self) -> None:
        """Valida Wappalyzer CLI."""
        tool_name = "wappalyzer"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            # Verificar si estÃ¡ instalado
            path = shutil.which("wappalyzer")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="Wappalyzer CLI no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            start_time = time.time()
            result = subprocess.run(
                ["wappalyzer", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip()
            
            # Prueba funcional
            test_passed, test_error = self._test_wappalyzer()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout despuÃ©s de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_wappalyzer(self) -> Tuple[bool, str]:
        """Prueba funcional de Wappalyzer."""
        try:
            result = subprocess.run(
                ["wappalyzer", self.test_url],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                # Verificar que la salida sea JSON vÃ¡lido
                try:
                    json.loads(result.stdout)
                    return True, ""
                except json.JSONDecodeError:
                    return False, "Salida no es JSON vÃ¡lido"
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_whatweb(self) -> None:
        """Valida WhatWeb."""
        tool_name = "whatweb"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            # Verificar si estÃ¡ instalado
            path = shutil.which("whatweb")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="WhatWeb no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            start_time = time.time()
            result = subprocess.run(
                ["whatweb", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip().split('\n')[0] if result.stdout else "Unknown"
            
            # Prueba funcional
            test_passed, test_error = self._test_whatweb()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout despuÃ©s de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_whatweb(self) -> Tuple[bool, str]:
        """Prueba funcional de WhatWeb."""
        try:
            result = subprocess.run(
                ["whatweb", "--quiet", "--no-errors", self.test_url],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                return True, ""
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_httpx(self) -> None:
        """Valida httpx."""
        tool_name = "httpx"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            # Verificar si estÃ¡ instalado
            path = shutil.which("httpx")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="httpx no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            start_time = time.time()
            result = subprocess.run(
                ["httpx", "-version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode != 0:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}",
                    response_time=response_time
                )
                return
            
            version = result.stdout.strip()
            
            # Prueba funcional
            test_passed, test_error = self._test_httpx()
            
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.AVAILABLE if test_passed else ToolStatus.ERROR,
                version=version,
                path=path,
                error=test_error,
                test_passed=test_passed,
                response_time=response_time
            )
            
        except subprocess.TimeoutExpired:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Timeout despuÃ©s de {self.timeout}s"
            )
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _test_httpx(self) -> Tuple[bool, str]:
        """Prueba funcional de httpx."""
        try:
            result = subprocess.run(
                ["httpx", "-u", self.test_url, "-silent", "-json"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0 and result.stdout:
                # Verificar que la salida sea JSON vÃ¡lido
                try:
                    json.loads(result.stdout)
                    return True, ""
                except json.JSONDecodeError:
                    return False, "Salida no es JSON vÃ¡lido"
            else:
                return False, f"Error en prueba: {result.stderr}"
                
        except subprocess.TimeoutExpired:
            return False, "Timeout en prueba funcional"
        except Exception as e:
            return False, f"Error en prueba: {str(e)}"
    
    def _validate_curl(self) -> None:
        """Valida curl (fallback)."""
        tool_name = "curl"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            path = shutil.which("curl")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="curl no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            start_time = time.time()
            result = subprocess.run(
                ["curl", "--version"],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            response_time = time.time() - start_time
            
            if result.returncode == 0:
                version = result.stdout.split('\n')[0] if result.stdout else "Unknown"
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True,
                    response_time=response_time
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}",
                    response_time=response_time
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _validate_node(self) -> None:
        """Valida Node.js (requerido para Wappalyzer)."""
        tool_name = "node"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            path = shutil.which("node")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="Node.js no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            result = subprocess.run(
                ["node", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                version = result.stdout.strip()
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}"
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _validate_npm(self) -> None:
        """Valida npm (requerido para instalar Wappalyzer)."""
        tool_name = "npm"
        log.info(f"ðŸ” Validando {tool_name}...")
        
        try:
            path = shutil.which("npm")
            if not path:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.UNAVAILABLE,
                    error="npm no encontrado en PATH"
                )
                return
            
            # Verificar versiÃ³n
            result = subprocess.run(
                ["npm", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                version = result.stdout.strip()
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.AVAILABLE,
                    version=version,
                    path=path,
                    test_passed=True
                )
            else:
                self.tools_info[tool_name] = ToolInfo(
                    name=tool_name,
                    status=ToolStatus.ERROR,
                    path=path,
                    error=f"Error obteniendo versiÃ³n: {result.stderr}"
                )
                
        except Exception as e:
            self.tools_info[tool_name] = ToolInfo(
                name=tool_name,
                status=ToolStatus.ERROR,
                error=f"Error inesperado: {str(e)}"
            )
    
    def _generate_validation_report(self) -> None:
        """Genera reporte de validaciÃ³n."""
        log.info("\n" + "="*60)
        log.info("ðŸ” REPORTE DE VALIDACIÃ“N DE HERRAMIENTAS")
        log.info("="*60)
        
        available_tools = []
        unavailable_tools = []
        error_tools = []
        
        for tool_name, tool_info in self.tools_info.items():
            status_icon = {
                ToolStatus.AVAILABLE: "âœ…",
                ToolStatus.UNAVAILABLE: "âŒ",
                ToolStatus.ERROR: "âš ï¸",
                ToolStatus.UNKNOWN: "â“"
            }.get(tool_info.status, "â“")
            
            log.info(f"{status_icon} {tool_name.upper()}:")
            log.info(f"   Estado: {tool_info.status.value}")
            if tool_info.version:
                log.info(f"   VersiÃ³n: {tool_info.version}")
            if tool_info.path:
                log.info(f"   Ruta: {tool_info.path}")
            if tool_info.response_time > 0:
                log.info(f"   Tiempo respuesta: {tool_info.response_time:.2f}s")
            if tool_info.error:
                log.info(f"   Error: {tool_info.error}")
            log.info("")
            
            # Categorizar herramientas
            if tool_info.status == ToolStatus.AVAILABLE:
                available_tools.append(tool_name)
            elif tool_info.status == ToolStatus.UNAVAILABLE:
                unavailable_tools.append(tool_name)
            else:
                error_tools.append(tool_name)
        
        # Resumen
        log.info("ðŸ“Š RESUMEN:")
        log.info(f"   âœ… Disponibles: {len(available_tools)} - {', '.join(available_tools)}")
        if unavailable_tools:
            log.info(f"   âŒ No disponibles: {len(unavailable_tools)} - {', '.join(unavailable_tools)}")
        if error_tools:
            log.info(f"   âš ï¸ Con errores: {len(error_tools)} - {', '.join(error_tools)}")
        
        # Recomendaciones
        log.info("\nðŸ’¡ RECOMENDACIONES:")
        if "wappalyzer" not in available_tools:
            log.info("   - Instalar Wappalyzer CLI: npm install -g wappalyzer")
        if "whatweb" not in available_tools:
            log.info("   - Instalar WhatWeb segÃºn tu sistema operativo")
        if "httpx" not in available_tools:
            log.info("   - Instalar httpx: go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest")
        
        log.info("="*60)
    
    def get_available_tools(self) -> List[str]:
        """Retorna lista de herramientas disponibles."""
        return [
            name for name, info in self.tools_info.items() 
            if info.status == ToolStatus.AVAILABLE
        ]
    
    def is_tool_available(self, tool_name: str) -> bool:
        """Verifica si una herramienta especÃ­fica estÃ¡ disponible."""
        return (
            tool_name in self.tools_info and 
            self.tools_info[tool_name].status == ToolStatus.AVAILABLE
        )
    
    def get_fallback_tools(self) -> List[str]:
        """Retorna herramientas de fallback disponibles."""
        fallback_priority = ["curl", "httpx"]
        return [
            tool for tool in fallback_priority 
            if self.is_tool_available(tool)
        ]
    
    def export_validation_report(self, output_path: str) -> None:
        """Exporta reporte de validaciÃ³n a archivo JSON."""
        report_data = {
            "timestamp": time.time(),
            "tools": {
                name: {
                    "status": info.status.value,
                    "version": info.version,
                    "path": info.path,
                    "error": info.error,
                    "test_passed": info.test_passed,
                    "response_time": info.response_time
                }
                for name, info in self.tools_info.items()
            },
            "summary": {
                "available": self.get_available_tools(),
                "total_tools": len(self.tools_info),
                "available_count": len(self.get_available_tools())
            }
        }
        
        with open(output_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        log.info(f"ðŸ“„ Reporte exportado a: {output_path}")


def validate_tools(timeout: int = 30) -> Dict[str, ToolInfo]:
    """FunciÃ³n de conveniencia para validar todas las herramientas."""
    validator = ExternalToolValidator(timeout=timeout)
    return validator.validate_all_tools()


if __name__ == "__main__":
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s"
    )
    
    # Ejecutar validaciÃ³n
    validator = ExternalToolValidator()
    tools_info = validator.validate_all_tools()
    
    # Exportar reporte
    validator.export_validation_report("tool_validation_report.json")
    
    # Mostrar herramientas disponibles
    available = validator.get_available_tools()
    print(f"\nðŸŽ¯ Herramientas disponibles para detecciÃ³n mejorada: {len(available)}")
    for tool in available:
        print(f"   âœ… {tool}")