#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Manejador avanzado de WAF (Web Application Firewall)
Incluye detección y técnicas de evasión específicas para Cloudflare y otros WAF.
"""

import logging
import random
import time
import re
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse, urljoin
from pathlib import Path
import json

import httpx
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from pentest.config import WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS
from pentest.exceptions import SecurityConfigError

log = logging.getLogger(__name__)

class WAFType:
    """Tipos de WAF detectados."""
    CLOUDFLARE = "cloudflare"
    AWS_WAF = "aws_waf"
    AKAMAI = "akamai"
    INCAPSULA = "incapsula"
    BARRACUDA = "barracuda"
    F5_BIG_IP = "f5_big_ip"
    SUCURI = "sucuri"
    UNKNOWN = "unknown"
    NONE = "none"

class WAFDetector:
    """Detector de WAF basado en headers, cookies y patrones de respuesta."""
    
    # Patrones de detección de WAF
    WAF_SIGNATURES = {
        WAFType.CLOUDFLARE: {
            'headers': {
                'server': [r'cloudflare', r'cloudflare-nginx'],
                'cf-ray': [r'.*'],
                'cf-cache-status': [r'.*'],
                'cf-request-id': [r'.*']
            },
            'cookies': [r'__cfduid', r'__cf_bm', r'cf_clearance'],
            'content': [
                r'cloudflare',
                r'cdn-cgi/l/email-protection',
                r'Performance & Security by Cloudflare',
                r'DDoS protection by Cloudflare'
            ],
            'status_codes': [403, 503, 520, 521, 522, 523, 524, 525]
        },
        WAFType.AWS_WAF: {
            'headers': {
                'server': [r'awselb', r'aws'],
                'x-amzn-requestid': [r'.*'],
                'x-amz-cf-id': [r'.*']
            },
            'content': [r'AWS', r'Request blocked'],
            'status_codes': [403]
        },
        WAFType.AKAMAI: {
            'headers': {
                'server': [r'AkamaiGHost'],
                'x-akamai-transformed': [r'.*']
            },
            'content': [r'Reference #[0-9a-f\.]+'],
            'status_codes': [403]
        },
        WAFType.INCAPSULA: {
            'headers': {
                'x-iinfo': [r'.*'],
                'x-cdn': [r'Incapsula']
            },
            'cookies': [r'incap_ses', r'visid_incap'],
            'content': [r'Incapsula', r'Request unsuccessful'],
            'status_codes': [403]
        },
        WAFType.BARRACUDA: {
            'headers': {
                'server': [r'BARRA', r'Barracuda']
            },
            'content': [r'Barracuda', r'You have been blocked'],
            'status_codes': [403]
        },
        WAFType.F5_BIG_IP: {
            'headers': {
                'server': [r'BigIP', r'F5-TrafficShield']
            },
            'cookies': [r'BIGipServer', r'F5_fullWT', r'F5_ST'],
            'content': [r'The requested URL was rejected'],
            'status_codes': [403]
        },
        WAFType.SUCURI: {
            'headers': {
                'server': [r'Sucuri', r'cloudproxy']
            },
            'content': [r'Sucuri', r'Access Denied - Sucuri'],
            'status_codes': [403]
        }
    }
    
    @classmethod
    def detect_waf(cls, response: requests.Response) -> Tuple[str, Dict[str, Any]]:
        """Detecta el tipo de WAF basado en la respuesta HTTP.
        
        Args:
            response: Respuesta HTTP de requests
            
        Returns:
            Tuple con (tipo_waf, detalles_deteccion)
        """
        detection_details = {
            'detected_patterns': [],
            'confidence': 0,
            'evidence': {}
        }
        
        headers = {k.lower(): v for k, v in response.headers.items()}
        content = response.text.lower() if hasattr(response, 'text') else ''
        status_code = response.status_code
        
        for waf_type, signatures in cls.WAF_SIGNATURES.items():
            confidence = 0
            evidence = []
            
            # Verificar headers
            if 'headers' in signatures:
                for header_name, patterns in signatures['headers'].items():
                    if header_name in headers:
                        for pattern in patterns:
                            if re.search(pattern, headers[header_name], re.IGNORECASE):
                                confidence += 30
                                evidence.append(f"Header {header_name}: {headers[header_name]}")
            
            # Verificar cookies
            if 'cookies' in signatures:
                cookies_str = headers.get('set-cookie', '')
                for cookie_pattern in signatures['cookies']:
                    if re.search(cookie_pattern, cookies_str, re.IGNORECASE):
                        confidence += 25
                        evidence.append(f"Cookie pattern: {cookie_pattern}")
            
            # Verificar contenido
            if 'content' in signatures:
                for content_pattern in signatures['content']:
                    if re.search(content_pattern, content, re.IGNORECASE):
                        confidence += 20
                        evidence.append(f"Content pattern: {content_pattern}")
            
            # Verificar códigos de estado
            if 'status_codes' in signatures and status_code in signatures['status_codes']:
                confidence += 10
                evidence.append(f"Status code: {status_code}")
            
            if confidence > detection_details['confidence']:
                detection_details['confidence'] = confidence
                detection_details['detected_patterns'] = evidence
                detection_details['evidence'] = {
                    'waf_type': waf_type,
                    'confidence': confidence,
                    'patterns': evidence
                }
                
                if confidence >= 50:  # Umbral de confianza
                    return waf_type, detection_details
        
        return WAFType.NONE if detection_details['confidence'] < 30 else WAFType.UNKNOWN, detection_details

class WAFEvasionTechniques:
    """Técnicas específicas de evasión para diferentes tipos de WAF."""
    
    # Técnicas específicas por tipo de WAF
    EVASION_STRATEGIES = {
        WAFType.CLOUDFLARE: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)',
                'Mozilla/5.0 (compatible; facebookexternalhit/1.1; +http://www.facebook.com/externalhit_uatext.php)',
                'facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php)',
                'Twitterbot/1.0'
            ],
            'headers': {
                'CF-Connecting-IP': '127.0.0.1',
                'CF-IPCountry': 'US',
                'X-Forwarded-For': '127.0.0.1',
                'X-Real-IP': '127.0.0.1',
                'X-Originating-IP': '127.0.0.1'
            },
            'delays': {'min': 2, 'max': 5},
            'max_requests_per_minute': 10
        },
        WAFType.AWS_WAF: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'curl/7.68.0',
                'Wget/1.20.3'
            ],
            'headers': {
                'X-Forwarded-For': '127.0.0.1',
                'X-Real-IP': '127.0.0.1'
            },
            'delays': {'min': 1, 'max': 3},
            'max_requests_per_minute': 20
        },
        WAFType.AKAMAI: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            ],
            'headers': {
                'Akamai-Origin-Hop': '1',
                'X-Forwarded-For': '127.0.0.1'
            },
            'delays': {'min': 3, 'max': 6},
            'max_requests_per_minute': 8
        }
    }
    
    @classmethod
    def get_evasion_config(cls, waf_type: str) -> Dict[str, Any]:
        """Obtiene la configuración de evasión para un tipo específico de WAF.
        
        Args:
            waf_type: Tipo de WAF detectado
            
        Returns:
            Configuración de evasión específica
        """
        if waf_type in cls.EVASION_STRATEGIES:
            return cls.EVASION_STRATEGIES[waf_type]
        
        # Configuración por defecto
        return {
            'user_agents': WAF_USER_AGENTS,
            'headers': {},
            'delays': {'min': 1, 'max': 3},
            'max_requests_per_minute': 15
        }

class WAFAwareHTTPClient:
    """Cliente HTTP que se adapta automáticamente a diferentes tipos de WAF."""
    
    def __init__(self):
        self.detected_wafs = {}  # Cache de WAF detectados por dominio
        self.request_history = {}  # Historial de peticiones por dominio
        
    def _get_domain(self, url: str) -> str:
        """Extrae el dominio de una URL."""
        return urlparse(url).netloc
    
    def _should_throttle(self, domain: str, waf_config: Dict[str, Any]) -> bool:
        """Determina si se debe aplicar throttling basado en el historial."""
        if domain not in self.request_history:
            self.request_history[domain] = []
        
        now = time.time()
        # Limpiar peticiones antiguas (más de 1 minuto)
        self.request_history[domain] = [
            req_time for req_time in self.request_history[domain] 
            if now - req_time < 60
        ]
        
        max_requests = waf_config.get('max_requests_per_minute', 15)
        return len(self.request_history[domain]) >= max_requests
    
    def _apply_throttling(self, domain: str, waf_config: Dict[str, Any]):
        """Aplica throttling si es necesario."""
        if self._should_throttle(domain, waf_config):
            delay = random.uniform(10, 20)  # Espera más tiempo si se alcanza el límite
            log.info(f"Aplicando throttling para {domain}: esperando {delay:.1f}s")
            time.sleep(delay)
        else:
            delays = waf_config.get('delays', {'min': 1, 'max': 3})
            delay = random.uniform(delays['min'], delays['max'])
            time.sleep(delay)
        
        # Registrar la petición
        self.request_history[domain].append(time.time())
    
    def make_request(self, url: str, method: str = 'GET', **kwargs) -> requests.Response:
        """Realiza una petición HTTP adaptada al WAF detectado.
        
        Args:
            url: URL objetivo
            method: Método HTTP
            **kwargs: Argumentos adicionales para requests
            
        Returns:
            Respuesta HTTP
        """
        domain = self._get_domain(url)
        
        # Detectar WAF si no se ha hecho antes
        if domain not in self.detected_wafs:
            try:
                # Petición inicial para detectar WAF
                initial_response = requests.get(
                    url, 
                    timeout=10, 
                    verify=False, 
                    allow_redirects=True
                )
                waf_type, detection_details = WAFDetector.detect_waf(initial_response)
                self.detected_wafs[domain] = {
                    'type': waf_type,
                    'details': detection_details
                }
                log.info(f"WAF detectado para {domain}: {waf_type} (confianza: {detection_details['confidence']}%)")
            except Exception as e:
                log.warning(f"Error detectando WAF para {domain}: {e}")
                self.detected_wafs[domain] = {'type': WAFType.UNKNOWN, 'details': {}}
        
        waf_info = self.detected_wafs[domain]
        waf_type = waf_info['type']
        
        # Obtener configuración de evasión
        evasion_config = WAFEvasionTechniques.get_evasion_config(waf_type)
        
        # Aplicar throttling
        self._apply_throttling(domain, evasion_config)
        
        # Configurar headers específicos para el WAF
        headers = WAF_COMMON_HEADERS.copy()
        headers.update(evasion_config.get('headers', {}))
        
        # Seleccionar User-Agent específico para el WAF
        waf_user_agents = evasion_config.get('user_agents', WAF_USER_AGENTS)
        headers['User-Agent'] = random.choice(waf_user_agents)
        
        # Merge con headers personalizados
        if 'headers' in kwargs:
            headers.update(kwargs['headers'])
        kwargs['headers'] = headers
        
        # Configurar otros parámetros
        kwargs.setdefault('timeout', WAF_EVASION_CONFIG['max_time'])
        kwargs.setdefault('verify', False)
        kwargs.setdefault('allow_redirects', True)
        
        # Realizar la petición con reintentos
        max_retries = WAF_EVASION_CONFIG.get('retry_attempts', 2)
        
        for attempt in range(max_retries + 1):
            try:
                if attempt > 0:
                    retry_delay = WAF_EVASION_CONFIG.get('retry_delay', 2) * attempt
                    log.debug(f"Reintentando petición a {url} en {retry_delay}s (intento {attempt + 1})")
                    time.sleep(retry_delay)
                
                response = requests.request(method, url, **kwargs)
                
                # Verificar si la respuesta indica bloqueo por WAF
                if self._is_waf_blocked(response, waf_type):
                    log.warning(f"Petición bloqueada por WAF en {url} (intento {attempt + 1})")
                    if attempt < max_retries:
                        continue
                
                return response
                
            except requests.exceptions.RequestException as e:
                if attempt == max_retries:
                    raise
                log.debug(f"Error en petición a {url}: {e}. Reintentando...")
        
        raise requests.exceptions.RequestException(f"Falló después de {max_retries + 1} intentos")
    
    def _is_waf_blocked(self, response: requests.Response, waf_type: str) -> bool:
        """Determina si la respuesta indica un bloqueo por WAF.
        
        Args:
            response: Respuesta HTTP
            waf_type: Tipo de WAF detectado
            
        Returns:
            True si la respuesta indica bloqueo por WAF
        """
        # Códigos de estado que indican bloqueo
        blocked_status_codes = [403, 406, 429, 503, 520, 521, 522, 523, 524, 525]
        
        if response.status_code in blocked_status_codes:
            # Verificar patrones específicos en el contenido
            content = response.text.lower() if hasattr(response, 'text') else ''
            
            blocked_patterns = [
                'access denied', 'blocked', 'forbidden', 'rate limit',
                'too many requests', 'security policy', 'firewall',
                'cloudflare', 'incapsula', 'sucuri', 'akamai'
            ]
            
            for pattern in blocked_patterns:
                if pattern in content:
                    return True
        
        return False

# Instancia global del cliente WAF-aware
waf_client = WAFAwareHTTPClient()

def make_waf_aware_request(url: str, method: str = 'GET', **kwargs) -> requests.Response:
    """Función de conveniencia para realizar peticiones con evasión WAF.
    
    Args:
        url: URL objetivo
        method: Método HTTP
        **kwargs: Argumentos adicionales para requests
        
    Returns:
        Respuesta HTTP
    """
    return waf_client.make_request(url, method, **kwargs)

def detect_waf_for_domain(domain: str) -> Dict[str, Any]:
    """Detecta el WAF para un dominio específico.
    
    Args:
        domain: Dominio a analizar
        
    Returns:
        Información del WAF detectado
    """
    try:
        url = f"https://{domain}" if not domain.startswith('http') else domain
        response = requests.get(url, timeout=10, verify=False)
        waf_type, details = WAFDetector.detect_waf(response)
        
        return {
            'domain': domain,
            'waf_type': waf_type,
            'detection_details': details,
            'evasion_config': WAFEvasionTechniques.get_evasion_config(waf_type)
        }
    except Exception as e:
        log.error(f"Error detectando WAF para {domain}: {e}")
        return {
            'domain': domain,
            'waf_type': WAFType.UNKNOWN,
            'detection_details': {'error': str(e)},
            'evasion_config': WAFEvasionTechniques.get_evasion_config(WAFType.UNKNOWN)
        }

def save_waf_analysis(domains: List[str], output_file: Path) -> Path:
    """Analiza y guarda información de WAF para múltiples dominios.
    
    Args:
        domains: Lista de dominios a analizar
        output_file: Archivo donde guardar los resultados
        
    Returns:
        Path al archivo de resultados
    """
    log.info(f"🛡️ Analizando WAF para {len(domains)} dominios")
    
    results = []
    for domain in domains:
        log.info(f"Analizando WAF para {domain}")
        waf_info = detect_waf_for_domain(domain)
        results.append(waf_info)
        
        # Pequeña pausa entre análisis
        time.sleep(random.uniform(1, 2))
    
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    log.info(f"✅ Análisis de WAF completado. Resultados guardados en {output_file}")
    return output_file