#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Manejador avanzado de WAF (Web Application Firewall)
Incluye detecci√≥n y t√©cnicas de evasi√≥n espec√≠ficas para Cloudflare y otros WAF.
"""

import logging
import random
import time
import re
import asyncio
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse, urljoin
from pathlib import Path
import json

import httpx
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from pentest.config import WAF_EVASION_CONFIG, WAF_USER_AGENTS, WAF_COMMON_HEADERS
from pentest.exceptions import SecurityConfigError

log = logging.getLogger(__name__)

class WAFType:
    """Tipos de WAF detectados."""
    CLOUDFLARE = "cloudflare"
    AWS_WAF = "aws_waf"
    AKAMAI = "akamai"
    INCAPSULA = "incapsula"
    BARRACUDA = "barracuda"
    F5_BIG_IP = "f5_big_ip"
    SUCURI = "sucuri"
    UNKNOWN = "unknown"
    NONE = "none"

class WAFDetector:
    """Detector de WAF basado en headers, cookies y patrones de respuesta."""
    
    # Patrones de detecci√≥n de WAF
    WAF_SIGNATURES = {
        WAFType.CLOUDFLARE: {
            'headers': {
                'server': [r'cloudflare', r'cloudflare-nginx'],
                'cf-ray': [r'.*'],
                'cf-cache-status': [r'.*'],
                'cf-request-id': [r'.*']
            },
            'cookies': [r'__cfduid', r'__cf_bm', r'cf_clearance'],
            'content': [
                r'cloudflare',
                r'cdn-cgi/l/email-protection',
                r'Performance & Security by Cloudflare',
                r'DDoS protection by Cloudflare'
            ],
            'status_codes': [403, 503, 520, 521, 522, 523, 524, 525]
        },
        WAFType.AWS_WAF: {
            'headers': {
                'server': [r'awselb', r'aws'],
                'x-amzn-requestid': [r'.*'],
                'x-amz-cf-id': [r'.*']
            },
            'content': [r'AWS', r'Request blocked'],
            'status_codes': [403]
        },
        WAFType.AKAMAI: {
            'headers': {
                'server': [r'AkamaiGHost'],
                'x-akamai-transformed': [r'.*']
            },
            'content': [r'Reference #[0-9a-f\.]+'],
            'status_codes': [403]
        },
        WAFType.INCAPSULA: {
            'headers': {
                'x-iinfo': [r'.*'],
                'x-cdn': [r'Incapsula']
            },
            'cookies': [r'incap_ses', r'visid_incap'],
            'content': [r'Incapsula', r'Request unsuccessful'],
            'status_codes': [403]
        },
        WAFType.BARRACUDA: {
            'headers': {
                'server': [r'BARRA', r'Barracuda']
            },
            'content': [r'Barracuda', r'You have been blocked'],
            'status_codes': [403]
        },
        WAFType.F5_BIG_IP: {
            'headers': {
                'server': [r'BigIP', r'F5-TrafficShield']
            },
            'cookies': [r'BIGipServer', r'F5_fullWT', r'F5_ST'],
            'content': [r'The requested URL was rejected'],
            'status_codes': [403]
        },
        WAFType.SUCURI: {
            'headers': {
                'server': [r'Sucuri', r'cloudproxy']
            },
            'content': [r'Sucuri', r'Access Denied - Sucuri'],
            'status_codes': [403]
        }
    }
    
    @classmethod
    def detect_waf(cls, response: requests.Response) -> Tuple[str, Dict[str, Any]]:
        """Detecta el tipo de WAF basado en la respuesta HTTP.
        
        Args:
            response: Respuesta HTTP de requests
            
        Returns:
            Tuple con (tipo_waf, detalles_deteccion)
        """
        detection_details = {
            'detected_patterns': [],
            'confidence': 0,
            'evidence': {}
        }
        
        headers = {k.lower(): v for k, v in response.headers.items()}
        content = response.text.lower() if hasattr(response, 'text') else ''
        status_code = response.status_code
        
        for waf_type, signatures in cls.WAF_SIGNATURES.items():
            confidence = 0
            evidence = []
            
            # Verificar headers
            if 'headers' in signatures:
                for header_name, patterns in signatures['headers'].items():
                    if header_name in headers:
                        for pattern in patterns:
                            if re.search(pattern, headers[header_name], re.IGNORECASE):
                                confidence += 30
                                evidence.append(f"Header {header_name}: {headers[header_name]}")
            
            # Verificar cookies
            if 'cookies' in signatures:
                cookies_str = headers.get('set-cookie', '')
                for cookie_pattern in signatures['cookies']:
                    if re.search(cookie_pattern, cookies_str, re.IGNORECASE):
                        confidence += 25
                        evidence.append(f"Cookie pattern: {cookie_pattern}")
            
            # Verificar contenido
            if 'content' in signatures:
                for content_pattern in signatures['content']:
                    if re.search(content_pattern, content, re.IGNORECASE):
                        confidence += 20
                        evidence.append(f"Content pattern: {content_pattern}")
            
            # Verificar c√≥digos de estado
            if 'status_codes' in signatures and status_code in signatures['status_codes']:
                confidence += 10
                evidence.append(f"Status code: {status_code}")
            
            if confidence > detection_details['confidence']:
                detection_details['confidence'] = confidence
                detection_details['detected_patterns'] = evidence
                detection_details['evidence'] = {
                    'waf_type': waf_type,
                    'confidence': confidence,
                    'patterns': evidence
                }
                
                if confidence >= 50:  # Umbral de confianza
                    return waf_type, detection_details
        
        return WAFType.NONE if detection_details['confidence'] < 30 else WAFType.UNKNOWN, detection_details

class WAFEvasionTechniques:
    """T√©cnicas espec√≠ficas de evasi√≥n para diferentes tipos de WAF."""
    
    # T√©cnicas espec√≠ficas por tipo de WAF
    EVASION_STRATEGIES = {
        WAFType.CLOUDFLARE: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)',
                'Mozilla/5.0 (compatible; facebookexternalhit/1.1; +http://www.facebook.com/externalhit_uatext.php)',
                'facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php)',
                'Twitterbot/1.0'
            ],
            'headers': {
                'CF-Connecting-IP': '127.0.0.1',
                'CF-IPCountry': 'US',
                'X-Forwarded-For': '127.0.0.1',
                'X-Real-IP': '127.0.0.1',
                'X-Originating-IP': '127.0.0.1'
            },
            'delays': {'min': 2, 'max': 5},
            'max_requests_per_minute': 10
        },
        WAFType.AWS_WAF: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'curl/7.68.0',
                'Wget/1.20.3'
            ],
            'headers': {
                'X-Forwarded-For': '127.0.0.1',
                'X-Real-IP': '127.0.0.1'
            },
            'delays': {'min': 1, 'max': 3},
            'max_requests_per_minute': 20
        },
        WAFType.AKAMAI: {
            'user_agents': [
                'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            ],
            'headers': {
                'Akamai-Origin-Hop': '1',
                'X-Forwarded-For': '127.0.0.1'
            },
            'delays': {'min': 3, 'max': 6},
            'max_requests_per_minute': 8
        }
    }
    
    @classmethod
    def get_evasion_config(cls, waf_type: str) -> Dict[str, Any]:
        """Obtiene la configuraci√≥n de evasi√≥n para un tipo espec√≠fico de WAF.
        
        Args:
            waf_type: Tipo de WAF detectado
            
        Returns:
            Configuraci√≥n de evasi√≥n espec√≠fica
        """
        if waf_type in cls.EVASION_STRATEGIES:
            return cls.EVASION_STRATEGIES[waf_type]
        
        # Configuraci√≥n por defecto
        return {
            'user_agents': WAF_USER_AGENTS,
            'headers': {},
            'delays': {'min': 1, 'max': 3},
            'max_requests_per_minute': 15
        }

class WAFAwareHTTPClient:
    """Cliente HTTP que se adapta autom√°ticamente a diferentes tipos de WAF."""
    
    def __init__(self):
        self.detected_wafs = {}  # Cache de WAF detectados por dominio
        self.request_history = {}  # Historial de peticiones por dominio
        
    def _get_domain(self, url: str) -> str:
        """Extrae el dominio de una URL."""
        return urlparse(url).netloc
    
    def _should_throttle(self, domain: str, waf_config: Dict[str, Any]) -> bool:
        """Determina si se debe aplicar throttling basado en el historial."""
        if domain not in self.request_history:
            self.request_history[domain] = []
        
        now = time.time()
        # Limpiar peticiones antiguas (m√°s de 1 minuto)
        self.request_history[domain] = [
            req_time for req_time in self.request_history[domain] 
            if now - req_time < 60
        ]
        
        max_requests = waf_config.get('max_requests_per_minute', 15)
        return len(self.request_history[domain]) >= max_requests
    
    def _apply_throttling(self, domain: str, waf_config: Dict[str, Any]):
        """Aplica throttling si es necesario."""
        if self._should_throttle(domain, waf_config):
            delay = random.uniform(10, 20)  # Espera m√°s tiempo si se alcanza el l√≠mite
            log.info(f"Aplicando throttling para {domain}: esperando {delay:.1f}s")
            time.sleep(delay)
        else:
            delays = waf_config.get('delays', {'min': 1, 'max': 3})
            delay = random.uniform(delays['min'], delays['max'])
            time.sleep(delay)
        
        # Registrar la petici√≥n
        self.request_history[domain].append(time.time())
    
    def make_request(self, url: str, method: str = 'GET', **kwargs) -> requests.Response:
        """Realiza una petici√≥n HTTP adaptada al WAF detectado.
        
        Args:
            url: URL objetivo
            method: M√©todo HTTP
            **kwargs: Argumentos adicionales para requests
            
        Returns:
            Respuesta HTTP
        """
        domain = self._get_domain(url)
        
        # Detectar WAF si no se ha hecho antes
        if domain not in self.detected_wafs:
            try:
                # Petici√≥n inicial para detectar WAF
                initial_response = requests.get(
                    url, 
                    timeout=10, 
                    verify=False, 
                    allow_redirects=True
                )
                waf_type, detection_details = WAFDetector.detect_waf(initial_response)
                self.detected_wafs[domain] = {
                    'type': waf_type,
                    'details': detection_details
                }
                log.info(f"WAF detectado para {domain}: {waf_type} (confianza: {detection_details['confidence']}%)")
            except Exception as e:
                log.warning(f"Error detectando WAF para {domain}: {e}")
                self.detected_wafs[domain] = {'type': WAFType.UNKNOWN, 'details': {}}
        
        waf_info = self.detected_wafs[domain]
        waf_type = waf_info['type']
        
        # Obtener configuraci√≥n de evasi√≥n
        evasion_config = WAFEvasionTechniques.get_evasion_config(waf_type)
        
        # Aplicar throttling
        self._apply_throttling(domain, evasion_config)
        
        # Configurar headers espec√≠ficos para el WAF
        headers = WAF_COMMON_HEADERS.copy()
        headers.update(evasion_config.get('headers', {}))
        
        # Seleccionar User-Agent espec√≠fico para el WAF
        waf_user_agents = evasion_config.get('user_agents', WAF_USER_AGENTS)
        headers['User-Agent'] = random.choice(waf_user_agents)
        
        # Merge con headers personalizados
        if 'headers' in kwargs:
            headers.update(kwargs['headers'])
        kwargs['headers'] = headers
        
        # Configurar otros par√°metros
        kwargs.setdefault('timeout', WAF_EVASION_CONFIG['max_time'])
        kwargs.setdefault('verify', False)
        kwargs.setdefault('allow_redirects', True)
        
        # Realizar la petici√≥n con reintentos
        max_retries = WAF_EVASION_CONFIG.get('retry_attempts', 2)
        
        for attempt in range(max_retries + 1):
            try:
                if attempt > 0:
                    retry_delay = WAF_EVASION_CONFIG.get('retry_delay', 2) * attempt
                    log.debug(f"Reintentando petici√≥n a {url} en {retry_delay}s (intento {attempt + 1})")
                    time.sleep(retry_delay)
                
                response = requests.request(method, url, **kwargs)
                
                # Verificar si la respuesta indica bloqueo por WAF
                if self._is_waf_blocked(response, waf_type):
                    log.warning(f"Petici√≥n bloqueada por WAF en {url} (intento {attempt + 1})")
                    if attempt < max_retries:
                        continue
                
                return response
                
            except requests.exceptions.RequestException as e:
                if attempt == max_retries:
                    raise
                log.debug(f"Error en petici√≥n a {url}: {e}. Reintentando...")
        
        raise requests.exceptions.RequestException(f"Fall√≥ despu√©s de {max_retries + 1} intentos")
    
    def _is_waf_blocked(self, response: requests.Response, waf_type: str) -> bool:
        """Determina si la respuesta indica un bloqueo por WAF.
        
        Args:
            response: Respuesta HTTP
            waf_type: Tipo de WAF detectado
            
        Returns:
            True si la respuesta indica bloqueo por WAF
        """
        # C√≥digos de estado que indican bloqueo
        blocked_status_codes = [403, 406, 429, 503, 520, 521, 522, 523, 524, 525]
        
        if response.status_code in blocked_status_codes:
            # Verificar patrones espec√≠ficos en el contenido
            content = response.text.lower() if hasattr(response, 'text') else ''
            
            blocked_patterns = [
                'access denied', 'blocked', 'forbidden', 'rate limit',
                'too many requests', 'security policy', 'firewall',
                'cloudflare', 'incapsula', 'sucuri', 'akamai'
            ]
            
            for pattern in blocked_patterns:
                if pattern in content:
                    return True
        
        return False

# Instancia global del cliente WAF-aware
waf_client = WAFAwareHTTPClient()

def make_waf_aware_request(url: str, method: str = 'GET', **kwargs) -> requests.Response:
    """Funci√≥n de conveniencia para realizar peticiones con evasi√≥n WAF.
    
    Args:
        url: URL objetivo
        method: M√©todo HTTP
        **kwargs: Argumentos adicionales para requests
        
    Returns:
        Respuesta HTTP
    """
    return waf_client.make_request(url, method, **kwargs)

def detect_waf_for_domain(domain: str) -> Dict[str, Any]:
    """Detecta el WAF para un dominio espec√≠fico.
    
    Args:
        domain: Dominio a analizar
        
    Returns:
        Informaci√≥n del WAF detectado
    """
    try:
        url = f"https://{domain}" if not domain.startswith('http') else domain
        response = requests.get(url, timeout=10, verify=False)
        waf_type, details = WAFDetector.detect_waf(response)
        
        return {
            'domain': domain,
            'waf_type': waf_type,
            'detection_details': details,
            'evasion_config': WAFEvasionTechniques.get_evasion_config(waf_type)
        }
    except Exception as e:
        log.error(f"Error detectando WAF para {domain}: {e}")
        return {
            'domain': domain,
            'waf_type': WAFType.UNKNOWN,
            'detection_details': {'error': str(e)},
            'evasion_config': WAFEvasionTechniques.get_evasion_config(WAFType.UNKNOWN)
        }

def save_waf_analysis(domains: List[str], output_file: Path) -> Path:
    """Analiza y guarda informaci√≥n de WAF para m√∫ltiples dominios.
    
    Args:
        domains: Lista de dominios a analizar
        output_file: Archivo donde guardar los resultados
        
    Returns:
        Path al archivo de resultados
    """
    log.info(f"üõ°Ô∏è Analizando WAF para {len(domains)} dominios")
    
    results = []
    for domain in domains:
        log.info(f"Analizando WAF para {domain}")
        waf_info = detect_waf_for_domain(domain)
        results.append(waf_info)
        
        # Peque√±a pausa entre an√°lisis
        time.sleep(random.uniform(1, 2))
    
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    log.info(f"‚úÖ An√°lisis de WAF completado. Resultados guardados en {output_file}")
    return output_file