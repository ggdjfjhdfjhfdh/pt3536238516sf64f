#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Integraci√≥n del manejo avanzado de WAF con el sistema de pentesting existente.
Este m√≥dulo modifica las funciones existentes para usar el nuevo WAFAwareHTTPClient.
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional
from pathlib import Path
import json

from pentest.waf_handler import (
    WAFAwareHTTPClient, 
    WAFDetector, 
    WAFType,
    make_waf_aware_request,
    detect_waf_for_domain
)
from pentest.config import WAF_EVASION_CONFIG

log = logging.getLogger(__name__)

class WAFIntegratedScanner:
    """Scanner integrado con capacidades avanzadas de evasi√≥n WAF."""
    
    def __init__(self):
        self.waf_client = WAFAwareHTTPClient()
        self.scan_results = {}
    
    def detect_waf(self, target_url: str) -> Dict[str, Any]:
        """Detecta el WAF para el objetivo especificado.
        
        Args:
            target_url: URL objetivo
            
        Returns:
            Informaci√≥n del WAF detectado
        """
        log.info(f"üõ°Ô∏è Detectando WAF para {target_url}")
        
        domain = target_url.split('/')[2] if '//' in target_url else target_url
        waf_info = detect_waf_for_domain(domain)
        
        log.info(f"WAF detectado: {waf_info['waf_type']} (confianza: {waf_info['confidence']}%)")
        
        return waf_info
        
    def enhanced_dir_brute(self, target_url: str, wordlist: List[str], 
                          extensions: List[str] = None) -> Dict[str, Any]:
        """Fuerza bruta de directorios con evasi√≥n WAF mejorada.
        
        Args:
            target_url: URL objetivo
            wordlist: Lista de palabras para probar
            extensions: Extensiones de archivo a probar
            
        Returns:
            Resultados del escaneo
        """
        log.info(f"üîç Iniciando dir_brute mejorado para {target_url}")
        
        # Detectar WAF primero
        domain = target_url.split('/')[2] if '//' in target_url else target_url
        waf_info = detect_waf_for_domain(domain)
        
        log.info(f"WAF detectado: {waf_info['waf_type']}")
        
        results = {
            'target': target_url,
            'waf_info': waf_info,
            'found_paths': [],
            'blocked_attempts': 0,
            'total_attempts': 0
        }
        
        extensions = extensions or ['', '.php', '.html', '.asp', '.aspx', '.jsp']
        
        for word in wordlist:
            for ext in extensions:
                test_path = f"{word}{ext}"
                test_url = f"{target_url.rstrip('/')}/{test_path}"
                
                try:
                    response = self.waf_client.make_request(test_url)
                    results['total_attempts'] += 1
                    
                    # Verificar si es un resultado v√°lido
                    if response.status_code in [200, 301, 302, 403]:
                        if response.status_code != 404:
                            path_info = {
                                'path': test_path,
                                'url': test_url,
                                'status_code': response.status_code,
                                'content_length': len(response.content),
                                'content_type': response.headers.get('content-type', '')
                            }
                            results['found_paths'].append(path_info)
                            log.info(f"‚úÖ Encontrado: {test_url} [{response.status_code}]")
                    
                    # Detectar si fue bloqueado
                    if self.waf_client._is_waf_blocked(response, waf_info['waf_type']):
                        results['blocked_attempts'] += 1
                        
                except Exception as e:
                    log.debug(f"Error probando {test_url}: {e}")
                    results['blocked_attempts'] += 1
        
        log.info(f"Dir brute completado: {len(results['found_paths'])} paths encontrados, "
                f"{results['blocked_attempts']} intentos bloqueados de {results['total_attempts']}")
        
        return results
    
    def enhanced_security_config_scan(self, target_url: str) -> Dict[str, Any]:
        """Escaneo de configuraci√≥n de seguridad con evasi√≥n WAF.
        
        Args:
            target_url: URL objetivo
            
        Returns:
            Resultados del an√°lisis de seguridad
        """
        log.info(f"üîí Iniciando escaneo de configuraci√≥n de seguridad para {target_url}")
        
        domain = target_url.split('/')[2] if '//' in target_url else target_url
        waf_info = detect_waf_for_domain(domain)
        
        results = {
            'target': target_url,
            'waf_info': waf_info,
            'security_headers': {},
            'exposed_files': [],
            'server_info': {}
        }
        
        try:
            # Obtener headers de seguridad
            response = self.waf_client.make_request(target_url)
            
            # Analizar headers de seguridad
            security_headers = {
                'X-Frame-Options': response.headers.get('X-Frame-Options'),
                'X-XSS-Protection': response.headers.get('X-XSS-Protection'),
                'X-Content-Type-Options': response.headers.get('X-Content-Type-Options'),
                'Strict-Transport-Security': response.headers.get('Strict-Transport-Security'),
                'Content-Security-Policy': response.headers.get('Content-Security-Policy'),
                'Referrer-Policy': response.headers.get('Referrer-Policy'),
                'Permissions-Policy': response.headers.get('Permissions-Policy')
            }
            
            results['security_headers'] = {k: v for k, v in security_headers.items() if v}
            results['server_info'] = {
                'server': response.headers.get('Server'),
                'powered_by': response.headers.get('X-Powered-By'),
                'technology': response.headers.get('X-Technology')
            }
            
            # Buscar archivos expuestos comunes
            common_files = [
                'robots.txt', 'sitemap.xml', '.htaccess', 'web.config',
                'crossdomain.xml', 'clientaccesspolicy.xml', 'humans.txt',
                '.well-known/security.txt', 'security.txt'
            ]
            
            for file_path in common_files:
                try:
                    file_url = f"{target_url.rstrip('/')}/{file_path}"
                    file_response = self.waf_client.make_request(file_url)
                    
                    if file_response.status_code == 200:
                        results['exposed_files'].append({
                            'file': file_path,
                            'url': file_url,
                            'size': len(file_response.content),
                            'content_type': file_response.headers.get('content-type', '')
                        })
                        log.info(f"üìÑ Archivo expuesto encontrado: {file_path}")
                        
                except Exception as e:
                    log.debug(f"Error verificando {file_path}: {e}")
            
        except Exception as e:
            log.error(f"Error en escaneo de seguridad: {e}")
            results['error'] = str(e)
        
        return results
    
    def enhanced_fingerprint_scan(self, target_url: str) -> Dict[str, Any]:
        """Fingerprinting mejorado con evasi√≥n WAF.
        
        Args:
            target_url: URL objetivo
            
        Returns:
            Informaci√≥n de fingerprinting
        """
        log.info(f"üîç Iniciando fingerprinting mejorado para {target_url}")
        
        domain = target_url.split('/')[2] if '//' in target_url else target_url
        waf_info = detect_waf_for_domain(domain)
        
        results = {
            'target': target_url,
            'waf_info': waf_info,
            'technologies': [],
            'cms_detected': None,
            'server_details': {},
            'ssl_info': {}
        }
        
        try:
            response = self.waf_client.make_request(target_url)
            
            # Detectar tecnolog√≠as por headers
            headers = response.headers
            content = response.text.lower() if hasattr(response, 'text') else ''
            
            # Detectar servidor web
            server = headers.get('Server', '')
            if server:
                results['server_details']['server'] = server
                
                # Detectar versiones espec√≠ficas
                if 'apache' in server.lower():
                    results['technologies'].append('Apache')
                elif 'nginx' in server.lower():
                    results['technologies'].append('Nginx')
                elif 'iis' in server.lower():
                    results['technologies'].append('IIS')
            
            # Detectar tecnolog√≠as por headers espec√≠ficos
            tech_headers = {
                'X-Powered-By': 'powered_by',
                'X-AspNet-Version': 'aspnet_version',
                'X-Technology': 'technology',
                'X-Generator': 'generator'
            }
            
            for header, key in tech_headers.items():
                if header in headers:
                    results['server_details'][key] = headers[header]
                    results['technologies'].append(headers[header])
            
            # Detectar CMS por patrones en contenido
            cms_patterns = {
                'WordPress': [r'wp-content', r'wp-includes', r'/wp-admin'],
                'Drupal': [r'drupal', r'sites/default', r'misc/drupal'],
                'Joomla': [r'joomla', r'administrator', r'components/com_'],
                'Magento': [r'magento', r'skin/frontend', r'js/mage'],
                'PrestaShop': [r'prestashop', r'modules/ps_', r'themes/classic']
            }
            
            for cms, patterns in cms_patterns.items():
                for pattern in patterns:
                    if pattern in content:
                        results['cms_detected'] = cms
                        results['technologies'].append(cms)
                        break
                if results['cms_detected']:
                    break
            
            # Informaci√≥n SSL/TLS
            if target_url.startswith('https'):
                results['ssl_info']['enabled'] = True
                # Aqu√≠ se podr√≠a agregar m√°s an√°lisis SSL
            
        except Exception as e:
            log.error(f"Error en fingerprinting: {e}")
            results['error'] = str(e)
        
        return results

def create_waf_aware_pipeline(target_url: str, output_dir: Path) -> Dict[str, Any]:
    """Pipeline completo de pentesting con evasi√≥n WAF integrada.
    
    Args:
        target_url: URL objetivo
        output_dir: Directorio para guardar resultados
        
    Returns:
        Resultados completos del pipeline
    """
    log.info(f"üöÄ Iniciando pipeline WAF-aware para {target_url}")
    
    scanner = WAFIntegratedScanner()
    
    # Crear directorio de salida
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    pipeline_results = {
        'target': target_url,
        'timestamp': str(Path().cwd()),
        'stages': {}
    }
    
    try:
        # 1. Detecci√≥n inicial de WAF
        log.info("üì° Etapa 1: Detecci√≥n de WAF")
        domain = target_url.split('/')[2] if '//' in target_url else target_url
        waf_info = detect_waf_for_domain(domain)
        pipeline_results['waf_info'] = waf_info
        
        # Guardar informaci√≥n de WAF
        waf_file = output_dir / 'waf_detection.json'
        with open(waf_file, 'w') as f:
            json.dump(waf_info, f, indent=2)
        
        # 2. Fingerprinting
        log.info("üîç Etapa 2: Fingerprinting")
        fingerprint_results = scanner.enhanced_fingerprint_scan(target_url)
        pipeline_results['stages']['fingerprint'] = fingerprint_results
        
        fingerprint_file = output_dir / 'fingerprint.json'
        with open(fingerprint_file, 'w') as f:
            json.dump(fingerprint_results, f, indent=2)
        
        # 3. Configuraci√≥n de seguridad
        log.info("üîí Etapa 3: An√°lisis de configuraci√≥n de seguridad")
        security_results = scanner.enhanced_security_config_scan(target_url)
        pipeline_results['stages']['security_config'] = security_results
        
        security_file = output_dir / 'security_config.json'
        with open(security_file, 'w') as f:
            json.dump(security_results, f, indent=2)
        
        # 4. Directory bruteforce (con wordlist b√°sica)
        log.info("üìÅ Etapa 4: Directory bruteforce")
        basic_wordlist = [
            'admin', 'administrator', 'login', 'panel', 'dashboard',
            'wp-admin', 'phpmyadmin', 'cpanel', 'webmail', 'mail',
            'ftp', 'ssh', 'api', 'backup', 'config', 'test', 'dev'
        ]
        
        dir_brute_results = scanner.enhanced_dir_brute(target_url, basic_wordlist)
        pipeline_results['stages']['dir_brute'] = dir_brute_results
        
        dir_brute_file = output_dir / 'dir_brute.json'
        with open(dir_brute_file, 'w') as f:
            json.dump(dir_brute_results, f, indent=2)
        
        # Resumen final
        pipeline_results['summary'] = {
            'waf_detected': waf_info['waf_type'],
            'technologies_found': len(fingerprint_results.get('technologies', [])),
            'security_headers': len(security_results.get('security_headers', {})),
            'exposed_files': len(security_results.get('exposed_files', [])),
            'directories_found': len(dir_brute_results.get('found_paths', [])),
            'blocked_attempts': dir_brute_results.get('blocked_attempts', 0)
        }
        
        # Guardar resultados completos
        results_file = output_dir / 'pipeline_results.json'
        with open(results_file, 'w') as f:
            json.dump(pipeline_results, f, indent=2)
        
        log.info(f"‚úÖ Pipeline completado. Resultados guardados en {output_dir}")
        
    except Exception as e:
        log.error(f"Error en pipeline: {e}")
        pipeline_results['error'] = str(e)
    
    return pipeline_results

def patch_existing_modules():
    """Aplica parches a los m√≥dulos existentes para usar el cliente WAF-aware.
    
    Esta funci√≥n modifica las importaciones y funciones existentes para usar
    el nuevo sistema de evasi√≥n WAF.
    """
    log.info("üîß Aplicando parches para integraci√≥n WAF")
    
    # Aqu√≠ se pueden agregar parches din√°micos a los m√≥dulos existentes
    # Por ejemplo, reemplazar las funciones de requests en otros m√≥dulos
    
    import pentest.http_utils as http_utils
    import pentest.dir_brute as dir_brute
    import pentest.security_config as security_config
    
    # Reemplazar la funci√≥n de peticiones HTTP en http_utils
    if hasattr(http_utils, 'make_request'):
        http_utils.make_request_original = http_utils.make_request
        http_utils.make_request = make_waf_aware_request
        log.info("‚úÖ Parchado http_utils.make_request")
    
    log.info("üîß Parches aplicados correctamente")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Uso: python waf_integration.py <target_url> [output_dir]")
        sys.exit(1)
    
    target = sys.argv[1]
    output = sys.argv[2] if len(sys.argv) > 2 else f"./waf_scan_{target.replace('://', '_').replace('/', '_')}"
    
    # Configurar logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Ejecutar pipeline
    results = create_waf_aware_pipeline(target, Path(output))
    
    print(f"\nüéØ Resumen del escaneo para {target}:")
    print(f"WAF detectado: {results.get('waf_info', {}).get('waf_type', 'Desconocido')}")
    
    if 'summary' in results:
        summary = results['summary']
        print(f"Tecnolog√≠as encontradas: {summary.get('technologies_found', 0)}")
        print(f"Headers de seguridad: {summary.get('security_headers', 0)}")
        print(f"Archivos expuestos: {summary.get('exposed_files', 0)}")
        print(f"Directorios encontrados: {summary.get('directories_found', 0)}")
        print(f"Intentos bloqueados: {summary.get('blocked_attempts', 0)}")
    
    print(f"\nüìÅ Resultados guardados en: {output}")