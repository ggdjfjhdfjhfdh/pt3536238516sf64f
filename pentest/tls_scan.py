"""M√≥dulo para an√°lisis de configuraci√≥n TLS y certificados."""

import json
import logging
import os
import re
import ssl
import socket
import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

from pentest.exceptions import TLSScanError
from pentest.config import TLS_SCAN_TIMEOUT

from sslyze import ServerScanRequest, ServerNetworkLocation, Scanner
from sslyze.errors import ServerHostnameCouldNotBeResolved
from sslyze import ScanCommand
from sslyze.plugins.fallback_scsv_plugin import FallbackScsvScanCommand
from sslyze.plugins.heartbleed_plugin import HeartbleedScanCommand
from sslyze.plugins.openssl_ccs_injection_plugin import OpenSslCcsInjectionScanCommand
from sslyze.plugins.robot_plugin import RobotScanCommand
from sslyze.plugins.session_renegotiation_plugin import SessionRenegotiationScanCommand
from sslyze.plugins.session_resumption_plugin import SessionResumptionScanCommand
from sslyze.plugins.supported_cipher_suites_plugin import SupportedCipherSuitesScanCommand
from sslyze.plugins.tls_1_3_early_data_plugin import Tls13EarlyDataScanCommand
from sslyze.plugins.tls_compression_plugin import TlsCompressionScanCommand
from sslyze.plugins.http_headers_plugin import HttpHeadersScanCommand
from sslyze.plugins.elliptic_curves_plugin import EllipticCurvesScanCommand



def get_tls_grade_with_sslyze(hostname: str, port: int = 443) -> Optional[str]:
    """Obtiene la calificaci√≥n TLS de un host usando SSLyze.

    Args:
        hostname: El nombre de host a escanear.
        port: El puerto a escanear (por defecto 443).

    Returns:
        La calificaci√≥n TLS (A+, A, B, etc.) o None si no se pudo obtener.
    """
    try:
        server_location = ServerNetworkLocation(hostname=hostname, port=port)
        all_scan_requests = [
            ServerScanRequest(server_location=server_location,
                              scan_commands=[
                                  ScanCommand.CERTIFICATE_INFO,
                                  ScanCommand.SUPPORTED_CIPHER_SUITES,
                                  ScanCommand.FALLBACK_SCSV,
                                  ScanCommand.HEARTBLEED,
                                  ScanCommand.OPENSSL_CCS_INJECTION,
                                  ScanCommand.ROBOT,
                                  ScanCommand.SESSION_RENEGOTIATION,
                                  ScanCommand.SESSION_RESUMPTION,
                                  ScanCommand.TLS_1_3_EARLY_DATA,
                                  ScanCommand.TLS_COMPRESSION,
                                  ScanCommand.HTTP_HEADERS,
                                  ScanCommand.ELLIPTIC_CURVES
                              ])
        ]
    except ServerHostnameCouldNotBeResolved:
        log.warning(f"No se pudo resolver el hostname {hostname}")
        return None

    scanner = Scanner()
    scanner.queue_scans(all_scan_requests)

    for server_scan_result in scanner.get_results():
        if server_scan_result.scan_result:
            # SSLyze no devuelve una calificaci√≥n directa (A+, A, etc.)
            # sino que eval√∫a la configuraci√≥n contra perfiles de Mozilla.
            # Para simplificar, podemos inferir una calificaci√≥n basada en los hallazgos.
            # Esto es una simplificaci√≥n y puede requerir una l√≥gica m√°s compleja.
            # Por ahora, si no hay fallos cr√≠ticos, asumimos una buena calificaci√≥n.
            # Una implementaci√≥n m√°s robusta implicar√≠a analizar cada resultado de comando.

            # Ejemplo muy simplificado de c√≥mo inferir una calificaci√≥n:
            # Si el servidor es compatible con la configuraci√≥n "moderna" de Mozilla, es A+
            # Si es compatible con "intermedia", es A
            # Si es compatible con "antigua", es B
            # Si no es compatible, es F

            # Para obtener una calificaci√≥n real, se necesitar√≠a un an√°lisis m√°s profundo
            # de los resultados de cada ScanCommand y compararlos con criterios de calificaci√≥n.
            # Por ejemplo, sslyze --mozilla_config=modern www.example.com
            # La API no expone directamente esta funcionalidad de "grado" como la CLI.

            # Por simplicidad, vamos a devolver un valor fijo o basado en la presencia de vulnerabilidades cr√≠ticas.
            # Esto es un placeholder y deber√≠a ser mejorado con una l√≥gica de calificaci√≥n real.
            grade = "N/A"
            if server_scan_result.scan_result.heartbleed.result.is_vulnerable:
                grade = "F" # Ejemplo: si es vulnerable a Heartbleed, es F
            elif server_scan_result.scan_result.robot.result.is_vulnerable:
                grade = "F" # Ejemplo: si es vulnerable a ROBOT, es F
            # ... a√±adir m√°s l√≥gica de calificaci√≥n basada en otros resultados
            else:
                grade = "A" # Si no se detectan vulnerabilidades cr√≠ticas, asumimos A

            return grade
    return None



# Configuraci√≥n de logging
log = logging.getLogger(__name__)

# Protocolos TLS a comprobar
TLS_PROTOCOLS = {
    ssl.PROTOCOL_TLSv1: {"name": "TLSv1.0", "obsolete": True},
    ssl.PROTOCOL_TLSv1_1: {"name": "TLSv1.1", "obsolete": True},
    ssl.PROTOCOL_TLSv1_2: {"name": "TLSv1.2", "obsolete": False},
}



def extract_cert_info(cert: Dict[str, Any]) -> Dict[str, Any]:
    """Extrae informaci√≥n relevante de un certificado SSL.
    
    Args:
        cert: Certificado SSL
        
    Returns:
        Diccionario con informaci√≥n del certificado
    """
    # Extraer subject
    subject = dict(x[0] for x in cert['subject'])
    issued_to = subject.get('commonName', '')
    
    # Extraer issuer
    issuer = dict(x[0] for x in cert['issuer'])
    issued_by = issuer.get('commonName', '')
    
    # Extraer fechas de validez
    not_before = datetime.datetime.strptime(cert['notBefore'], '%Y%m%d%H%M%SZ')
    not_after = datetime.datetime.strptime(cert['notAfter'], '%Y%m%d%H%M%SZ')
    
    # Comprobar si est√° expirado o pr√≥ximo a expirar
    now = datetime.datetime.utcnow()
    days_left = (not_after - now).days
    is_expired = now > not_after
    expires_soon = days_left <= 30 and not is_expired
    
    return {
        "subject": issued_to,
        "issuer": issued_by,
        "valid_from": not_before.isoformat(),
        "valid_to": not_after.isoformat(),
        "days_left": days_left,
        "serial_number": cert.get('serialNumber', '').lower(),
        "is_expired": is_expired,
        "expires_soon": expires_soon
    }

def check_tls_protocol(host: str, port: int, protocol: int) -> bool:
    """Comprueba si un host soporta un protocolo TLS espec√≠fico.
    
    Args:
        host: Nombre del host
        port: Puerto
        protocol: Versi√≥n del protocolo TLS
        
    Returns:
        True si el protocolo es soportado, False en caso contrario
    """
    context = ssl.SSLContext(protocol)
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    try:
        with socket.create_connection((host, port), timeout=TLS_SCAN_TIMEOUT) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                return True
    except (socket.timeout, socket.error, ssl.SSLError):
        return False

def get_certificate(host: str, port: int) -> Optional[Dict[str, Any]]:
    """Obtiene el certificado SSL de un host.
    
    Args:
        host: Nombre del host
        port: Puerto
        
    Returns:
        Diccionario con informaci√≥n del certificado o None si no se pudo obtener
    """
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    try:
        with socket.create_connection((host, port), timeout=TLS_SCAN_TIMEOUT) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                cert = ssock.getpeercert(binary_form=False)
                return extract_cert_info(cert) if cert else None
    except (socket.timeout, socket.error, ssl.SSLError) as e:
        log.debug("Error al obtener certificado de %s:%d - %s", host, port, str(e))
        return None

def tls_scan(httpx_file: Path, tmp_dir: Path) -> Path:
    """Analiza la configuraci√≥n TLS y certificados de hosts activos.
    
    Args:
        httpx_file: Archivo JSON con hosts activos
        tmp_dir: Directorio temporal para almacenar resultados
        
    Returns:
        Path al archivo JSON con los resultados del an√°lisis TLS
        
    Raises:
        TLSScanError: Si falla el an√°lisis TLS
    """
    log.info("üîç Iniciando an√°lisis de configuraci√≥n TLS")
    
    output_file = tmp_dir / "tls.json"
    
    # Verificar que el archivo de hosts existe
    if not httpx_file.exists():
        raise TLSScanError(f"Archivo de hosts no encontrado: {httpx_file}")
    
    # Extraer hosts del archivo httpx
    try:
        with open(httpx_file, "r") as f:
            hosts_data = json.load(f)
        
        # Filtrar hosts HTTPS
        https_hosts = []
        for host in hosts_data:
            url = host.get("url", "")
            if url.startswith("https://"):
                # Extraer hostname y puerto
                match = re.match(r"https://([^:/]+)(?::([0-9]+))?", url)
                if match:
                    hostname = match.group(1)
                    port = int(match.group(2)) if match.group(2) else 443
                    https_hosts.append((hostname, port, url))
        
        if not https_hosts:
            log.warning("No se encontraron hosts HTTPS para analizar")
            # Crear un archivo de resultados vac√≠o
            with open(output_file, "w") as f:
                json.dump({"findings": [], "certificates": []}, f, indent=2)
            return output_file
            
        log.info("Analizando %d hosts HTTPS", len(https_hosts))
    except Exception as e:
        raise TLSScanError(f"Error al procesar archivo de hosts: {str(e)}") from e
    
    # Resultados
    findings = []
    certificates = []
    
    # Analizar cada host
    for hostname, port, url in https_hosts:
        host_findings = []
        cert_info = None
        
        # Comprobar protocolos TLS soportados
        supported_protocols = []
        for protocol, info in TLS_PROTOCOLS.items():
            protocol_name = info["name"]
            is_obsolete = info["obsolete"]
            
            try:
                is_supported = check_tls_protocol(hostname, port, protocol)
                
                if is_supported:
                    supported_protocols.append(protocol_name)
                    
                    # A√±adir hallazgo si es un protocolo obsoleto
                    if is_obsolete:
                        host_findings.append({
                            "name": f"Protocolo obsoleto {protocol_name}",
                            "severity": "high",
                            "description": f"El servidor soporta el protocolo obsoleto {protocol_name}, que tiene vulnerabilidades conocidas."
                        })
            except Exception as e:
                log.debug("Error al comprobar protocolo %s en %s:%d - %s", 
                         protocol_name, hostname, port, str(e))
        
        # Obtener informaci√≥n del certificado
        try:
            cert_info = get_certificate(hostname, port)
            
            if cert_info:
                # A√±adir a la lista de certificados
                cert_info["host"] = url
                certificates.append(cert_info)

                # Comprobar si est√° expirado
                if cert_info["is_expired"]:
                    host_findings.append({
                        "name": "Certificado expirado",
                        "severity": "critical",
                        "description": f"El certificado SSL ha expirado el {cert_info['valid_to']}."
                    })
                # Comprobar si expira pronto
                elif cert_info["expires_soon"]:
                    host_findings.append({
                        "name": "Certificado pr√≥ximo a expirar",
                        "severity": "medium",
                        "description": f"El certificado SSL expirar√° en {cert_info['days_left']} d√≠as ({cert_info['valid_to']})."
                    })
        except Exception as e:
            log.debug("Error al obtener informaci√≥n del certificado para %s:%d - %s", hostname, port, str(e))

        # A√±adir hallazgos del host
        for finding in host_findings:
            findings.append({
                "host": url,
                "info": finding
            })

        # Obtener calificaci√≥n TLS con SSLyze
        tls_grade = get_tls_grade_with_sslyze(hostname, port)
        if tls_grade:
            host_findings.append({
                "name": "Calificaci√≥n TLS",
                "severity": "info",
                "description": f"El servidor obtuvo una calificaci√≥n TLS de {tls_grade} seg√∫n SSLyze.",
                "grade": tls_grade
            })

        # A√±adir hallazgos espec√≠ficos del host a la lista general
        if host_findings:
            findings.append({
                "url": url,
                "findings": host_findings
            })

    # Guardar resultados en archivo JSON
    try:
        with open(output_file, "w") as f:
            json.dump({"findings": findings, "certificates": certificates}, f, indent=2)
        log.info("‚úÖ An√°lisis TLS completado. Resultados guardados en %s", output_file)
        return output_file
    except Exception as e:
        raise TLSScanError(f"Error al guardar resultados del an√°lisis TLS: {str(e)}") from e