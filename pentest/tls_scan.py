"""M√≥dulo para an√°lisis de configuraci√≥n TLS y certificados."""

import json
import logging
import os
import re
import ssl
import socket
import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple

from pentest.exceptions import TLSScanError
from pentest.config import TLS_SCAN_TIMEOUT

# Configuraci√≥n de logging
log = logging.getLogger(__name__)

# Protocolos TLS a comprobar
TLS_PROTOCOLS = {
    ssl.PROTOCOL_TLSv1: {"name": "TLSv1.0", "obsolete": True},
    ssl.PROTOCOL_TLSv1_1: {"name": "TLSv1.1", "obsolete": True},
    ssl.PROTOCOL_TLSv1_2: {"name": "TLSv1.2", "obsolete": False},
}

# Intentar a√±adir TLS 1.3 si est√° disponible
try:
    TLS_PROTOCOLS[ssl.PROTOCOL_TLSv1_3] = {"name": "TLSv1.3", "obsolete": False}
except AttributeError:
    log.warning("TLS 1.3 no est√° disponible en esta versi√≥n de Python")

def extract_cert_info(cert: Dict[str, Any]) -> Dict[str, Any]:
    """Extrae informaci√≥n relevante de un certificado SSL.
    
    Args:
        cert: Certificado SSL
        
    Returns:
        Diccionario con informaci√≥n del certificado
    """
    # Extraer subject
    subject = dict(x[0] for x in cert['subject'])
    issued_to = subject.get('commonName', '')
    
    # Extraer issuer
    issuer = dict(x[0] for x in cert['issuer'])
    issued_by = issuer.get('commonName', '')
    
    # Extraer fechas de validez
    not_before = datetime.datetime.strptime(cert['notBefore'], '%Y%m%d%H%M%SZ')
    not_after = datetime.datetime.strptime(cert['notAfter'], '%Y%m%d%H%M%SZ')
    
    # Comprobar si est√° expirado o pr√≥ximo a expirar
    now = datetime.datetime.utcnow()
    days_left = (not_after - now).days
    is_expired = now > not_after
    expires_soon = days_left <= 30 and not is_expired
    
    return {
        "subject": issued_to,
        "issuer": issued_by,
        "valid_from": not_before.isoformat(),
        "valid_to": not_after.isoformat(),
        "days_left": days_left,
        "serial_number": cert.get('serialNumber', '').lower(),
        "is_expired": is_expired,
        "expires_soon": expires_soon
    }

def check_tls_protocol(host: str, port: int, protocol: int) -> bool:
    """Comprueba si un host soporta un protocolo TLS espec√≠fico.
    
    Args:
        host: Nombre del host
        port: Puerto
        protocol: Versi√≥n del protocolo TLS
        
    Returns:
        True si el protocolo es soportado, False en caso contrario
    """
    context = ssl.SSLContext(protocol)
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    try:
        with socket.create_connection((host, port), timeout=TLS_SCAN_TIMEOUT) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                return True
    except (socket.timeout, socket.error, ssl.SSLError):
        return False

def get_certificate(host: str, port: int) -> Optional[Dict[str, Any]]:
    """Obtiene el certificado SSL de un host.
    
    Args:
        host: Nombre del host
        port: Puerto
        
    Returns:
        Diccionario con informaci√≥n del certificado o None si no se pudo obtener
    """
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    try:
        with socket.create_connection((host, port), timeout=TLS_SCAN_TIMEOUT) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                cert = ssock.getpeercert(binary_form=False)
                return extract_cert_info(cert) if cert else None
    except (socket.timeout, socket.error, ssl.SSLError) as e:
        log.debug("Error al obtener certificado de %s:%d - %s", host, port, str(e))
        return None

def tls_scan(httpx_file: Path, tmp_dir: Path) -> Path:
    """Analiza la configuraci√≥n TLS y certificados de hosts activos.
    
    Args:
        httpx_file: Archivo JSON con hosts activos
        tmp_dir: Directorio temporal para almacenar resultados
        
    Returns:
        Path al archivo JSON con los resultados del an√°lisis TLS
        
    Raises:
        TLSScanError: Si falla el an√°lisis TLS
    """
    log.info("üîç Iniciando an√°lisis de configuraci√≥n TLS")
    
    output_file = tmp_dir / "tls.json"
    
    # Verificar que el archivo de hosts existe
    if not httpx_file.exists():
        raise TLSScanError(f"Archivo de hosts no encontrado: {httpx_file}")
    
    # Extraer hosts del archivo httpx
    try:
        with open(httpx_file, "r") as f:
            hosts_data = json.load(f)
        
        # Filtrar hosts HTTPS
        https_hosts = []
        for host in hosts_data:
            url = host.get("url", "")
            if url.startswith("https://"):
                # Extraer hostname y puerto
                match = re.match(r"https://([^:/]+)(?::([0-9]+))?", url)
                if match:
                    hostname = match.group(1)
                    port = int(match.group(2)) if match.group(2) else 443
                    https_hosts.append((hostname, port, url))
        
        if not https_hosts:
            log.warning("No se encontraron hosts HTTPS para analizar")
            # Crear un archivo de resultados vac√≠o
            with open(output_file, "w") as f:
                json.dump({"findings": [], "certificates": []}, f, indent=2)
            return output_file
            
        log.info("Analizando %d hosts HTTPS", len(https_hosts))
    except Exception as e:
        raise TLSScanError(f"Error al procesar archivo de hosts: {str(e)}") from e
    
    # Resultados
    findings = []
    certificates = []
    
    # Analizar cada host
    for hostname, port, url in https_hosts:
        host_findings = []
        cert_info = None
        
        # Comprobar protocolos TLS soportados
        supported_protocols = []
        for protocol, info in TLS_PROTOCOLS.items():
            protocol_name = info["name"]
            is_obsolete = info["obsolete"]
            
            try:
                is_supported = check_tls_protocol(hostname, port, protocol)
                
                if is_supported:
                    supported_protocols.append(protocol_name)
                    
                    # A√±adir hallazgo si es un protocolo obsoleto
                    if is_obsolete:
                        host_findings.append({
                            "name": f"Protocolo obsoleto {protocol_name}",
                            "severity": "high",
                            "description": f"El servidor soporta el protocolo obsoleto {protocol_name}, que tiene vulnerabilidades conocidas."
                        })
            except Exception as e:
                log.debug("Error al comprobar protocolo %s en %s:%d - %s", 
                         protocol_name, hostname, port, str(e))
        
        # Obtener informaci√≥n del certificado
        try:
            cert_info = get_certificate(hostname, port)
            
            if cert_info:
                # A√±adir a la lista de certificados
                cert_info["host"] = url
                certificates.append(cert_info)
                
                # Comprobar si est√° expirado
                if cert_info["is_expired"]:
                    host_findings.append({
                        "name": "Certificado expirado",
                        "severity": "critical",
                        "description": f"El certificado SSL ha expirado el {cert_info['valid_to']}."
                    })
                # Comprobar si expira pronto
                elif cert_info["expires_soon"]:
                    host_findings.append({
                        "name": "Certificado pr√≥ximo a expirar",
                        "severity": "medium",
                        "description": f"El certificado SSL expirar√° en {cert_info['days_left']} d√≠as ({cert_info['valid_to']})."
                    })
        except Exception as e:
            log.debug("Error al obtener certificado de %s:%d - %s", hostname, port, str(e))
        
        # A√±adir hallazgos del host
        for finding in host_findings:
            findings.append({
                "host": url,
                "info": finding
            })
    
    # Guardar resultados
    with open(output_file, "w") as f:
        json.dump({
            "findings": findings,
            "certificates": certificates
        }, f, indent=2)
    
    log.info("‚úÖ An√°lisis TLS completado: %d hallazgos, %d certificados", 
             len(findings), len(certificates))
    return output_file